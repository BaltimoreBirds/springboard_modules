<?php

/**
 * @file sf_queue.module
 * Implements export queue and administrativa for Salesforce API
 */
function sf_queue_menu() {
  return array(
    'admin/reports/sf_queue' => array(
      'title' => 'Salesforce export queue',
      'description' => 'Displays the content of the Salesforce Suite Export queue.',
      'type' => MENU_NORMAL_ITEM,
      'page callback' => 'sf_queue_admin_form',
      'access arguments' => array('administer salesforce'),
      'file' => 'sf_queue.admin.inc',
    ),
    'admin/reports/sf_queue/view' => array(
      'title' => 'Salesforce export queue - View item',
      'description' => 'Displays the content of a Salesforce Suite Export queue item.',
      'type' => MENU_CALLBACK,
      'page callback' => 'sf_queue_admin_view',
      'access arguments' => array('administer salesforce'),
      'file' => 'sf_queue.admin.inc',
    ),
    'admin/reports/sf_queue/delete' => array(
      'title' => 'Salesforce export queue - Delete item',
      'description' => 'Deletes a Salesforce Suite Export queue item.',
      'type' => MENU_CALLBACK,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('sf_queue_admin_delete_confirm', 4),
      'access arguments' => array('administer salesforce'),
      'file' => 'sf_queue.admin.inc',
    ),
    'admin/reports/sf_queue/processqueue' => array(
      'title' => 'Salesforce export queue - Process queue now',
      'description' => 'Processes the Salesforce Suite Export queue now.',
      'type' => MENU_CALLBACK,
      'page callback' => 'sf_queue_process_queue_force',
      'access arguments' => array('administer salesforce'),
    ),
  );

}

/**
 * Implements hook_salesforce_api_export().
 */
function sf_queue_salesforce_api_export($fieldmap, $drupal_id, $drupal_data, $existing = NULL) {
  // If queue is not in use, don't enqueue and don't short-circuit the export.
  if (!variable_get('sf_queue_enabled', FALSE)) {
    watchdog('sf_queue', "Salesforce Export Queue module is enabled but the queue is not.");
    return;
  }
  $op = isset($existing->sfid) ? 'create' : 'update';  // Note that create-op data hasn't been dupe checked yet.
  $settings = variable_get('sf_queue_settings', _sf_queue_default_settings());
  if (!in_array($op, $settings['cron_operations'])) {
    return TRUE;
  }
  return sf_queue_enqueue($op, $drupal_data, $fieldmap, $drupal_id, isset($existing->sfid) ? $existing->sfid : '');
}

/**
 * Implements hook_salesforce_api_post_export().
 */
function sf_queue_salesforce_api_post_export($sf_object, $map, $oid, $response) {
  // If queue is not in use, return;
  // Nothing yet.
}

/**
 * Implements hook_salesforce_api_post_unlink().
 * Change "updates" to "inserts" and remove sfid when objects are unlinked.
 */
function sf_queue_salesforce_api_post_unlink($args) {
  $update = db_update('salesforce_export_queue')
    ->fields(array(
      'sf_op' => 'create',
      'sfid' => '',
    ))
    ->condition('sf_op', 'update', '=')
  ;
  if (!empty($args['oid'])) {
    $update->condition('oid', $args['oid'], '=');
  }
  if (!empty($args['sfid'])) {
    $update->condition('sfid', $args['sfid'], '=');
  }
  if (!empty($args['name'])) {
    $update->condition('fieldmap_name', $args['name'], '=');
  }
  if (!empty($args['drupal_type'])) {
    $update->condition('drupal_type', $args['drupal_type'], '=');
  }
  $update->execute();
}

/**
 * Implements hook_salesforce_api_delete().
 */
function sf_queue_salesforce_api_delete($sfid, $map, $oid) {
  // If queue is not in use, return;
  if (!variable_get('sf_queue_enabled', FALSE)) {
    return;
  }
  $settings = variable_get('sf_queue_settings', _sf_queue_default_settings());
  if (!in_array('delete', $settings['cron_operations'])) {
    return TRUE;
  }
  return sf_queue_enqueue('delete', (object) array('Id' => $sfid), $map, $oid);
}

/**
 * Helper function to add / update a queue item.
 */
function sf_queue_enqueue($op, $drupal_data, $map, $oid, $sfid) {
  $drupal_type = $map->drupal_entity . '_' . $map->drupal_bundle;
  $object = (object) array(
    'sf_op' => $op,
    'oid' => $oid,
    'attempts' => 0,
    'created' => REQUEST_TIME,
    'sfid' => $sfid,
    'drupal_type' => $map->drupal_entity,
    'drupal_bundle' => $map->drupal_bundle,
    'sf_type' => $map->salesforce,
    'name' => md5(microtime()),
    'fieldmap_name' => $map->name,
    'drupal_data' => $drupal_data,
  );
  $update = array();
  // If an existing operation is queued for this drupal object / fieldmap pair,
  // update the queue by merging the two records instead of appending to it.
  $existing = db_query(
    "SELECT oid
      FROM {salesforce_export_queue}
      WHERE fieldmap_name=:fieldmap_name AND oid=:oid
    ;", 
    array(':fieldmap_name' => $map->name, ':oid' => $oid)
  )->fetchAssoc();
  if ($existing) {
    $update = 'oid';
    $object->oid = $existing['oid'];
  }
  
  // If we successfully wrote to the queue, then we return FALSE to prevent an
  // immediate salesforce export. If we failed to write to the queue, log an
  // error but don't prevent the export.
  if (drupal_write_record('salesforce_export_queue', $object, $update)) {
    if (user_access('administer salesforce')) {
      drupal_set_message(t('Drupal !type queued for Salesforce export.', array('!type' => $drupal_type)));
    }
    return FALSE;
  }
  else {
    watchdog('sf_queue', 'Failed to queue Salesforce object. <pre>' . print_r($object, 1) . print_r($sf_object, 1) . '</pre>');
    return TRUE;
  }
}

/**
 * Implements hook_cron().
 */
function sf_queue_cron() {
  if (!variable_get('sf_queue_enabled', FALSE)) {
    return FALSE;
  }
  $settings = variable_get('sf_queue_settings', _sf_queue_default_settings());
  $state = variable_get('sf_queue_state', _sf_queue_default_state());
  if ((REQUEST_TIME - $settings['cron_frequency']) > $state['last_attempt']) {
    $state['last_attempt'] = REQUEST_TIME;
    variable_set('sf_queue_state', $state);
    sf_queue_process_queue($settings, $state);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function sf_queue_process_queue_force($redir = TRUE) {
  if (!variable_get('sf_queue_enabled', FALSE)) {
    return FALSE;
  }
  $settings = variable_get('sf_queue_settings', _sf_queue_default_settings());
  $state = variable_get('sf_queue_state', _sf_queue_default_state());
  $request_time = REQUEST_TIME;
  $state['last_attempt'] = $request_time;
  variable_set('sf_queue_state', $state);
  sf_queue_process_queue($settings, $state);
  if (user_access('administer salesforce')) {
    drupal_set_message(t('Salesforce export queue processed.'));
  }
  if ($redir == TRUE) {
    drupal_goto("admin/reports/sf_queue/");
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function sf_queue_process_queue($settings, $state) {
  $duration = $settings['cron_period'];
  if ($duration > .5) {
    $duration = .5;
  }
  $limit = ini_get('max_execution_time') * $duration;
  $start_time = REQUEST_TIME;

  // Clean up the queue before we do any processing.
  db_delete('salesforce_export_queue')
    ->where("sf_op IN ('delete', 'update') AND (sfid IS NULL OR sfid = NULL OR sfid = '')")
    ->execute()
  ;

  $settings = array_merge($settings, array('start_time' => $start_time, 'limit' => $limit));
  // Order of operations: delete, update, create
  if (in_array('delete', $settings['cron_operations'])) {
    sf_queue_handle_deletes($settings);
  }

  if (in_array('create', $settings['cron_operations'])
    || in_array('update', $settings['cron_operations'])) {
    sf_queue_handle_upserts($settings);
  }
}

/**
 * Helper function to process queue deletes. Since we can delete across object
 * types by SFID alone, plow through 200 deletes at a time, oldest first.
 */
function sf_queue_handle_deletes($settings) {
  $query = db_select('salesforce_export_queue', 'q')
    ->fields('q', array(
      'id', 'oid', 'fieldmap_name', 'drupal_type', 'sf_type', 'sfid'
    ))
    ->condition('sf_op', 'delete', '=')
  ;
  $args = array();
  if ($settings['retry_num_attempts'] >= 0) {
    $query->condition('attempts', $settings['retry_num_attempts'] + 1, '<');
  }
  $results = $query->orderBy('created')
    ->range(0, $settings['cron_num_objects'])
    ->execute()
  ;

  $done = FALSE;
  $sfids = $deletes = $real_deletes = $fails = array();

  while ($row = $results->fetchAssoc()) {
    $sfids[] = $row['sfid'];
    $deletes[] = $row;
  }
  if (count($deletes) == 0) {
    return;
  }
  if ($settings['cron_min_threshold']
      && count($deletes) < $settings['cron_min_threshold']) {
    return;
  }

  try {
    $sf = salesforce_api_connect();
    $responses = $sf->client->delete($sfids);
    sf_queue_handle_responses($responses, $deletes);
  }
  catch (Exception $e) {
    sf_queue_handle_exception($e, $deletes);
  }

  // Now we need to delete the entry from salesforce_object_map
}

/**
 * Helper function to process queue updates and inserts (creates). The logic
 * proceeds basically like this:
 * - Get a list of object types that we're going to upsert by eliminating those
 *   queue item groups that do not meet the criteria (too many fails, threshold
 *   not met, etc.)
 * - For each object type:
 *   - update up to 200 records at a time
 *   - then, create up to 200 records at a time
 * - On each iteration of each major loop, break if we have exceeded our
 *   allotted processing time limit.
 */
function sf_queue_handle_upserts($settings) {
  // Prepare a query of the queue item totals for each fieldmap with insert/create actions pending.
  $counts = db_select('salesforce_export_queue', 'q');
  $counts->addField('q', 'fieldmap_name');
  $counts->addExpression('COUNT(q.fieldmap_name)', 'total');
  $counts->condition('sf_op', array('upsert', 'insert', 'create'));
  $counts->groupBy('fieldmap_name');
  $counts->orderBy('total', 'DESC');
  
  // Prepare a query for each fieldmap's queue items.
  $enqueued = db_select('salesforce_export_queue', 'q')
    ->fields('q', array(
      'id', 'oid', 'fieldmap_name', 'sfid', 'drupal_data'
    ))
  ;
  $enqueued->condition('sf_op', array('upsert', 'insert', 'create'));
  $enqueued->orderBy('created');
  $enqueued->range(0, $settings['cron_num_objects']);
  
  // Limit both queries to the configured maximum number of retry attempts.
  if ($settings['retry_num_attempts'] >= 0) {
    $counts->condition('attempts', $settings['retry_num_attempts'] + 1, '<');
    $enqueued->condition('attempts', $settings['retry_num_attempts'] + 1, '<');
  }
  
  // Limit the counts query to the configured minimum number of queue items.
  if ($settings['cron_min_threshold']) {
    $counts->havingCondition('total', $settings['cron_min_threshold'], '>=');
  }
  
  // Iterate over all fieldmaps with insert/create actions pending, until we run out of time.
  $counts_results = $counts->execute();
  $timeout_time = $settings['start_time'] + $settings['limit'];
  while ($timeout_time > time()  &&  $count = $counts_results->fetchObject()) {
    // Make sure we have a Salesforce connection.
    if (!isset($sf)) {
      $sf = salesforce_api_connect();
    }
    
    // Load the fieldmap.
    $fieldmap = salesforce_api_salesforce_fieldmap_load($count->fieldmap_name);
    $export_objects = array();
//    $dedupe_drupal_field = $fieldmap->fields[$fieldmap->dedupe_key];
    $dedupe_field_enquote = TRUE; //@todo: un-hardwire this

    // Query all update/insert queue items for this fieldmap.
    $enqueued_per_fieldmap = clone $enqueued;
    $enqueued_per_fieldmap->condition('fieldmap_name', $fieldmap->name, '=');
    $queue_items = $enqueued_per_fieldmap->execute();
    
    // Iterate over queue items, preparing for dedupe query.
    $existing_sf_objects = array();
    $known_sfids = array();
    $dedupe_keys = array();
    foreach ($queue_items as $queue_item) {
      if (!empty($queue_item->sfid)) {
        $known_sfids[] = $queue_item->sfid;
      } else {
        $dedupe_value = _sf_queue_get_dedupe_value($fieldmap, $queue_item);
        if (!empty($dedupe_value)) {
          $dedupe_keys[$dedupe_value] = FALSE;
        }
      }
    }
    
    // Prepare to query Salesforce for existing records.
    $sf_fields = array_keys($fieldmap->fields);
    if (!in_array('Id', $sf_fields)) {
      $sf_fields[] = 'Id';
    }
    $query_stub = 'SELECT ' . implode(',', $sf_fields) . ' FROM ' . $fieldmap->salesforce . ' WHERE ';
    $query_stub_length = strlen($sf_select) + strlen("Id IN () OR $fieldmap->dedupe_key IN ()");
    $dedupe_values = array_keys($dedupe_keys);
    $sfids = $known_sfids;
    
    // Submit queries of up to SALESFORCE_API_QUERY_CHAR_MAX characters until we've looked up everything.
    while (!empty($sfids) || !empty($dedupe_values)) {
      // Build query.
      $query_sfids = ',';
      $query_dedupe_values = ',';
      while (SALESFORCE_API_QUERY_CHAR_MAX > (
        $query_stub_length + strlen($query_condition_sfids) + strlen($query_condition_dedupe)
      )) {
        if (!empty($sfids)) {
          $query_sfids = '"' . array_pop($sfids) . '",' . $query_sfids;
        } else if (!empty($dedupe_values)) {
          $query_dedupe_values = 
            ($dedupe_field_enquote ? '"' : '')
            . array_pop($dedupe_values)
            . ($dedupe_field_enquote ? '",' : ',')
            . $query_dedupe_values
          ;
        } else {
          break;
        }
      }
      $query_sfids = substr($query_sfids, 0, -1);
      $query_dedupe_values = substr($query_dedupe_values, 0, -1);
      $query = $query_stub;
      if (strlen($query_sfids) > 1) {
        $query .= "Id IN ($query_sfids)";
        if (strlen($query_dedupe_values) > 1) {
          $query .= ' OR ';
        }
      }
      if (strlen($query_dedupe_values) > 1) {
        $query .= "$fieldmap->dedupe_key IN ($query_dedupe_values)"; 
      }
      
      // Submit query and process results.
      try {
        $result = $sf->client->query($query);
      }
      catch (Exception $e) {
        salesforce_api_log(
          SALESFORCE_LOG_SOME, 
          'Exception in sf_queue_handle_upserts: ' . $e->getMessage(), 
          array(), 
          WATCHDOG_ALERT
        );
        // This sinks us, so abort.
        return;
      }
      if ($result->size > 0) {
        foreach ($result->records as $existing_object) {
          $existing_sf_objects[$existing_object->Id] = $existing_object;
          if (isset($dedupe_keys[ $existing_object->{$fieldmap->dedupe_key} ])) {
            $dedupe_keys[ $existing_object->{$fieldmap->dedupe_key} ] = $existing_object->Id;
          }
        }
      }
    }
    
    // Iterate over queue items again, this time building and submitting an upsert request.
    $done_trying = FALSE;  //@todo: is this $done_trying logic really what we want? won't it just hammer the API with the same upsert until the cron time limit is reached?
    while ($timeout_time > time()  &&  !$done_trying) {
      $items = $ids = $objects = array();
      foreach ($queue_items as $queue_item) {
        $ids[] = $queue_item->id;
        $items[] = $queue_item;
        $drupal_data = (object) unserialize($queue_item->drupal_data);
                
        // Do we have an existing Salesforce object?
        $existing_sf_object = NULL;
        if (!empty($queue_item->sfid)) {
          $existing_sf_object = $existing_sf_objects[$queue_item->sfid];
        } else {
          $dedupe_value = _sf_queue_get_dedupe_value($fieldmap, $queue_item);
          if (!empty($dedupe_value) && $dedupe_keys[$dedupe_value] !== FALSE) {
            $existing_sf_object = $existing_sf_objects[$dedupe_keys[$dedupe_value]];
          }
        }
        
        // Generate Salesforce object for export.
        $objects[] = salesforce_api_fieldmap_export_create($fieldmap->name, $drupal_data, $existing_sf_object);
        
        if ($sf_op == 'create') {
          unset($object->Id);
        }
        $objects[] = $object;
      }
      if (count($ids) > 0) {
        try {
          $responses = $sf->client->upsert($objects, $fieldmap->salesforce);
          error_log(print_r($responses, 1));  //@todo: remove after testing
          list($wins, $fails) = sf_queue_handle_responses($responses, $items);
        }
        catch (Exception $e) {
          sf_queue_handle_exception($e, $responses);
          continue;
        }
        error_log(print_r($wins, 1));  //@todo: remove after testing
        error_log(print_r($fails, 1));  //@todo: remove after testing
        if (count($fails) > 0) {
          watchdog('sf_queue', "Failed objects [<pre>" . print_r($objects, TRUE) . "</pre>]");
        }
        if (count($wins) == 0) {
          break;
        }
        // Instead of using salesforce_api_id_save to generate 2 SQL queries per
        // record, we collect them all to do 2 massive queries for all the
        // records at once.
        db_delete('salesforce_object_map')
          ->condition('oid', array_values($wins), 'IN')
          ->execute()
        ;
        $insert = db_insert('salesforce_object_map')
          ->fields(array(
            'drupal_entity', 'drupal_bundle', 'oid', 'sfid', 'name', 'created', 'last_export'
          ))
        ;
        $offset = 0;
        foreach ($wins as $sfid => $oid) {
          $insert->values(array(
            'drupal_entity' => $fieldmap->drupal_entity,
            'drupal_bundle' => $fieldmap->drupal_bundle,
            'oid' => $oid,
            'sfid' => $sfid,
            'name' => $items[$offset]->fieldmap_name,
            'created' => time(),
            'last_export' => time(),
          ));
          $offset++;
        }
        $insert->execute();
      }
      else {
        $done_trying = TRUE;
        break;
      }
    } // while time limit for each operation
  } // while sf_type loop
}

function _sf_queue_get_dedupe_value($fieldmap, $queue_item) {
  //@todo: Replace this with a less kludgy approach that maps just the field and not the whole object?
  //@todo: Does the dedupe key actually have to be mapped by the fieldmap? If not, then this has to be replaced.
  $drupal_data = (object) unserialize($queue_item->drupal_data);
  $sf_object = salesforce_api_fieldmap_export_create($fieldmap->name, $drupal_data);
  $dedupe_value = $sf_object->{$fieldmap->dedupe_key};
  return $dedupe_value;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function sf_queue_handle_responses($responses, $dataset) {
  $wins = $fails = array();
  if (!is_array($responses)) {
    $responses = array($responses);
  }
  foreach ($responses as $key => $response) {
    $item = $dataset[$key];
    if (!empty($response->success)) {
      $wins[$response->id] = $item['oid'];
    }
    else {
      if (isset($response->errors) && is_array($response->errors) && is_object($response->errors[0])) {
        $fields = isset($response->errors[0]->fields) ? $response->errors[0]->fields : '';
        $error_str = t(
          "Error from Salesforce:<br>Message - !message<br>Fields - !fields<br>Status code - !code", 
          array(
            '!message' => $response->errors[0]->message, 
            '!fields' => $fields, 
            '!code' => $response->errors[0]->statusCode
          )
        );
        watchdog('sf_queue', $error_str);
      }
      $fails[] = $item['oid'];
    }
  }
  if (count($wins) > 0) {
    db_delete('salesforce_export_queue')
      ->condition('oid', array_values($wins), 'IN')
    ;
  }
  if (count($fails) > 0) {
    db_query(
      "UPDATE {salesforce_export_queue} SET attempts = attempts + 1 WHERE oid IN (:oids);",
      array(':oids' => $fails)
    );
  }
  return array($wins, $fails);
}

/**
 * Set global state if API limit is exceeded, password is expired, creds are
 * wrong, or if there are any other "blocker" exceptions. Otherwise, log the
 * exception and update the queue records with failure attempts.
 */
function sf_queue_handle_exception($e, $dataset) {
  // TODO: Parse the exception and take action on it
  $oids = array();
  if (is_array($dataset)) {
    foreach ($dataset as $data) {
      $oids[] = $data['oid'];
    }
  }
  else {
    $oids[] = $dataset['oid'];
  }
  if (is_int($oid[0])) {
    db_query(
      "UPDATE {salesforce_export_queue} SET attempts = attempts + 1 WHERE oid IN (:oids);",
      array(':oids' => $oids)
    );
  }
}

/**
 * Implements hook_form_salesforce_api_settings_form_alter().
 * @see salesforce_api/salesforce_api.admin.inc::salesforce_api_settings_form
 */
function sf_queue_form_salesforce_api_settings_form_alter(&$form, &$form_state) {
  $enabled = variable_get('sf_queue_enabled', FALSE);
  $form['sf_queue'] = array(
    '#type' => 'fieldset',
    '#title' => t('Queue Settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => -1,
  );
  if ($enabled) {
    $description = l('View the export queue', 'admin/reports/sf_queue');
  }
  else {
    $description = t('Salesforce Export Queue will attempt to optimize your Salesforce API usage by scheduling transactions for delayed processing, combining multiple object insert/updates, and backlogging failed transactions for re-processing. Enable the Export Queue to configure settings for these features.');
  }
  $form['sf_queue']['sf_queue_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable Salesforce Export Queue'),
    '#description' => $description,
    '#default_value' => $enabled,
  );
  if (!$enabled) {
    return;
  }

  $sf_queue_settings = variable_get('sf_queue_settings', _sf_queue_default_settings());
  $frequency = drupal_map_assoc(array(0, 60, 180, 300, 600, 900, 1800, 2700, 3600, 10800, 21600, 32400, 43200, 86400), 'format_interval');
  $frequency[0] = t('Every cron run');

  $fieldmaps = salesforce_api_salesforce_fieldmap_load_all();
  $objects = array();
  foreach ($fieldmaps as $map) {
    $objects[$map->salesforce] = $map->salesforce;
  }
  $num_objects = drupal_map_assoc(array(5, 10, 15, 30, 50, 75, 100, 125, 150, 175, 200));

  $threshold = drupal_map_assoc(array(0, 5, 10, 15, 30, 50, 75, 100, 125, 150, 175, 200));
  $threshold[0] = t('No minimum');

  $attempts = drupal_map_assoc(array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1));
  $attempts[-1] = t('No limit');

  $period = array(
    '.05' => t('5% of cron run'),
    '.1' => t('10% of cron run'),
    '.15' => t('15% of cron run'),
    '.2' => t('20% of cron run'),
    '.25' => t('25% of cron run'),
    '.3' => t('30% of cron run'),
    '.35' => t('35% of cron run'),
    '.4' => t('40% of cron run'),
    '.45' => t('45% of cron run'),
    '.5' => t('50% of cron run'),
  );

  $settings = array(
    '#tree' => TRUE,
    'cron_operations' => array(
      '#title' => 'Queued Operations',
      '#type' => 'checkboxes',
      '#options' => array(
        'create' => t('Create'),
        'update' => t('Update'),
        'delete' => t('Delete'),
      ),
      '#default_value' => $sf_queue_settings['cron_operations'],
      '#description' => t('Which operations should be queued? Check each operation that should cause an API transaction to be queued. Unchecked operations will trigger an API transaction immediately. <strong>Check more of these options if you are running out of API calls.</strong>'),
    ),
    'cron_frequency' => array(
      '#title' => 'Frequency',
      '#type' => 'select',
      '#options' => $frequency,
      '#default_value' => $sf_queue_settings['cron_frequency'],
      '#description' => t('How often should exports be attempted? Note: exports will only be attempted when cron is run. If your site-wide cron runs less frequently than this setting, the exports will be attempted on every cron run. <strong>If cron is timing out, you should lower this setting so that the queue is processed more frequently.</strong>'),
    ),
    'cron_period' => array(
      '#title' => 'Time',
      '#type' => 'select',
      '#options' => $period,
      '#default_value' => $sf_queue_settings['cron_period'],
      '#description' => t('Amount of time as a percentage of allotted cron run time that should be devoted to the export queue.'),
    ),
    'cron_num_objects' => array(
      '#title' => 'Number of Object Types',
      '#type' => 'select',
      '#options' => $num_objects,
      '#default_value' => $sf_queue_settings['cron_num_objects'],
      '#description' => t('How many object types should be processed per cron run? Salesforce allows up to 200 objects of the same type to be created, updated, or deleted in a single API transaction. The export queue will group objects of the same type to maximize efficient use of API transactions. This setting determines how many such object groups should be processed per cron run. <strong>If cron is timing out, you should lower this setting so that fewer API transactions are attempted per cron run.</strong>'),
    ),
    'cron_min_threshold' => array(
      '#title' => 'Minimum Number of Objects to Trigger Export',
      '#type' => 'select',
      '#options' => $threshold,
      '#default_value' => $sf_queue_settings['cron_min_threshold'],
      '#description' => t('How many objects of should be required to trigger an export? The settings "No minimum" means that the export queue will be processed as fully as possible on each cron run, even if only one object is to be created, updated, or deleted. Setting this value too high may delay processing of queued data. <strong>If you are running out of API calls, try raising this setting so that more objects are queued before an API call is made. If your cron runs are timing out, try lowering this setting so that the queue load is smaller on each cron run.</strong>'),
    ),
    'retry_num_attempts' => array(
      '#title' => 'Number of Retry Attempts',
      '#type' => 'select',
      '#options' => $attempts,
      '#default_value' => $sf_queue_settings['retry_num_attempts'],
      '#description' => t('How many times should an API transacrion be retried after a failed attempt? "No limit" means that failed attempts will be retried either until they succeed or are manually removed from the queue. <strong>If you are running out of API calls, try lowering this setting. If your cron runs are timing out, try lowering this setting.</strong>'),
    ),
  );
  $form['sf_queue']['sf_queue_settings'] = $settings;
}

/**
 * Helper function for sf_queue_settings variable. Should be used for default
 * sf_queue_settings if it is empty, e.g.
 * variable_get('sf_queue_settings', _sf_queue_default_settings())
 */
function _sf_queue_default_settings() {
  return array(
    'cron_operations' => array('create', 'update', 'delete'),
    'cron_min_threshold' => array(0),
    'cron_num_objects' => 200,
    'cron_frequency' => 0,
    'cron_period' => '.25',
    'retry_num_attempts' => 1,
  );
}

/**
 * Helper function for sf_queue_state, which keeps track of which objects
 * have been processed, when they were last processed, etc.
 */
function _sf_queue_default_state() {
  return array(
    'last_attempt' => NULL,
  );
}
