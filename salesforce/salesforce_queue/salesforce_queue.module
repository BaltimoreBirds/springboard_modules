<?php

/**
 * @file
 * Provides batch processing functionality for Salesforce integration.
 */

/**
 * Implements hook_form_FORM_ID_alter().
 */
function salesforce_queue_form_salesforce_mapping_form_alter(&$form, &$form_state) {
  // Remove overly restrictive validation routine. Ideally the current monolithic
  // validation handler be broken down into 3 separate validation routines:
  // - Check for existence of duplicate map
  // - Field type validation (this is still too strict IMHO)
  // - Dedupe field (SOAP API has different limitations)
  // Then we'd only need to alter the dedupe field validation.
  unset($form['#validate']);
}

/**
 * Implements hook_menu().
 */
function salesforce_queue_menu() {
  $items['admin/structure/salesforce/queue'] = array(
    'title' => 'Salesforce Queue Settings',
    'description' => 'Configuration settings for the Salesforce queue.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_queue_admin_settings'),
    'access arguments' => array('configure salesforce queue'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'salesforce_queue.admin.inc',
  );

  $items['admin/structure/salesforce/object-verify'] = array(
    'title' => 'Salesforce Queue Object Verify',
    'description' => 'Utility for verifying the format of Salesforce objects.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_queue_object_verification_form'),
    'access arguments' => array('configure salesforce queue'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'salesforce_queue.utility.inc',
    'weight' => 10,
  );

  $items['salesforce-queue-sandbox'] = array(
    'title' => 'Salesforce queue sandbox',
    'page callback' => 'salesforce_queue_sandbox',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function salesforce_queue_permission() {
  return array(
    'configure salesforce queue' => array(
      'description' => t('Configure settings for the Salesforce queue.'),
      'title' => t('Configure Salesforce queue'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_cron().
 */
function salesforce_queue_cron() {
  //salesforce_queue_prune_logs();
  // Bail on normal cron run if standalone cron is enabled.
  if (_salesforce_queue_standalone_cron_enabled()) {
    // If standalone cron is enabled, do nothing.
    return 0;
  }
  else {
    // Process the queue normally.
    watchdog('salesforce_queue', t('Standard cron run.'));
    if (lock_acquire('salesforce_queue_standalone_cron')) {
      salesforce_queue_process();
      lock_release('salesforce_queue_standalone_cron');
    }
    else {
      watchdog('salesforce_queue', 'Attempting to process salesforce queue while it is already running.', array(), WATCHDOG_WARNING);
    }
  }
}

/**
 * Menu callback for the standalone cron.
 */
function salesforce_queue_standalone_cron() {
  if (_salesforce_queue_standalone_cron_enabled()) {
    // Process the queue.
    watchdog('salesforce_queue_cron', t('Standalone cron run.'));

    // Acquire an excluse lock on the process.
    if (lock_acquire('salesforce_queue_standalone_cron')) {
      salesforce_queue_process();
      watchdog('salesforce_queue', 'Salesforce queue cron run completed.', array(), WATCHDOG_NOTICE);
      lock_release('salesforce_queue_standalone_cron');
    }
    else {
      watchdog('salesforce_queue', 'Attempting to process salesforce queue while it is already running.', array(), WATCHDOG_WARNING);
    }
  }
}

/**
 * Processes the data in the Salesforce queue.
 */
function salesforce_queue_process() {
  watchdog('salesforce_queue', 'The queue is being processed.');
}

/**
 * Implements hook_salesforce_async_queue_name().
 */
function salesforce_queue_salesforce_async_queue_name_alter(&$queue_name) {
  // Change the queue_name so we can implement SalesforceQueue.
  $queue_name = 'salesforce';
}

/**
 * Implements hook_salesforce_push_queue_item_alter().
 */
function salesforce_queue_salesforce_push_queue_item_alter(&$item, $mapping) {
  // Go ahead and convert the entity into it's Salesforce representation before
  // stashing it into the queue.
  print '<pre>';
  print_r($mapping);
  print '</pre>';
  //die();

}


function salesforce_queue_sandbox() {
  $page = array(
    'FirstName' => 'Phillip',
    'LastName' => 'Cave',
    'Account' => 'User::User::2',
  );
  $qid = salesforce_queue_insert('1', 'entity', 'page', 'Page', 'upsert', $page, 'Email');
}

/**
 * Inserts an item into the Salesforce queue.
 *
 * @param $drupal_id
 *   The id of the Drupal object. This could be a nid, uid, sid, etc.
 * @param $module
 *   The module name that implements the delta. For node types this would be entity.
 * @param $delta
 *   The module sub-type. For node types this would be node type name, article for instance.
 * @param $salesforce_type
 *   The name of the Salesforce type that is being exported.
 * @param $operation
 *   The CRUD operation being run in Salesforce (upsert, create, update, delete).
 * @param $sobject
 *   The Salesforce object that is being queued.
 * @param $dedupe_field
 *   The Salesforce field to dedupe on during UPSERT operations.
 *
 * @return
 *   The id of the queue entry or false if insertion fails or a duplicate is already
 *   in the queue.
 */
function salesforce_queue_insert($drupal_id, $module, $delta, $salesforce_type, $operation, &$sobject, $dedupe_field = NULL) {

  // allow other modules to alter the object before it is queued
  drupal_alter('salesforce_queue_prequeue', $sobject, $drupal_id, $module, $delta);

  if (!salesforce_queue_enqueue($drupal_id, $module, $delta, $salesforce_type)) {

    $qid = db_insert('salesforce_queue')
      ->fields(array(
        'drupal_id' => $drupal_id,
        'module' => $module,
        'delta' => $delta,
        'salesforce_type' => $salesforce_type,
        'operation' => $operation,
        'dedupe_field' => $dedupe_field,
        'sobject' => json_encode($sobject),
        'created' => REQUEST_TIME,
        ))
      ->execute();

    return $qid;
  }
  else {
    // TODO: log or throw exception?
    return FALSE;
  }
}

/**
 * Determines if an item is already in the queue.
 *
 * @param $drupal_id
 *   The id of the Drupal object. This could be a nid, uid, sid, etc.
 * @param $module
 *   The module name that implements the delta. For node types this would be entity.
 * @param $delta
 *   The module sub-type. For node types this would be node type name, article for instance.
 * @param $salesforce_type
 *   The name of the Salesforce object type.
 */
function salesforce_queue_enqueue($drupal_id, $module, $delta, $salesforce_type) {
  $query = db_select('salesforce_queue', 's')
    ->fields('s', array('id'))
    ->condition('s.drupal_id', $drupal_id)
    ->condition('s.module', $module)
    ->condition('s.delta', $delta)
    ->condition('s.salesforce_type', $salesforce_type);

  $count = $query->countQuery()->execute()->fetchField();

  // Return TRUE if this item is already in the queue.
  return $count > 0;
}

/**
 * Removes an item from the queue.
 *
 * @param $drupal_id
 *   The id of the Drupal object. This could be a nid, uid, sid, etc.
 * @param $module
 *   The module name that implements the delta. For node types this would be entity.
 * @param $delta
 *   The module sub-type. For node types this would be node type name, article for instance.
 * @param $salesforce_type
 *   The name of the Salesforce object type.
 */
function salesforce_queue_dequeue($drupal_id, $module, $delta, $salesforce_type) {
  // TODO: pre-delete hook
  $count = db_delete('salesforce_queue')
    ->condition('drupal_id', $drupal_id)
    ->condition('module', $module)
    ->condition('delta', $delta)
    ->condition('salesforce_type', $salesforce_type)
    ->execute();

  // TODO: log removal
  return $count;
}

/**
 * Invokes hook_salesforce_queue_info().
 *
 * This hook allows other modules to inform the queue system about
 * the data they need to integrate. For now the sole purpose of this
 * hook is to allow other modules to tell the proessor about the item
 * types they are integrating. The entity integration would return an
 * array of all types that have been mapped.
 *
 */
function salesforce_queue_info() {
  // Get information from other modules.
  return module_invoke_all('salesforce_queue_info');
}

/**
 * Indicates whether or not queue standalone cron is enabled.
 */
function _salesforce_queue_standalone_cron_enabled() {
  return variable_get('salesforce_queue_standalone_cron_enabled', FALSE);
}
