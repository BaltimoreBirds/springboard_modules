<?php

/**
 * @file
 * Simpletests for salesforce_queue
 */

/**
 * Tests basic set up for queueing data for Salesforce and sending it
 */
class SalesforceQueueTestCase extends DrupalWebTestCase {

  /**
   * Implementation of getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => 'General API for Salesforce Queue Tests',
      'description' => 'Ensure that the salesforce_queue module functions properly.',
      'group' => 'Salesforce Queue',
    );
  }

  /**
   * Implementation of setUp().
   */
  public function setUp($modules = array()) {
    $modules = $modules + array(
      'libraries',
      'salesforce',
      'salesforce_soap',
      'salesforce_queue',
    );
    parent::setUp($modules);

    // Create an admin user
    $permissions = array(
      'access content',
      'administer site configuration',
      'administer content types',
      'administer nodes',
      'administer users',
      'administer salesforce',
      'configure salesforce queue',
    );
    $this->admin_user = $this->drupalCreateUser($permissions);
    // Don't forget, need to pass --uri in drush command in order for logging
    // in to work
    $this->drupalLogin($this->admin_user);
  }

  /**
   * Implementation of tearDown().
   */
  public function tearDown() {
    user_cancel(array(), $this->admin_user->uid, 'user_cancel_delete');
    parent::tearDown();
  }

  /**
   * Test for hook_salesforce_queue_process_fail_item()
   */
  public function testProcessFailItem() {
    $this->salesforceConnect();

    // Queue up an Opportunity which will automatically fail
    $queue = SalesforceQueue::get();
    $this->createQueueItems($queue, 1, array('CREATE'), array('Account', 'Contact'));
    $item = $queue->claimItem();
    $queue->releaseItem($item);
    salesforce_queue_process_queue();

    // Verify the item has been marked to retry
    $record = $queue->getItem($item->drupal_id, $item->module, $item->delta, $item->salesforce_type);
    $this->assertEqual('retry', $record->queue, 'Failed item placed into the retry queue.');
    $this->assertEqual(1, $record->retries, 'Failed item marked as having one retry.');

    // Do this until we hit maximum retries and make sure it is placed in the
    // fail queue
    $max_retries = variable_get('salesforce_queue_max_retries', 5);
    while ($max_retries > $record->retries) {
      salesforce_queue_process_queue();
      $record = $queue->getItem($item->drupal_id, $item->module, $item->delta, $item->salesforce_type);
    }
    salesforce_queue_process_queue();
    $record = $queue->getItem($item->drupal_id, $item->module, $item->delta, $item->salesforce_type);
    $this->assertEqual('fail', $record->queue, 'After maximum retries, item placed into fail queue');
  }

  /**
   * Test for salesforce_queue_cron()
   */
  public function testCron() {
    $this->salesforceConnect();

    // Set cron frequency to 0 so it doesn't get in our way
    variable_set('salesforce_queue_cron_frequency', 0);

    // Add item to queue and ensure it is there
    $queue = SalesforceQueue::get();
    $this->createQueueItems($queue, 1, array('CREATE'), array('Opportunity'));
    $items = $queue->claimBatch();
    $queue->releaseBatch($items[0]->lease_key);
    $this->assertFalse(empty($items), 'Queued up an item to test with.');

    // Kick off cron, then verify the item is not there
    $this->cronRun();
    $items = $queue->claimBatch();
    $this->assertTrue(empty($items), 'Cron processed queued item.');

    // Delete the variable to put us back to normal
    variable_del('salesforce_queue_cron_frequency');
  }

  /**
   * Grabs the Salesforce connection information from the live db and authenticates
   *
   * @return Object
   *   Salesforce Object
   */
  public function salesforceConnect() {
    // Steal the Salesforce configuration from the live database
    global $db_prefix;
    $table = empty($db_prefix) ? 'variable' : $db_prefix .'_variable';
    $sql = "SELECT * FROM $table v WHERE v.name LIKE 'salesforce_%'";
    $result = db_query($sql);
    foreach ($result as $record) {
      if (!strstr($record->name, 'salesforce_queue')) {
        variable_set($record->name, unserialize($record->value));
      }
    }

    // Test the connection
    $salesforce = salesforce_get_api();
    $this->assertTrue($salesforce->isAuthorized(), 'Connected to Salesforce');

    // Make a call to Salesforce that will do nothing just so we can get an
    // access token into our session.  This is dumb, but I can't think of any
    // other way to get an access token.
    $salesforce->apiCall('');

    return $salesforce;
  }

  /**
   * Creates a random bunch of items to send to the given queue
   *
   * @param SalesforceQueue $queue
   *   Queue to send items to
   * @param int $num
   *   Number of items to create
   */
  public function createQueueItems(SalesforceQueue $queue, $num = 5, $ops = array(), $exempt_objects = array()) {
    // Define objects
    $objects = array(
      'Account' => array(
        'type' => 'Account',
        'records' => array(),
        'fields' => array(
          'Name' => FALSE,
          'Type' => FALSE,
          'AccountNumber' => FALSE,
        ),
      ),
      'Contact' => array(
        'type' => 'Contact',
        'records' => array(),
        'fields' => array(
          'FirstName' => FALSE,
          'LastName' => FALSE,
          'Email' => TRUE,
        ),
      ),
      'Opportunity' => array(
        'type' => 'Opportunity',
        'records' => array(
          'Donation',
          'Grant',
          'Membership',
        ),
        'fields' => array(
          'Name' => TRUE,
          'Amount' => FALSE,
          'AccountId' => FALSE,
          'StageName' => FALSE,
          'CloseDate' => FALSE,
        ),
      ),
    );
    foreach ($exempt_objects as $exempt_object) {
      unset($objects[$exempt_object]);
    }

    // Define types of operations
    if (empty($ops)) {
      $ops = array(
        'UPSERT',
        'CREATE',
        'UPDATE',
        'DELETE'
      );
    }

    $i = 0;
    while ($i < $num) {
      $i++;

      // Set up the data array
      $ops_rand = array_rand($ops);
      $data = array(
        'drupal_id' => rand(1, $num*100),
        'module' => $this->randomName(),
        'delta' => $this->randomName() .':'. rand(1, $num*100),
        'operation' => $ops[$ops_rand],
        'dedupe_field' => NULL,
      );

      // Create the Salesforce object
      $object_rand = array_rand($objects);
      $record_rand = empty($objects[$object_rand]['records']) ? NULL : array_rand($objects[$object_rand]['records']);
      $sObject = new stdClass;
      $sObject->type = $objects[$object_rand]['type'];
      $sObject->record = is_null($record_rand) ? NULL : $objects[$object_rand]['records'][$record_rand];
      $sObject->fields = array();
      foreach ($objects[$object_rand]['fields'] as $field => $dedupe) {
        if ($field == 'Email') {
          $sObject->fields[$field] = $this->randomName() . '@' . $this->randomName() . '.com';
        }
        else if ($field == 'Amount') {
          $sObject->fields[$field] = rand(1, 10000);
        }
        else if ($field == 'CloseDate') {
          $sObject->fields[$field] = date('c', REQUEST_TIME);
        }
        else {
          $sObject->fields[$field] = $this->randomName();
        }

        // If this field can be used for dedupe, give it a 50% chance of it
        // being set.  Unless, of course, the operation is UPSERT, then it needs
        // to be set.
        if ($dedupe && (rand(0, 1) || $data['operation'] == 'UPSERT')) {
          $data['dedupe_field'] = $field;
        }
      }

      // If the operation is UPSERT, and there is no dedupe field, change the
      // operation to CREATE
      if ($data['operation'] == 'UPSERT' && empty($data['dedupe_field'])) {
        $data['operation'] = 'CREATE';
      }

      // If the operation is UPDATE or DELETE add in a fake Id field
      if ($data['operation'] == 'UPDATE' || $data['operation'] == 'DELETE') {
        $sObject->Id = $this->randomName();
      }

      $data['salesforce_type'] = $sObject->type;
      $data['sobject'] = $sObject;

      // Create the queue item
      $result = $queue->createItem($data);
      $this->assertTrue($result, 'Created a queue item.');
    }
  }
}
