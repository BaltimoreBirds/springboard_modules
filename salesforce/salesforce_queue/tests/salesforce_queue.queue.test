<?php
include_once(dirname(__FILE__) . '/salesforce_queue.test');

/**
 * @file
 * Simple tests for includes/salesforce_queue.queue.inc
 */

/**
 * Tests basic set up for queueing data for Salesforce and sending it
 */
class SalesforceQueueQueueTestCase extends SalesforceQueueTestCase {

  /**
   * Implementation of getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => 'SalesforceQueue',
      'description' => 'Ensure that the SalesforceQueue class functions properly.',
      'group' => 'Salesforce Queue',
    );
  }

  /**
   * Implementation of setUp().
   */
  public function setUp() {
    parent::setUp();
  }

  /**
   * Implementation of tearDown().
   */
  public function tearDown() {
    parent::tearDown();
  }

  /**
   * Test the SalesforceQueue class
   */
  public function testSalesforceQueue() {
    module_load_include('inc', 'system', 'system.queue');

    // get() && __construct() && createQueue()
    // You can work against the entire queue at once ignoring if items are
    // slated for a certain task or not, or you can grab items specified for
    // something specific, like retries, permenant failures, etc.  It is
    // completely arbitrary, so for the case of testing I'm using "foo"
    $whole_queue = SalesforceQueue::Get();
    $foo_queue = SalesforceQueue::Get('foo');

    // createItem()
    // The "whole" queue does not have a subset defined, so it will actually put
    // all of the new items in a "new" queue by default.  All of the items in
    // the "foo" queue will get placed in the "foo" queue by default.
    $this->createQueueItems($whole_queue);
    $this->createQueueItems($foo_queue);

    // Lets grab the "new" queue so we can test against it, too
    $new_queue = SalesforceQueue::Get('new');

    // numberOfItems()
    // Note that the "whole" queue is going to count both the items that it
    // added as well as the items that the "foo" queue added
    $this->assertEqual(10, $whole_queue->numberOfItems(), 'Counted 10 records for the entire queue.');
    $this->assertEqual(5, $new_queue->numberOfItems(), 'Counted 5 records for the "new" queue.');
    $this->assertEqual(5, $foo_queue->numberOfItems(), 'Counted 5 records for the "foo" queue.');

    // claimItem()
    // Each will claim an item from its own queue
    $new_queue_item = $new_queue->claimItem();
    $this->assertTrue(is_object($new_queue_item), 'Retreived an item from the new queue');
    $this->assertEqual('new', $new_queue_item->queue, 'New queue retreived an item from the new queue.');
    $this->assertTrue(isset($new_queue_item->sobject->type), 'The sObject has been defined in the new queue item.');
    $foo_queue_item = $foo_queue->claimItem();
    $this->assertTrue(is_object($foo_queue_item), 'Retreived an item from the foo queue');
    $this->assertEqual('foo', $foo_queue_item->queue, 'Foo queue retreived an item from the foo queue.');
    $this->assertTrue(isset($foo_queue_item->sobject->type), 'The sObject has been defined in the foo queue item.');

    // The whole queue will select the oldest queue item, regardless of which
    // queue it came from.  Currently, the oldest is from the new queue
    $whole_queue_item = $whole_queue->claimItem();
    $this->assertTrue(is_object($whole_queue_item), 'Retreived an item from the queue');
    $this->assertEqual('new', $whole_queue_item->queue, 'Whole queue retreived an item from the new queue as expected.');
    $this->assertTrue(isset($whole_queue_item->sobject->type), 'The sObject has been defined in the whole queue item.');

    // The new_queue and whole_queue should not have picked up the same item
    $this->assertNotEqual($whole_queue_item->item_id, $new_queue_item->item_id, 'New queue and whole queue processes did not lease the same item.');

    // If you create an item with the same primary keys [drupal_id, module,
    // delta, salesforce_type] as another item already in the queue, then that
    // item will be replaced with the new data instead of a new queue item being
    // created. Lets re-create an item we just fetched and see it merge.
    $data = (array)$whole_queue_item;
    // Unset everything we don't use when creating a new item
    $keys = array('drupal_id', 'module', 'delta', 'salesforce_type', 'operation', 'dedupe_field', 'sobject');
    foreach ($data as $key => $value) { if (!in_array($key, $keys)) unset($data[$key]); }

    // Change one value that is not a primary key, create a queue item and
    // ensure that it was merged with the original
    $data['dedupe_field'] = 'foobar';
    $whole_queue->createItem($data);
    $dedupe_value = db_select('salesforce_queue', 'q')
      ->fields('q', array('dedupe_field'))
      ->condition('item_id', $whole_queue_item->item_id)
      ->execute()
      ->fetchField();
    $this->assertEqual('foobar', $dedupe_value, 'Requeing item updated old queue item.');

    // releaseItem() && deleteItem()
    $items = array(
      array($whole_queue, $whole_queue_item),
      array($new_queue, $new_queue_item),
      array($foo_queue, $foo_queue_item),
    );
    foreach ($items as $item) {
      // Release
      $this->assertTrue($item[0]->releaseItem($item[1]), 'Release item query returned success.');
      $record = db_query("SELECT * FROM {salesforce_queue} q WHERE item_id = :item_id", array(':item_id' => $item[1]->item_id))->fetchObject();
      $this->assertEqual(0, $record->expire, 'Released queue item has had it\'s expire time set back to 0.');

      // Delete
      $this->assertTrue($item[0]->deleteItem($item[1]), 'Delete item query returned success.');
      $record = db_query("SELECT * FROM {salesforce_queue} q WHERE item_id = :item_id", array(':item_id' => $item[1]->item_id))->fetchObject();
      $this->assertFalse($record, 'The deleted queue item is nowhere to be found in the queue.');
    }

    // deleteQueue()
    // When you define a specific queue, it deletes all items in that queue only
    $foo_queue->deleteQueue();
    $result = $foo_queue->numberOfItems();
    $this->assertEqual(0, $result, 'Counted '. $result .' items in the Foo queue when we had deleted the Foo queue.');
    $result = $whole_queue->numberOfItems();
    $this->assertEqual(3, $result, 'Counted '. $result .' items in the whole queue when we had only deleted the Foo queue.');
    $result = $new_queue->numberOfItems();
    $this->assertEqual(3, $result, 'Counted '. $result .' items in the new queue when we had only deleted the Foo queue.');

    // If you don't define a specific queue, it purges the whole queue
    // Create some more foo items to ensure that cross-queues get deleted
    $this->createQueueItems($foo_queue);
    $whole_queue->deleteQueue();
    $result = $whole_queue->numberOfItems();
    $this->assertEqual(0, $result, 'Counted '. $result .' items in the whole queue when we had purged the queue.');
    $result = $foo_queue->numberOfItems();
    $this->assertEqual(0, $result, 'Counted '. $result .' items in the Foo queue when we had purged the queue.');

    // itemInQueue()
    // Lets see if an item we've claimed is in the queue
    $this->createQueueItems($whole_queue, 15);
    $item = $whole_queue->claimItem();
    $data = (array)$item;
    $this->assertTrue($whole_queue->itemInQueue($data), 'The claimed item is in queue.');
    // Now lets claim items and change just one trait and ensure it fails
    $keys = array('drupal_id', 'module', 'delta', 'salesforce_type');
    foreach ($keys as $key) {
      $item = $whole_queue->claimItem();
      $data = (array)$item;
      $data[$key] = 'foo';
      $this->assertFalse($whole_queue->itemInQueue($data), 'The altered claimed item is not in the queue.');
    }
  }
}
