<?php

/**
 * @file
 * This module provides functionality for pre-popluating forms from an ecrypted query string parameter.
 */

/**
 * Implmentation of hook_menu().
 */
function secure_prepopulate_menu() {
  $items['admin/config/system/secure-prepopulate'] = array(
    'title' => 'Secure Pre-populate',
    'description' => 'Secure Pre-populate settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('secure_prepopulate_admin_settings'),
    'access arguments' => array('administer secure pre-populate'),
    'file' => 'secure_prepopulate.admin.inc',
  );
  $items['secure-prepopulate/not-me/%'] = array(
    'title' => 'Not me',
    'page callback' => 'secure_prepopulate_clear',
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Callback for clearing node specific prepopulate values.
 *
 * @param $nid
 * The nid of the node who's prepopulate data should be cleared.
 */
function secure_prepopulate_clear($nid) {
  global $user;
  secure_prepopulate_clear_session($nid);
  if (user_is_logged_in()) { // Log user out.
    session_destroy();
    $null = NULL;
    user_module_invoke('logout', $null, $user); // Coder: This is ok.
    $user = drupal_anonymous_user();
  }
  drupal_goto('node/' . $nid);
}

/**
 * Implements hook_permission().
 */
function secure_prepopulate_permission() {
  return array(
    'administer secure pre-populate' => array(
      'title' => t('administer secure pre-populate'),
      'description' => t('Administer Secure Pre-populate settings.'),
    ),
  );
}

/**
 * Implements hook_init().
 */
function secure_prepopulate_init() {
  // Check for the presence of the af query string parameter and we're on a node page.
  if (isset($_GET['af']) && arg(0) == 'node' && is_numeric(arg(1))) {
    $af = $_GET['af'];
    $nid = arg(1);
    // Use the full query string for hash expiration.
    $qs = !empty($_SERVER['QUERY_STRING']) ? $_SERVER['QUERY_STRING'] : 'q=node/' . $nid . '&af=' . $af;
    // First, check to see if the query string has already been used.
    if (!secure_prepopulate_is_expired($qs)) {
      // Run af param through decryption routine.
      if ($fields = secure_prepopulate_decrypt($af)) {
        $_SESSION['secure_prepopulate_values'][$nid] = $fields; // Coder: This is ok.
        if ($fields['uid']) {
          secure_prepopulate_login_user($fields['uid']);
        }
        // Expire the query string.
        secure_prepopulate_expire($qs);
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function secure_prepopulate_theme() {
  return array(
    'secure_prepopulate_welcome_message' => array(
      'variables' => array('values' => NULL, 'nid' => NULL),
      'template' => 'templates/secure-prepopulate-welcome-message',
      'pattern' => 'secure_prepopulate_welcome_message_[0-9]+',
    ),
  );
}

/**
 * Implemenation of hook_node_view().
 *
 * Adds a welcome_back key to the node for themeing and output.
 */
function secure_prepopulate_node_view($node, $view_mode, $langcode) {
  // First check to see if there is any prepopulate values available.
  if (is_array($_SESSION['secure_prepopulate_values'])) { // Coder: This is ok.
    if ($view_mode == 'full' && !empty($node->webform) && array_key_exists($node->nid, $_SESSION['secure_prepopulate_values'])) { // Coder: This is ok.
      $node->content['welcome_back'] = array(
        '#value' => theme(array('secure_prepopulate_welcome_message_' . $node->nid, 'secure_prepopulate_welcome_message'),
          array('values' => $_SESSION['secure_prepopulate_values'][$node->nid], 'nid' => $node->nid)), // Coder: This is ok.
        '#weight' => -1,
      );
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function secure_prepopulate_form_alter(&$form, &$form_state, $form_id) {
  // Make sure the node has a webform.
  if (strstr($form_id, 'webform_client_form')) {
    $node = $form['#parameters'][2];
    // See if the user has any pre-popluate data for this node in their session.
    $prepopulate_data = isset($_SESSION['secure_prepopulate_values'][$node->nid]) ? $_SESSION['secure_prepopulate_values'][$node->nid] : NULL; // Coder: This is ok.
    $precedence = variable_get('secure_prepopulate_precedence', 'url');
    // If we have some data to pre-populate add a function to call on after_build so we can be sure that we're the last ones to alter the form.
    if (!empty($prepopulate_data)) {
      // If a user is logged in, the precedence must be set to url.
      if (!user_is_logged_in() || (user_is_logged_in() && $precedence == 'url')) {
        $form['#after_build'][] = 'secure_prepopulate_after_build';
        $form['#submit'][] = 'secure_prepopulate_submit';
      }
    }
  }
}

/**
 * After build form alteration routine to ensure that url prepopulation is the last thing that happens.
 */
function secure_prepopulate_after_build($form, &$form_state) {
  $node = $form['#parameters'][2];
  // see if the user has any pre-populate data for this node in their session
  $prepopulate_data = isset($_SESSION['secure_prepopulate_values'][$node->nid]) ? $_SESSION['secure_prepopulate_values'][$node->nid] : array(); // Coder: This is ok.
  if (!empty($form_state['submitted'])) {
    // Skip the prepopulate work, as we've already submitted the form and it is
    // being validated or otherwise altered by the user. Exit here cleanly.
    return $form;
  }
  $precedence = variable_get('secure_prepopulate_precedence', 'url');
  $components = $node->webform['components'];
  // Create an data structure that will tell us exactly where each webform component lives in the FAPI array.
  $component_hierarchy = _secure_prepopulate_parse_form($node->nid, $components);
  // Try to prepopulate any fields found in the prepopulate_data array.
  foreach ($prepopulate_data as $form_key => $value) {
    if ($field =& _secure_prepopulate_find_field($form, $component_hierarchy[$form_key])) {
      switch ($field['#type']) {
        case 'radios':
          if (array_key_exists($value, $field)) {
            $field[$value]['#value'] = $value;
          }
        break;
        case 'checkboxes':
          if (array_key_exists($value, $field)) {
            $field[$value]['#value'] = $value;
          }
          $value = array($value);
        break;
        case 'date':
          $timezone = $field['#webform_component']['extra']['timezone'] != 'user' ? NULL : 'user';
          $value = webform_date_array($value, 'date');
          $field['month']['#value'] = $value['month'];
          $field['year']['#value'] = $value['year'];
          $field['day']['#value'] = $value['day'];
        break;
      }
      $field['#value'] = $value;
      $field['#default_value'] = $value;
    }
  }
  // Clear out any other form fields that might be populated by another module.
  foreach ($component_hierarchy as $form_key => $value) {
    if (!array_key_exists($form_key, $prepopulate_data)) { // the key is not in the prepopuldate data, so lets clear it out
      if ($field =& _secure_prepopulate_find_field($form, $component_hierarchy[$form_key])) {
        // set back to original default value by using the webform component definition
        switch ($field['#type']) {
          case 'hidden':
            // If it's a hidden field, leave the values intact.
          continue;
          case 'date':
            if (drupal_strlen($field['#webform_component']['value']) > 0) {
              $timezone = $field['#webform_component']['extra']['timezone'] != 'user' ? NULL : 'user';
              $default_values = webform_date_array(webform_strtodate('c', $field['#webform_component']['value'], $timezone), 'date');
            }
            else {
              $default_values = array(
                'day' => NULL,
                'month' => NULL,
                'year' => NULL,
              );
            }
            $field['month']['#value'] = $default_values['month'];
            $field['day']['#value'] = $default_values['day'];
            $field['year']['#value'] = $default_values['year'];
          break;
          case 'checkboxes':
            $field[$field['#webform_component']['form_key']]['#value'] = $field['#webform_component']['value'];
          break;
          default:
            if (strpos($field['#webform_component']['value'], '%get[') !== FALSE) {
              // If the default value is %get[something], set the field to nothing.
              $field['#value'] = NULL;
              $field['#default_value'] = NULL;
            }
            else {
              // For all other component default values, copy them to $field.
              $field['#value'] = $field['#webform_component']['value'];
              $field['#default_value'] = $field['#webform_component']['value'];
            }
          break;
        }
      }
    }
  }
  return $form;
}

/**
 * Submit handler for forms that have been prepopulated.
 */
function secure_prepopulate_submit(&$form, &$form_state) {
  $node = $form['#parameters'][2];
  secure_prepopulate_clear_session($node->nid);
}

/**
 * Helper function, Decrypts query string paramater using a shared key.
 *
 * This function will attempt to decrypt a string with an
 * AES Key and IV that have been preconfigued.
 *
 * @param $cipher
 *   The cipher text to decrypt.
 */
function secure_prepopulate_decrypt($cipher) {
  $key = variable_get('secure_prepopulate_key', NULL);
  $iv = variable_get('secure_prepopulate_iv', NULL);
  if (!$key || !$iv) {
    watchdog('Secure pre-populate', 'Cannot perform decryption because AES Key and IV have not been configured correct.', NULL, WATCHDOG_CRITICAL);
    return;
  }
  $raw_qs = _secure_prepopulate_decrypt($cipher, $key, $iv);
  return secure_prepopulate_parse_qs($raw_qs);
}

/**
 * Helper function, Attempts to automatically login a user given their uid.
 *
 * @param $uid
 *   The uid of the user to log in.
 */
function secure_prepopulate_login_user($uid) { // Coder: This is ok.
  if (!user_is_logged_in()) {
    $user = user_load($uid);
    if ($user) {
      return user_external_login($user);
    }
    return FALSE;
  }
  return TRUE;
}

/**
 * Helper function, Parses the decrypted query string into an array.
 *
 * @param $qs
 *   The query string to parse in key/value pair format.
 */
function secure_prepopulate_parse_qs($qs) {
  $result = array();
  $segments = explode('&', $qs);
  // Loop over each field in the segement and extract the key/value pairs.
  if (count($segments)) {
    foreach ($segments as $segment) {
      $key_value = explode('=', $segment);
      $result[$key_value[0]] = $key_value[1];
    }
  }
  return $result;
}


/**
 * Helper function, Determines if an encrypted query string has already been used.
 *
 * @param $qs
 *   The query string to examine.
 */
function secure_prepopulate_is_expired($qs) {
  $qs_hashed = md5($qs);
  $result = db_query("SELECT COUNT(hash) FROM {secure_prepopulate_expired} WHERE hash = :hash", array(':hash' => $qs_hashed))->fetchField();
  // if no results it's a new query string
  if ($result == 0) {
    return FALSE;
  }
  watchdog('Secure pre-populate', 'Attempted use of encrypted query string @q', array('@q' => $qs_hashed), array('langcode' => NULL, '' => WATCHDOG_NOTICE));
  return TRUE;
}

/**
 * Helper function, expires query string so it cannot be used more than once.
 *
 * @param $qs
 *   The query string to expire.
 */
function secure_prepopulate_expire($qs) {
  $qs_hashed = md5($qs);
  $record = new stdClass();
  $record->hash = $qs_hashed;
  $record->expire_date = REQUEST_TIME;
  drupal_write_record('secure_prepopulate_expired', $record);
}

/**
 * Helper function, Clears the decrypted values from the user's session.
 *
 * @param $nid
 *   The id of the node who's prepopulated data should be cleared.
 */
function secure_prepopulate_clear_session($nid) {
  unset($_SESSION['secure_prepopulate_values'][$nid]); // Coder: This is ok.
}

/**
 * Helper function, creates a nested array of where components exist in the FAPI array for all components in a webform.
 *
 * @param $nid
 *   The nid of the node that contains the webform.
 * @param $components
 *   The webform components array attached to the node.
 */
function _secure_prepopulate_parse_form($nid, $components) {
  $component_hierarchy = array();
  foreach ($components as $cid => $component) {
    $component_path = 'submitted[' . implode('][', _secure_prepopulate_walk_component_hierarchy($nid, $cid)) . ']';
    parse_str($component_path, $output); // convert string to a nested array
    $component_hierarchy[$component['form_key']] = $output;
  }
  return $component_hierarchy;
}

/**
 * Helper function, Builds a path from the webform component to it's topmost parent.
 *
 * @param $nid
 *   The nid of the node that contains the webform.
 * @param $cid
 *   The cid of the webform component being examined.
 * @param $path
 *   The current path to the component within the webform component array.
 *   This path is built up using recursion.
 */
function _secure_prepopulate_walk_component_hierarchy($nid, $cid, &$path = array()) {
  $result = db_query("SELECT cid, pid, form_key FROM {webform_component} WHERE nid = :nid and cid = :cid", array(':nid' => $nid, ':cid' => $cid));
  while ($data = db_fetch_object($result)) {
    array_unshift($path, $data->form_key);
    if ($data->pid > 0) {
      _secure_prepopulate_walk_component_hierarchy($nid, $data->pid, $path);
    }
  }
  return $path;
}

/**
 * Helper function, Returns a reference to an element of a FAPI array based on a known path.
 *
 * @param $form
 *   The form array that contains the field to find.
 * @param $path
 *   A nested array that represents the path to the field within the FAPI array.
 */
function &_secure_prepopulate_find_field(&$form, $path) {
  if (is_array($path)) {
    foreach (array_keys($path) as $v) {
      if (is_array($path[$v]) && count($path[$v])) { // if there are more keys
        return _secure_prepopulate_find_field($form[$v], $path[$v]);
      }
      else {
        return $form[$v];
      }
    }
  }
}

/**
 * Helper function, Encrypt an input string (128 bit AES) using the specified key and initialization vector.
 *
 * @param $input
 *   The string to encrypt.
 * @param $key
 *   The 128 bit key to use to encrypt the string.
 * @iv
 *   The initialization vector to use to encrypt the string.
 */
function _secure_prepopulate_encrypt($input, $key, $iv) {
  $size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
  $input = pkcs5_pad($input, $size);
  $descriptor = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');
  mcrypt_generic_init($descriptor, $key, $iv);
  $cipher = mcrypt_generic($descriptor, $input);
  mcrypt_generic_deinit($descriptor);
  mcrypt_module_close($descriptor);
  $cipher = base64_encode($cipher);
  $cipher = urlencode($cipher);
  return $cipher;
}

/**
 * Helper function, Decrypts AES encrypted data.
 *
 * @param $cipher
 *   The encrypted data to decrypt.
 * @param $key
 *   The 128 bit key to use to decrypt the string.
 * @iv
 *   The initialization vector to use to decrypt the string.
 */
function _secure_prepopulate_decrypt($cipher, $key, $iv) {
  $cipher = base64_decode($cipher);
  $descriptor = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');
  mcrypt_generic_init($descriptor, $key, $iv);
  $decrypted_data = mdecrypt_generic($descriptor, $cipher);
  mcrypt_generic_deinit($descriptor);
  mcrypt_module_close($descriptor);
  // account for some PHP AES shortcomings
  $decrypted_data = pkcs5_unpad($decrypted_data);
  $decrypted_data = rtrim($decrypted_data);
  return $decrypted_data;
}

/**
 * Helper function, for padding text to PKCS5 specification.
 *
 * @param $text
 *   The text to pad.
 * @param $blocksize
 *   The size of the PKCS5 blocksize to use.
 */
function pkcs5_pad($text, $blocksize) {
  $pad = $blocksize - (drupal_strlen($text) % $blocksize);
  return $text . str_repeat(chr($pad), $pad);
}

/**
 * Helper function, to unpad PKCS5 padded text.
 *
 * @param $text
 *   The text to unpad.
 */
function pkcs5_unpad($text) {
  $pad = ord($text{strlen($text) -1});
  if ($pad > drupal_strlen($text)) {
    return FALSE;
  }
  return drupal_substr($text, 0, -1 * $pad);
}
