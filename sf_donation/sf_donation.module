<?php
// $Id: sf_donation.module,v 1.0.0.0 2009/08/14 06:44:28 pcave Exp $

/**
 * @file
 * Integrates webform submissions with the Salesforce API.
 */

/**
 * Implementation of hook_menu().
 */
function sf_donation_menu() {
	$items['node/%webform_menu/edit/salesforce-donation-mapping'] = array(
	    'title' => 'Salesforce Donation Mapping',
	    'page callback' => 'drupal_get_form',
	    'page arguments' => array('sf_donation_mapping_form', 1),
	    'access callback' => 'mapping_form_access',
	    'weight' => 35,
	    'type' => MENU_LOCAL_TASK,
	);

	$items['admin/store/orders/%uc_order/export'] = array(
		'title' => t('Export to Salesforce'),
		'page callback' => 'drupal_get_form',
		'page arguments' => array('sf_donation_export_confirm_form'),
		'access callback' => 'check_order_export_status',
		'access arguments' => array(3),
		'weight' => 20,
		'type' => MENU_LOCAL_TASK,
	);
	
	$items['fix_one_offs'] = array(
		'title' => 'Fix one off donation errors',
		'page callback' => 'fix_one_off_errors',
		'access callback' => TRUE,
		'type' => MENU_CALLBACK,
	);

	return $items;
}

/**
 * Function to check whether or not an order has been exported to salesforce
 */
function check_order_export_status($order) {
	$sfid = db_result(db_query("SELECT sfid FROM {fundraiser_webform_order} WHERE order_id = %d UNION
		SELECT sf_opportunity_id AS sfid FROM {fundraiser_recurring} WHERE order_id = %d", $order->order_id, $order->order_id));

	if (!empty($sfid)) {
		return TRUE;
	}
	
	return FALSE;
}



/**
 * Confirmation form for manually exporting order to salesforce
 */
function sf_donation_export_confirm_form() {
	$order_id = arg(3);
	// get the user
	$user = db_fetch_object(db_query("SELECT billing_first_name, billing_last_name FROM {uc_orders} WHERE order_id = %d", $order_id));
	$donations = get_orders_for_export($order_id);
	
	// get recurring donations for close dates
	$result = db_query("SELECT order_id, next_charge FROM {fundraiser_recurring} WHERE master_order_id = %d", $order_id);
	while ($data = db_fetch_object($result)) {
		$close_dates[$data->order_id] = date('m-d-Y', $data->next_charge);
	}
	
	$output = '<h3>Donations</h3>';
	$header = array('Order ID', 'Salesforce ID', 'Donor Name', 'Amount', 'Close Date', 'Transaction Date');
	$rows = array();
	
	foreach ($donations as $key => $donation) {
		$rows[] = array(
			$donation['fields']['Order_ID__c'],
			$donation['fields']['Id'],
			$user->billing_first_name . ' ' . $user->billing_last_name,
			$donation['fields']['Amount'],
			$donation['fields']['CloseDate'] ? date('m-d-Y', strtotime($donation['fields']['CloseDate'])) : $close_dates[$donation['fields']['Order_ID__c']],
			$donation['fields']['Transaction_Date_Time__c'] ? date('m-d-Y h:i A', strtotime($donation['fields']['Transaction_Date_Time__c'])) : 'N/A',
		);
	}
	
	$output .= theme('table', $header, $rows);
	
	$form['order_id'] = array(
		'#type' => 'hidden',
		'#value' => $order_id,
	);
	return confirm_form($form, "Are you sure you want to re-export order $order_id to Salesforce?", 'admin/store/orders/'. $order_id, $output . "<p>Any values that have been changed in Salesforce will be overwritten.</p>", $yes = "Export", $no = "Cancel", $name = 'confirm');
}

/**
 * Logic to manually export an order to Salesforce
 */
function sf_donation_export_confirm_form_submit($form, &$form_state) {
	
	// get the webform submission id for mapped fields
	$order_id = $form_state['values']['order_id'];
	$donations = get_orders_for_export($order_id);
	
	// pop off the actual objects
	$donations_to_update = array();
	foreach ($donations as $value) {
		$donations_to_update[] = $value['fields'];
	}
	
	$sf = salesforce_management_api_connect();
	// only continue if we got a valid connection
	if ($sf) {
		$results = $sf->client->update($donations_to_update, 'Opportunity');
	}
	
	$failure_count = 0;
	$success_count = 0;
	$count = count($donations);
	
	// deal with salesforce's inconsistent returns
	if (!is_array($results)) {
		$temp = $results;
		$results = array();
		$results[] = $temp;
	}
	
	for ($i = 0; $i < $count; $i++) {
		if (!$results[$i]->success) {
			watchdog('salesforce', t('Order !order_id failed to update in Salesforce. Error: !error', array('!order_id' => $donations[$i]['order_id'], '!error' => print_r($results[$i]->error, true))), NULL, WATCHDOG_ERROR);
			$failure_count++;
		}
		else {
			$success_count++;
			uc_order_comment_save($donations[$i]['order_id'], 0, 'Order manually exported to Salesforce.', 'admin'); 
		}
	}
	
	drupal_set_message($success_count . ' orders successfully updated in Salesforce. ' . $failure_count . ' failed.');
	$form_state['redirect'] = 'admin/store/orders/' . $order_id;
}

function get_orders_for_export($order_id) {
	
	// only allow export en-mass (e.g., don't allow a single donation in a series, instead, get the whole series)
	$count = db_result(db_query("SELECT count(order_id) FROM {fundraiser_webform_order} WHERE order_id = %d", $order_id));
	if ($count == 0) {
		$order_id = db_result(db_query("SELECT master_order_id FROM {fundraiser_recurring} WHERE order_id = %d", $order_id));
	}
	
	$result = db_query("SELECT f.sid, f.sfid, u.uid FROM {fundraiser_webform_order} f INNER JOIN 
		{uc_orders} u on u.order_id = f.order_id WHERE f.order_id = %d", $order_id);
	
	while ($data = db_fetch_object($result)) {
		$sid = $data->sid;
		$uid = $data->uid;
		$sfid = $data->sfid;
	}
	
	$order_ids_to_export[] = array(
		'order_id' => $order_id,
		'sfid' => $sfid,
	);
	
	// see if it is a recurring donation
	$result = db_query("SELECT order_id, sf_opportunity_id FROM {fundraiser_recurring} WHERE master_order_id = %d", $order_id);
	
	while ($data = db_fetch_object($result)) {
		$order_ids_to_export[] = array(
			'order_id' => $data->order_id,
			'sfid' => $data->sf_opportunity_id,
		);
	}

	$donations = array();
	
	if ($sid) {
		// load the user
		$user = user_load($uid);
		foreach($order_ids_to_export as $key => $value) {			
			$donation = _create_single_donation($value['order_id'], $user, $sid);
			// remove the name because we don't want to overwrite what was set orginally
			unset($donation['fields']['Name']);
			$donation['order_id'] = $value['order_id'];
			$donation['fields']['Id'] = $value['sfid'];
			$donations[] = $donation;
		}
	}

	return $donations;
}

/**
* Implementation of hook_theme().
*/
function sf_donation_theme() {
	return array(
		'sf_donation_mapping_form' => array(
		'arguments' => array(),
	)
	);
}

/** 
 * Form to map the webform/donation to the Salesforce opportunity object
 */
function sf_donation_mapping_form($form_state, $node) {
	$form = array(
    '#tree' => TRUE,
    '#node' => $node,
    'mapping' => array(),
  );

  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  
  $integrator = _current_donation_integrator();
  $type = $integrator['donation_object']['type'];
  
	$sf = salesforce_management_api_connect();
	$donation = $sf->client->describeSObject($type);
	
	// get record types
	$record_types = array();
	foreach($donation->recordTypeInfos as $record_type) {
		if ($record_type->available && $record_type->name != 'Master') {
			$record_types[$record_type->recordTypeId] = $record_type->name;
		}
	}
	
	$record_types[] = '--Select One--';
  asort($record_types);
	
  $form['single_record_type'] = array(
    '#type' => 'select',
    '#title' => 'Single donation record type',
    '#description' => t('The type of @type to create when a single donation is exported to Salesforce.', array('@type' => $type)),
    '#options' => $record_types,
    '#default_value' => $node->single_recordtype_id,
  );
  
  $form['recurring_record_type'] = array(
    '#type' => 'select',
    '#title' => 'Recurring donation record type',
    '#description' => t('The type of @type to create when a recurring donation is exported to Salesforce.', array('@type' => $type)),
    '#options' => $record_types,
    '#default_value' => $node->recurring_recordtype_id,
  );
	
	$donation_fields = array('' => '--Select One--');
	$mapping_config = _get_mapping_config();
	
	$form['user_mappings'] = array(
		'#value' => t('<h3>Donation Mappings</h3><div>Use this form to map fields to the <strong>@type</strong> object in Salesforce. The current donation storage system is <strong>@integrator</strong>.</div>', array('@type' => $type, '@integrator' => $integrator['name'])),
		'#weight' => -1,
	);

	foreach($donation->fields as $field) {
    $donation_fields[$field->name] = $field->label;
	}
	
	asort($donation_fields);
	
	$node = $form['#node'];
	//_create_donation_map($node->webform['components']);
	
	require_once 'donation.php';
	//$donation = new Donation(1, 348);
	//$o = $donation->map();
  //print "<pre>".print_r($o, TRUE)."</pre>";die();
	$properties = Donation::get_mappable_properties();

	asort($properties);
	
	foreach($properties as $key => $value) {
	 $form['mapping']['donation'][$key] = array(
	   '#type' => 'item',
	   '#description' => $value,
	 );
	 $form['mapping']['salesforce'][$key] = array(
  		'#type' => 'select',
  		'#options' => $donation_fields,
  		'#default_value' => $node->salesforce_map[$key],
  	);
	}
	
	foreach($node->webform['components'] as $cid => $component) {
		if($component['type'] != 'fieldset' && !array_key_exists($component['form_key'], $mapping_config['predefined'])) {
			// component
			$form['mapping']['component'][$component['form_key']] = array(
			'#type' => 'item',
			'#description' => t($component['name']." - (".$component['type'].")"),
			);
			// opportunity field
			$form['mapping']['salesforce'][$component['form_key']] = array(
				'#type' => 'select',
				'#options' => $donation_fields,
				'#default_value' => $node->salesforce_map[$component['form_key']],
			);
		}
	}
	
	$form['submit'] = array('#type' => 'submit', '#value' => t('Save'));

	return $form;
}

/**
 * Implementation of hook_perm().
 */
function sf_donation_perm() {
  return array('sync donations with salesforce');
}

/*
 * Saves salesforce donation map
 */
function sf_donation_mapping_form_submit($form, &$form_state) {
	$integrator = _current_donation_integrator();
	$nid = $form['#node']->nid;
	
	// remove salesforce mappings
	db_query("DELETE FROM {fundraiser_salesforce_map} WHERE nid = %d", $nid);
	
	// re-add mappings
	foreach($form_state['values']['mapping']['salesforce'] as $key => $value) {
		if (!empty($value)) {
		  $map[$value] = $key;
		}
	}
	
	$salesforce = $integrator['donation_object']['type'];
	$single_recordtype_id = $form_state['values']['single_record_type'];
	$recurring_recordtype_id = $form_state['values']['recurring_record_type']; 
	
	// save the map
	db_query("INSERT INTO {fundraiser_salesforce_map} (nid, single_recordtype_id, recurring_recordtype_id, fields, salesforce) VALUES
	 (%d, '%s', '%s', '%s', '%s')", $nid, $single_recordtype_id, $recurring_recordtype_id, serialize($map), $salesforce);

	drupal_set_message(t('Salesforce mapping has been saved'));
}

/**
 * Clones a salesforce donation map
 * TODO: Rewrite for new mapping storage
 */
function sf_donation_clone_map($nid, $new_nid) {
	// get profile map for the original donation form
	$result = db_query("select f.nid, f.cid, f.map_id, c.form_key from {fundraiser_salesforce_map} f inner join
		{webform_component} c on c.cid = f.cid and c.nid = f.nid where f.nid = %d", $nid);
	
	// loop over mapped components and find new component in cloned donation form
	while ($data = db_fetch_object($result)) {
		$cid = db_result(db_query("SELECT cid FROM {webform_component} WHERE form_key = '%s' AND nid = %d", $data->form_key, $new_nid));
		if ($cid) {
			db_query("INSERT INTO {fundraiser_salesforce_map} (nid, cid, map_id) VALUES (%d, %d, '%s')", $new_nid, $cid, $data->map_id);
		}
	}
}

/**
 * Implementaion of hook_nodeapi().
 */
function sf_donation_nodeapi(&$node, $op, $teaser, $page) {
	if($node->type == 'webform') {
		$parts = explode("/",$_GET['q']);
		
		if($parts[0]=='node' && $parts[2]=='edit' && $parts[3] == 'salesforce-donation-mapping' && $op == 'load'){
			$result = db_query("SELECT single_recordtype_id, recurring_recordtype_id, fields FROM {fundraiser_salesforce_map} WHERE nid = %d", $node->nid);
			
			while($row = db_fetch_object($result)) {
        $fields = unserialize($row->fields);
        foreach($fields as $k => $v) {
          $map['salesforce_map'][$v] = $k;  
        }
        $map['single_recordtype_id'] = $row->single_recordtype_id;			   
        $map['recurring_recordtype_id'] = $row->recurring_recordtype_id;
			}
			
			return $map;
		}
	}
}

/**
 * Implementation of hook_sf_donation().
 */
function sf_donation_sf_donation($op, $order_id, $sfid, $message) {
  $aids = _trigger_get_hook_aids('sf_donation', $op);
  $context = array(
    'hook' => 'sf_donation',
    'op' => $op,
    'order_id' => $order_id,
		'sfid' => $sfid,
		'message' => $message,
  );
	$dummy = new stdClass();
  actions_do(array_keys($aids), $dummy, $context, $order_id, $sfid, $message);
}

/**
 * Implemenation of hook_menu_alter().
 */
function sf_donation_menu_alter(&$items) {
	// not sure why this is needed, but the custom trigger was not showing up without it
	$items['admin/build/trigger/sf_donation']['access callback'] = TRUE;
}

/**
 * Implementation of hook_form_alter().
 */
function sf_donation_form_alter(&$form, $form_state, $form_id) {
	switch($form_id) {
		case 'webform_component_edit_form':
			if ($form['advanced']['form_key']['#default_value'] == 'cid') {
				// turn it into a select field
				// get campaigns from salesforce
				$campaigns = _get_campaigns();
				if (!empty($campaigns)) {
					$form['value']['#type'] = 'select';
					$form['value']['#options'] = $campaigns;
				}
			}
			break;
			
		case 'salesforce_management_api_settings_form':
			// get campaigns from salesforce
			$campaigns = _get_campaigns();
			array_unshift($campaigns, '-- Please select --');
			
			$form['sf_donation'] = array(
	      '#type' => 'fieldset',
	      '#title' => t('Donation integration'),
	      '#description' => t('Fundraiser module integration settings.'),
	      '#collapsible' => TRUE,
	      '#collapsed' => TRUE,
	      '#weight' => -1,
	    );

			$form['sf_donation']['sf_donation_debug'] = array(
				'#type' => 'checkbox',
				'#title' => t('Debug mode'),
				'#description' => t('Log detailed information about each API call.'),
				'#default_value' => variable_get('sf_donation_debug', 0),
			);

			$form['sf_donation']['sf_donation_default_campaign'] = array(
				'#type' => 'select',
				'#title' => t('Default campaign'),
				'#description' => t('The default campaign to which donations will be assigned.'),
				'#options' => $campaigns,
				'#default_value' => variable_get('sf_donation_default_campaign', ''),
			);
			
			// get a list of installed donation integration modules
			$integrators = _donation_integration_list();
			$options = array();
			foreach ($integrators as $integrator) {
        $options[$integrator['id']] = $integrator['name'];
			}
			
			if (count($options) == 0) {
			 $message = t('There are no donation integration modules enabled. Donations will not be exported until one is enabled');
			 drupal_set_message($message);
			 watchdog('salesforce donation', $message, NULL, WATCHDOG_INFO);
			}
			
			$form['sf_donation']['sf_donation_backend'] = array(
        '#type' => 'select',
        '#title' => t('Salesforce Donation Application'),
        '#description' => t('The application Salesforce is using to process donations'),
        '#options' => $options,
        '#default_value' => variable_get('sf_donation_backend', 'npsp'),
			);

			break;
	}
}

/**
 * Implementation of hook_hook_info(). 
 */
function sf_donation_hook_info() {
	return array(
		'sf_donation' => array(
			'sf_donation' => array(
				'fails' => array(
					'runs when' => t('When a salesforce donation synchronization fails'),
				),
			),
		),
	);
}

/**
 * Implemenation of hook_queue_salesforce_info().
 */
function sf_donation_queue_salesforce_info($type, $action) {

	// since donations do not use fieldmaps in a traditional sense, we manually assign their Salesforce types here
	$integrator = _current_donation_integrator();
	
	switch ($type) {
		
		case FUNDRAISER_SINGLE_DONATION_TYPE:
			
			$data = array(
				'salesforce' => $integrator['donation_object']['type'],
				'dedupe_key' => $integrator['donation_object']['dedupe_key'],
			);
			break;
			
		case FUNDRAISER_RECURRING_DONATION_TYPE:
			$data = array(
				'salesforce' => $integrator['recurring_donation_object']['type'],
				'dedupe_key' => $integrator['recurring_donation_object']['dedupe_key'],
			);
			break;
		
	}
	
	return $data;
	
}


/**
 * Implementation of queue_preprocess_batch_alter().
 */
function sf_donation_queue_preprocess_batch_alter(&$batch) {

	if ($batch['type'] == 'donation' || $batch['type'] == 'recurring_donation') {
		foreach($batch['records'] as $record) {
			// get additional details about the order
			$details = db_fetch_object(db_query("SELECT f.sid, u.uid FROM {uc_orders} u INNER JOIN {fundraiser_webform_order} f ON f.order_id = u.order_id WHERE u.order_id = %d", $record->oid));
		
			// if empty, then the donation was part of a recurring series
			if (empty($details)) {
				$details = db_fetch_object(db_query("SELECT f.sid, u.uid FROM {uc_orders} u INNER JOIN {fundraiser_recurring} fr ON fr.order_id = u.order_id INNER JOIN
					{fundraiser_webform_order} f on f.order_id = fr.master_order_id WHERE u.order_id = %d", $record->oid));
			}
			
			$user_ids = _sf_donation_load_user_salesforce_ids($details->uid);
			
			switch ($batch['type']) {
				case FUNDRAISER_SINGLE_DONATION_TYPE:
					$object = _create_single_donation($record->oid, $user_ids->salesforce_account_id, $details->sid);
					if ($batch['action'] == 'update' && !empty($record->sfid)) {
						$object['Id'] = $record->sfid;
					}
					$record->object = $object;
					break;
					
				case FUNDRAISER_RECURRING_DONATION_TYPE:
					$donation_count = _recurring_donation_count($record->oid, $user);
					$donation_count++; // account for original order
					$record->object = _create_recurring_donation($record->oid, $user_ids, $donation_count);
					break;
			}
		}
	}

}

/**
 * Implemenation of hook_queue_postprocess_batch().
 */
function sf_donation_queue_postprocess_batch($batch, $responses, $item_count) {
	
	switch ($batch['type']) {
		case FUNDRAISER_SINGLE_DONATION_TYPE:

			if ($batch['action'] == create) {
				
				for ($i = 0; $i < $item_count; $i++) {
					if ($responses[$i]->success) {	
						$sfid = $responses[$i]->id;
						db_query("UPDATE {fundraiser_webform_order} SET sfid = '%s' WHERE order_id = %d", $sfid, (int)$batch['records'][$i]->oid);
						$user_ids = _sf_donation_load_user_salesforce_ids_from_order((int)$batch['records'][$i]->oid);
						
						// create and save the contact roles						
						$table = 'sf_donation_opportunity_contact_role';
						$record = new stdClass();
						$record->contact_id = $user_ids->salesforce_contact_id;
						$record->opportunity_id = $sfid;
						$record->role = 'Donor';
						drupal_write_record($table, $record);
								
					}
				}
				
				// export them
				sf_donation_export_opportunity_contact_roles();	
			}
			break;
			
		case FUNDRAISER_RECURRING_DONATION_TYPE:

      // determine integrator
      $integrator = _current_donation_integrator();
      $function = $integrator['recurring_donation_object']['postprocess'];
      $function($batch, $responses, $item_count);
			
			break;	
	}
	
}

/**
 * Exports opportunity contact role objects to Salesforce
 */
function sf_donation_export_opportunity_contact_roles() {

	$sf = salesforce_management_api_connect();
	// only continue if we got a valid connection
	if ($sf) {	
		
		// get all un-exported records
		$result = db_query("SELECT contact_id, opportunity_id, role FROM {sf_donation_opportunity_contact_role} WHERE exported = %d", 0);
		$contact_roles = array();
		while ($data = db_fetch_object($result)) {
			// create the object
			$contact_roles[] = array(
				'ContactId' => $data->contact_id,
				'OpportunityId' => $data->opportunity_id,
				'Role' => $data->role,
			);
		}
	
		// divide them up if we've got more than 200
		$pieces = ceil(count($contact_roles) / 200);
		$batches = array_split($contact_roles, $pieces);
		
		foreach($batches as $batch) {
			$response = _normalize_salesforce_response($sf->client->create($batch, 'OpportunityContactRole'));

			// Process responses
			$items_in_batch = count($batch);
			for ($i = 0; $i < $items_in_batch; $i++) {
				if ($response[$i]->success) {
					db_query("UPDATE {sf_donation_opportunity_contact_role} SET exported = %d WHERE contact_id = '%s' AND opportunity_id = '%s'", 1, $batch[$i]['ContactId'], $batch[$i]['OpportunityId']);
				}
				else {
					watchdog('salesforce donation', t('Unable to create opportunity contact roles for opportunity !id.', array('!id' => $batch[$i]['OpportunityId'])), NULL, WATCHDOG_CRITICAL);		
				}
			}
		}
	}
	else {
		watchdog('salesforce donation', t('Could not connect to Salesforce. Opportunity Contact Roles were not created at this time. They have been saved and will be exported with the next donation.'), NULL, WATCHDOG_CRITICAL);
	}

}

/**
 * Splits an array into a specified number of new arrays
 */
function array_split($array, $pieces = 2)
{  
	if ($pieces < 2) {
		return array($array);
	}
	
	$newCount = ceil(count($array)/$pieces);
	$a = array_slice($array, 0, $newCount);
	$b = array_split(array_slice($array, $newCount), $pieces-1);
	return array_merge(array($a),$b);
} 

/**
 * Returns the salesforce ids of a given user (prevents having to call node_load())
 */
function _sf_donation_load_user_salesforce_ids($uid) {
	$result = db_query("SELECT 
		CASE WHEN instr(u.data, 'salesforce_account_id') THEN substring(u.data, instr(u.data, 'salesforce_account_id')+29, 18)
		ELSE NULL
		END AS salesforce_account_id,
		CASE WHEN instr(u.data, 'salesforce_contact_id') THEN substring(u.data, instr(u.data, 'salesforce_contact_id')+29, 18)
		ELSE NULL
		END AS salesforce_contact_id 
		FROM {users} u 
		WHERE u.uid = %d", $uid);
		
	return db_fetch_object($result);	
}

/**
 * Uses an order id to look up the user's Salesforce ids.
 */
function _sf_donation_load_user_salesforce_ids_from_order($order_id) {
	$result = db_query("SELECT 
		CASE WHEN instr(u.data, 'salesforce_account_id') THEN substring(u.data, instr(u.data, 'salesforce_account_id')+29, 18)
		ELSE NULL
		END AS salesforce_account_id,
		CASE WHEN instr(u.data, 'salesforce_contact_id') THEN substring(u.data, instr(u.data, 'salesforce_contact_id')+29, 18)
		ELSE NULL
		END AS salesforce_contact_id 
		FROM {users} u INNER JOIN
		{uc_orders} o ON o.uid = u.uid WHERE o.order_id = %d", $order_id);
		
	return db_fetch_object($result);
}

/**
 * Creates an array that represents a salesforce opportunity object
 */
function _create_single_donation($order_id, $account_id, $sid) {
  $integrator = _current_donation_integrator();
  $function = $integrator['donation_object']['create'];
  return $function($order_id, $account_id, $sid);
}

/*
 * Creates an array that represents a salesforce recurring donation object
 */
function _create_recurring_donation($order_id, $user_ids, $count) {
	$order = uc_order_load($order_id);
	
	// determine integrator
	$integrator = _current_donation_integrator();
  $function = $integrator['recurring_donation_object']['create'];
  $donation = $function($order, $user_ids, $count);
	
  // clear the credit card cache
	uc_credit_cache('clear');
	return $donation;
}

/**
 * Returns the ISO code for a give country id.
 */
function _convert_billing_country($country_id) {
	return db_result(db_query("SELECT country_iso_code_2 FROM {uc_countries} WHERE country_id = %d", $country_id));
}

/* 
 * Updates an opportunity when a donation payment processes.
 */
function sf_donation_update_donation_status($order_id) {
	// get the sfid from the recurring orders table
	$sfid = db_result(db_query("SELECT sf_opportunity_id FROM {fundraiser_recurring} WHERE order_id = %d", $order_id));
	if ($sfid) {
		// get order payment so we can get the transaction date
		$payments = uc_payment_load_payments($order_id);
		// deal with sf date handling
		$transaction_date = strtotime(date('H:i:s d-M-Y T', $payments[0]->received));
		
		$opportunity = array(
			'Id' => $sfid,
			'Transaction_Date_Time__c' => gmdate('c', $transaction_date),
			'Probability' => 100.00,
			'StageName' => 'Posted',
		);
		
		$sf = salesforce_management_api_connect();
		$results = $sf->client->update(array($opportunity), 'Opportunity');
		
		if (!$results->success) {
			// Log failure
			watchdog('error', "Opportunity $sfid was not updated in salesforce after a recurring payment was processed. Errors: $results->errors");
			// Trigger failure
			//module_invoke_all('sf_donation', 'fails', $order_id, $sfid, "Opportunity $sfid was not updated in salesforce after a recurring payment was processed. Errors: $results->errors");
			$params = array(
				'order_id' => $order_id,
				'errors' => $results->errors,
				'donation' => print_r($opportunity, true),
			);
			drupal_mail('sf_donation', 'recurring_donation_payment_failure', 'phillip.cave@jacksonriver.com,tom.williamson@jacksonriver.com,tj.griffin@jacksonriver.com', language_default(), $params);
		}
		else {
			watchdog('salesforce', t('Opportunity !sfid updated to stage Posted at !time. Order Id is !order_id', array('!sfid'=>$sfid, '!time'=>gmdate('c', $transaction_date), '!order_id'=>$order_id)), NULL, WATCHDOG_INFO);
		}
	}
} 

/**
 * Updates the donation amount of recurring orders
 */
function sf_donation_update_donation_amount($order_ids, $amount) {
	// get all of the recurring donations that have not been processed
	$sql = "select sf_opportunity_id from {fundraiser_recurring} where order_id in (%s)";
	$results = db_query($sql, implode(",", $order_ids));
	
	$donations = array();
	
	while ($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'Amount' => $amount,
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			$errors = print_r($errors, TRUE);
			watchdog('error', "Donation amount for opportunity $sfid was not updated in salesforce. Errors: $errors");
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Donation amount for opportunity $sfid was not updated in salesforce. Errors: $errors");
		}
	}
}

/**
 * Updates billing information for recurring orders
 */
function sf_donation_update_donation_billing($order_ids) {
	
	// load up one of orders to get the billing information
	$order = uc_order_load($order_ids[0]);
	
	// get all of the recurring donations that have not been processed
	$sql = "select sf_opportunity_id from {fundraiser_recurring} where order_id in (%s)";
	
	$results = db_query($sql, implode(",", $order_ids));
	$donations = array();
	
	while($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'Billing_Street__c' => $order->billing_street1,
			'Billing_Street_Line_2__c' => $order->billing_street2,
			'Billing_State__c' => uc_get_zone_code($order->billing_zone),
			'Billing_Country__c' => _convert_billing_country($order->billing_country),
			'Billing_City__c' => $order->billing_city,
			'Billing_Zip__c' => $order->billing_postal_code,
			'CC_Last_4__c' => !empty($order->payment_details['cc_number']) ? substr($order->payment_details['cc_number'], -4) : '',
			'CC_Exp_Year__c' => $order->payment_details['cc_exp_year'],
			'CC_Exp_Month__c' => $order->payment_details['cc_exp_month'],
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			watchdog('error', "Billing information for opportunity $sfid was not updated in salesforce. Errors: $errors");
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Billing information for opportunity $sfid was not updated in salesforce. Errors: $errors");
		}
	}
}

/**
 * Cancels recurring donations. TODO: This could be moved to the queue.
 */
function sf_donation_canel_recurring_donations($order_id) {
	$sql = "select sf_opportunity_id, cancellation_reason from {fundraiser_recurring} where master_order_id = %d and gateway_resp = 'canceled'";
		
	$results = db_query($sql, $order_id);
	$donations = array();
	
	while ($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'StageName' => 'Withdrawn',
			'Cancellation_Reason__c' => $data->cancellation_reason,
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			watchdog('error', "Opportunity $sfid was not withdrawn in salesforce. Errors: " . print_r($errors, TRUE));
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Opportunity $sfid was not withdrawn in salesforce. Errors: " . print_r($errors, TRUE));
		}
	}
}

/*
 * Loads the donation -> salesforce map for this webform and populates it
 * with data from the actual webform submission
 */
function _load_salesforce_map($sid) {
	$map = array();
	
	$results = db_query(
	 "
	   SELECT f.map_id, c.form_key, s.data 
	   FROM {fundraiser_salesforce_map} f 
	   INNER JOIN {webform_component} c ON c.cid = f.cid AND c.nid = f.nid
		 INNER JOIN {webform_submitted_data} s ON s.cid = c.cid AND s.nid = c.nid 
		 WHERE s.sid = %d
	 ", 
	 $sid
	 );
	 
	while ($data = db_fetch_object($results)) {
		$map[$data->map_id] = $data->data;
	}	

	return $map;
}

/*
 * Gets the number of times a given donation recurs
 */
function _recurring_donation_count($order_id) {
	return db_result(db_query("select count(order_id) from {fundraiser_recurring} where master_order_id = %d", $order_id));
}

/*
 * Updates a webform created order with the id from salesforce
 */
function _update_webform_order($order_id, $sfid) {
	db_query("update {fundraiser_webform_order} set sfid = '%s' where order_id = %d", $sfid, $order_id);
}

/**
 * Theme the mapping form
 */
function theme_sf_donation_mapping_form($form) {
	$output = drupal_render($form['user_mappings']);
	$output .= drupal_render($form['single_record_type']);
	$output .= drupal_render($form['recurring_record_type']);

	$row = array();
	$row[] = 'Donation Properties';
	$row[] = '&nbsp;';
	$rows[] = $row;
	foreach ($form['mapping']['donation'] as $property=>$value) {
	  if (strpos($property, '#') === FALSE) {
      $row = array();
      $row[] = drupal_render($form['mapping']['donation'][$property]);
      $row[] = drupal_render($form['mapping']['salesforce'][$property]);
      $rows[] = $row;
		}
	}
	
	$row = array();
	$row[] = 'Webform Components';
	$row[] = '&nbsp;';
	$rows[] = $row;
	foreach ($form['mapping']['component'] as $key => $cid) {
		if (strpos($key, '#') === FALSE) {
			$row = array();
			$row[] = drupal_render($form['mapping']['component'][$key]);
			$row[] = drupal_render($form['mapping']['salesforce'][$key]);
			$rows[] = $row;
		}
	}
	
	$row = array();
	$row[] = drupal_render($form['submit']);
	$row[] = '&nbsp;';
	$rows[] = $row;

	$header = array("Drupal Field", "Opportunity Field");
	$output .= theme('table', $header, $rows, array('id' => 'sf_donation_mapping_form'));
	$output .= drupal_render($form);

	return $output;
}

function _get_campaigns() {
	$sf = salesforce_management_api_connect();
	$campaigns = array();
	// only continue if we got a valid connection
	if ($sf) {
		$results = $sf->client->query("select Id, Name from Campaign where Status = 'In Progress'");
		if (count($results->records)) {
			foreach($results->records as $campaign) {
				$campaigns[$campaign->Id] = $campaign->Name;
			}
		}
	}
	return $campaigns;
}

/**
 * Mail handling function
 */
function sf_donation_mail($key, &$message, $params) {
	switch($key) {
		case 'single_donation_failure':
			$message['subject'] = t("Single donation export failure");
			break;
			
		case 'recurring_donation_failure':
			$message['subject'] = t("Recurring donation export failure");
			break;
			
		case 'recurring_donation_update_failure':
			$message['subject'] = t("Recurring donation update failure");
			break;
		
		case 'recurring_donation_payment_failure':
			$message['subject'] = t("Recurring donation payment failure");
			break;
	}
	$message['body'][] = t("Order !order_id has failed to export to Salesforce.\n", array('!order_id' => $params['order_id']));
	$message['body'][] = t("API Error\n\n!errors", array('!errors' => $params['errors']));
	$message['body'][] = t("Failed Object\n\n!object", array('!object' => $params['donation']));
}

/**
 * Returns an array of predefined mapped fields so that they do not show up twice in the mapping list.
 */
function _get_mapping_config() {
	$fields = array(
		'predefined' => array(
			'card_number' => 'CC_Last_4__c',
			'card_expiration_date' => 'CC_Exp_Month__c',
			'amount' => 'Amount',
			'billing_address' => 'Billing_Street__c',
			'billing_address_2' => 'Billing_Street_Line_2__c',
			'billing_city' => 'Billing_City__c',
			'billing_country' => 'Billing_Country__c',
			'billing_state' => 'Billing_State__c',
			'billing_zipcode' => 'Billing_Zip__c',
			'recurs_monthly' => 'NOT MAPPED',
			'card_cvv' => 'NOT MAPPED',
			'other_amount' => 'NOT MAPPED',
      'first_name' => 'NOT MAPPED',
      'last_name' => 'NOT MAPPED',
      'email' => 'NOT MAPPED'
		),
	);
	return $fields;
}

/**
 * Returns information aboue all installed donation integrators.
 */
function _donation_integration_list() {
  $integrators = module_invoke_all('donation_integration');
  return $integrators;
}

/**
 * Returns the currently configured donation integrator.
 */
function _current_donation_integrator() {
  $integrators = _donation_integration_list();
  $current_integrator = variable_get('sf_donation_backend', 'npsp');
  // find the currently selected integrator and return it
  foreach ($integrators as $integrator) {
    if ($integrator['id'] == $current_integrator) {
      return $integrator;
    }
  }
  
  return NULL;
}