<?php

/**
 * @file
 * Integrates webform submissions with the Salesforce API.
 */

/**
 * Implementation of hook_menu().
 */
function sf_donation_menu() {
  $items['node/%webform_menu/webform/salesforce-donation-mapping'] = array(
    'title' => 'Donation map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sf_donation_mapping_form', 1),
    'access callback' => 'fundraiser_mapping_form_access',
    'access arguments' => array(1),
    'weight' => 35,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/store/orders/%uc_order/export'] = array(
    'title' => t('Export to Salesforce'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sf_donation_export_confirm_form'),
    'access callback' => 'sf_donation_check_order_export_status',
    'access arguments' => array(3),
    'weight' => 20,
    'type' => MENU_LOCAL_TASK,
  );

  $items['fix_one_offs'] = array(
    'title' => 'Fix one off donation errors',
    'page callback' => 'fix_one_off_errors',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implmentation of hook_fundraiser_form_insert().
 */
function sf_donation_fundraiser_form_insert($node, $components) {
  require_once 'donation.php';
  $integrator = _sf_donation_current_donation_integrator();
  $default_map = DonationMapper::GetDefaultMap($integrator['id']);
  if (is_array($default_map)) {
    $default_map = array_flip(DonationMapper::GetDefaultMap($integrator['id']));
  }
  $single = variable_get('sf_donation_default_single_donation_recordtype', '');
  $recurring = variable_get('sf_donation_default_recurring_donation_recordtype', '');
  
	// insert the default map record
	db_query("INSERT INTO {fundraiser_salesforce_map} (nid, single_recordtype_id, recurring_recordtype_id, fields, salesforce) VALUES
	 (%d, '%s', '%s', '%s', '%s')", $node->nid, $single, $recurring, serialize($default_map), $integrator['donation_object']['type']);
	
  drupal_set_message("Salesforce donation fields have been mapped. Use the Donation map tab to edit the map.");
}

/**
 * Function to check whether or not an order has been exported to salesforce
 */
function sf_donation_check_order_export_status($order) {
	$sfid = db_result(db_query("SELECT sfid FROM {fundraiser_webform_order} WHERE order_id = %d UNION
		SELECT sf_opportunity_id AS sfid FROM {fundraiser_recurring} WHERE order_id = %d", $order->order_id, $order->order_id));

	if (!empty($sfid)) {
		return TRUE;
	}
	
	return FALSE;
}

/**
 * Confirmation form for manually exporting order to salesforce
 */
function sf_donation_export_confirm_form() {
	$order_id = arg(3);
	// get the user
	$user = db_fetch_object(db_query("SELECT billing_first_name, billing_last_name FROM {uc_orders} WHERE order_id = %d", $order_id));
	$donations = sf_donation_get_orders_for_export($order_id);
	
	// get recurring donations for close dates
	$result = db_query("SELECT order_id, next_charge FROM {fundraiser_recurring} WHERE master_order_id = %d", $order_id);
	while ($data = db_fetch_object($result)) {
		$close_dates[$data->order_id] = date('m-d-Y', $data->next_charge);
	}
	
	$output = '<h3>Donations</h3>';
	$header = array('Order ID', 'Salesforce ID', 'Donor Name', 'Amount', 'Close Date', 'Transaction Date');
	$rows = array();
	
	foreach ($donations as $key => $donation) {
		$rows[] = array(
			$donation['fields']['Order_ID__c'],
			$donation['fields']['Id'],
			$user->billing_first_name . ' ' . $user->billing_last_name,
			$donation['fields']['Amount'],
			$donation['fields']['CloseDate'] ? date('m-d-Y', strtotime($donation['fields']['CloseDate'])) : $close_dates[$donation['fields']['Order_ID__c']],
			$donation['fields']['Transaction_Date_Time__c'] ? date('m-d-Y h:i A', strtotime($donation['fields']['Transaction_Date_Time__c'])) : 'N/A',
		);
	}
	
	$output .= theme('table', $header, $rows);
	
	$form['order_id'] = array(
		'#type' => 'hidden',
		'#value' => $order_id,
	);
	return confirm_form($form, "Are you sure you want to re-export order $order_id to Salesforce?", 'admin/store/orders/'. $order_id, $output . "<p>Any values that have been changed in Salesforce will be overwritten.</p>", $yes = "Export", $no = "Cancel", $name = 'confirm');
}

/**
 * Logic to manually export an order to Salesforce
 */
function sf_donation_export_confirm_form_submit($form, &$form_state) {
	
	// get the webform submission id for mapped fields
	$order_id = $form_state['values']['order_id'];
	$donations = sf_donation_get_orders_for_export($order_id);
	
	// pop off the actual objects
	$donations_to_update = array();
	foreach ($donations as $value) {
		$donations_to_update[] = $value['fields'];
	}
	
	$sf = salesforce_management_api_connect();
	// only continue if we got a valid connection
	if ($sf) {
		$results = $sf->client->update($donations_to_update, 'Opportunity');
	}
	
	$failure_count = 0;
	$success_count = 0;
	$count = count($donations);
	
	// deal with salesforce's inconsistent returns
	if (!is_array($results)) {
		$temp = $results;
		$results = array();
		$results[] = $temp;
	}
	
	for ($i = 0; $i < $count; $i++) {
		if (!$results[$i]->success) {
			watchdog('salesforce', t('Order !order_id failed to update in Salesforce. Error: !error', array('!order_id' => $donations[$i]['order_id'], '!error' => print_r($results[$i]->error, true))), NULL, WATCHDOG_ERROR);
			$failure_count++;
		}
		else {
			$success_count++;
			uc_order_comment_save($donations[$i]['order_id'], 0, 'Order manually exported to Salesforce.', 'admin'); 
		}
	}
	
	drupal_set_message($success_count . ' orders successfully updated in Salesforce. ' . $failure_count . ' failed.');
	$form_state['redirect'] = 'admin/store/orders/' . $order_id;
}

/**
 * 
 * @param $order_id
 * Int
 * 
 * @return 
 * Array
 */
function sf_donation_get_orders_for_export($order_id) {

  // only allow export en-mass (e.g., don't allow a single donation in a series, instead, get the whole series)
  $count = db_result(db_query("SELECT count(order_id) FROM {fundraiser_webform_order} WHERE order_id = %d", $order_id));
  if ($count == 0) {
    $order_id = db_result(db_query("SELECT master_order_id FROM {fundraiser_recurring} WHERE order_id = %d", $order_id));
  }

  $result = db_query("SELECT f.sid, f.sfid, u.uid FROM {fundraiser_webform_order} f INNER JOIN 
    {uc_orders} u on u.order_id = f.order_id WHERE f.order_id = %d", $order_id);

  while ($data = db_fetch_object($result)) {
    $sid = $data->sid;
    $uid = $data->uid;
    $sfid = $data->sfid;
  }

  $order_ids_to_export[] = array(
    'order_id' => $order_id,
    'sfid' => $sfid,
  );

  // see if it is a recurring donation
  $result = db_query("SELECT order_id, sf_opportunity_id FROM {fundraiser_recurring} WHERE master_order_id = %d", $order_id);

  while ($data = db_fetch_object($result)) {
    $order_ids_to_export[] = array(
      'order_id' => $data->order_id,
      'sfid' => $data->sf_opportunity_id,
    );
  }

  $donations = array();

  if ($sid) {
    // load the user
    $user = user_load($uid);
    foreach($order_ids_to_export as $key => $value) {			
      $donation = _sf_donation_create_single_donation($value['order_id'], $user, $sid);
      // remove the name because we don't want to overwrite what was set orginally
      unset($donation['fields']['Name']);
      $donation['order_id'] = $value['order_id'];
      $donation['fields']['Id'] = $value['sfid'];
      $donations[] = $donation;
    }
  }

  return $donations;
}

/**
 * Implementation of hook_theme().
 */
function sf_donation_theme() {
	return array(
		'sf_donation_mapping_form' => array(
		'arguments' => array(),
	)
	);
}

/**
 * Form for mapping webform component fields to a Salesforce object.
 * Used for the "Donation map" local task tab when editing the Webform settings 
 * on a Donation form
 */
function sf_donation_mapping_form($form_state, $node) {

	$form = array(
    '#tree' => TRUE,
    '#node' => $node,
    'mapping' => array(),
  );

  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  
  // Determine the current donation integrator (NPSP or Common Ground)
  // Returns the array of info that the integrator module returns in its
  // implementation of hook_donation_integration().
  $integrator = _sf_donation_current_donation_integrator();
  
  // Get the integrator object type for donations
  // For Salesforce NPSP and Common Ground, this is 'Opportunity'
  $type = $integrator['donation_object']['type'];

  $sf = salesforce_management_api_connect();

  // Connect to Salesforce and get info on the object type
  if (is_object($sf) && method_exists($sf->client, 'describeSObject')) {
    $donation = $sf->client->describeSObject($type);
  }

  // Calling methods on non-object variables is bad.
  if (is_object($donation)) {
    // Build an array of record types, with the format typeID => typeName
    // The recordTypeInfos array will include things like Donation, Grant, Major 
    // Gift, Matching Donation
    foreach($donation->recordTypeInfos as $record_type) {
      if ($record_type->available && $record_type->name != 'Master') {
        $record_types[$record_type->recordTypeId] = $record_type->name;
      }
    }
  }

  $record_types[] = '--Select One--';
  asort($record_types);

  $form['user_mappings'] = array(
    '#value' => t('<h3>Donation Mappings</h3><div>Use this form to map fields to the <strong>@type</strong> object in Salesforce. The current donation storage system is <strong>@integrator</strong>.</div>', array('@type' => $type, '@integrator' => $integrator['name'])),
    '#weight' => -1,
  );

  $form['single_record_type'] = array(
    '#type' => 'select',
    '#title' => 'Single donation record type',
    '#description' => t('The type of @type to create when a single donation is exported to Salesforce.', array('@type' => $type)),
    '#options' => $record_types,
    '#default_value' => $node->single_recordtype_id,
  );

  $form['recurring_record_type'] = array(
    '#type' => 'select',
    '#title' => 'Recurring donation record type',
    '#description' => t('The type of @type to create when a recurring donation is exported to Salesforce.', array('@type' => $type)),
    '#options' => $record_types,
    '#default_value' => $node->recurring_recordtype_id,
  );

  // Build a simple array of the fields available in the SF object
  $donation_fields = array('' => '--Select One--');
    if (is_array($donation->fields)) {
    foreach($donation->fields as $field) {
      $donation_fields[$field->name] = $field->label;
    }
  }

  // sort the fields alphabetically
  asort($donation_fields);

  $node = $form['#node'];

  require_once 'donation.php';
	
	// Get a list of built-in Donation form fields that can be mapped to SF fields
	$properties = Donation::get_mappable_properties();
	asort($properties);

	// For each Donation form field, show a dropdown of all SF fields
	foreach($properties as $key => $value) {
    $form['mapping']['donation'][$key] = array(
      '#type' => 'item',
      '#description' => $value,
    );
    $form['mapping']['salesforce'][$key] = array(
      '#type' => 'select',
      '#options' => $donation_fields,
      '#default_value' => $node->salesforce_map[$key],
    );
	}
	
	// Get pre-defined field mappings
	$mapping_config = _sf_donation_get_mapping_config();
	
	// Add mapping dropdowns for the 'special' donation form fields, like Market
	// Source, Campaign ID, and Referrers
	foreach($node->webform['components'] as $cid => $component) {
		if($component['type'] != 'fieldset' && !array_key_exists($component['form_key'], $mapping_config['predefined'])) {
			// Webform component
			$form['mapping']['component'][$component['form_key']] = array(
			'#type' => 'item',
			'#description' => t($component['name']." - (".$component['type'].")"),
			);
			// SF object field
			$form['mapping']['salesforce'][$component['form_key']] = array(
				'#type' => 'select',
				'#options' => $donation_fields,
				'#default_value' => $node->salesforce_map[$component['form_key']],
			);
		}
	}
	
	$form['submit'] = array('#type' => 'submit', '#value' => t('Save'));

	return $form;
}


/*
 * Save the SF donation field mapping for a Donation form
 */
function sf_donation_mapping_form_submit($form, &$form_state) {
	// Determine the current donation integrator (NPSP or Common Ground)
  // Returns the array of info that the integrator module returns in its
  // implementation of hook_donation_integration().
  $integrator = _sf_donation_current_donation_integrator();
	$nid = $form['#node']->nid;
	
	// Remove old Salesforce mappings
	db_query("DELETE FROM {fundraiser_salesforce_map} WHERE nid = %d", $nid);
	
	// Re-create mappings
	foreach($form_state['values']['mapping']['salesforce'] as $key => $value) {
		if (!empty($value)) {
		  $map[$value] = $key;
		}
	}
	
	// Determine the SF object type for this integrator
	$salesforce_type = $integrator['donation_object']['type'];
	
	// Look for the donation record types from the dropdowns in the form
	$single_recordtype_id = $form_state['values']['single_record_type'];
	$recurring_recordtype_id = $form_state['values']['recurring_record_type']; 
	
	// Save the mapping
	db_query("INSERT INTO {fundraiser_salesforce_map} (nid, single_recordtype_id, recurring_recordtype_id, fields, salesforce) VALUES
	 (%d, '%s', '%s', '%s', '%s')", $nid, $single_recordtype_id, $recurring_recordtype_id, serialize($map), $salesforce_type);

	drupal_set_message(t('Salesforce mapping has been saved'));
}

/**
 * Implementation of hook_perm().
 */
function sf_donation_perm() {
  return array('sync donations with salesforce');
}

/**
 * Clones a salesforce donation map
 */
function sf_donation_clone_map($nid, $new_nid) {
	// get profile map for the original donation form
	$result = db_fetch_array(db_query("SELECT nid, single_recordtype_id, recurring_recordtype_id, fields, salesforce FROM {fundraiser_salesforce_map} WHERE nid = %d", $nid));
	
	db_query(
	"
	 INSERT INTO {fundraiser_salesforce_map} 
	 (nid, single_recordtype_id, recurring_recordtype_id, fields, salesforce)
	 VALUES
	 (%d, '%s', '%s', '%s', '%s')
  ",
  $new_nid, $result['single_recordtype_id'], $result['recurring_recordtype_id'], $result['fields'], $result['salesforce']
  );
}

/**
 * Implementaion of hook_nodeapi().
 */
function sf_donation_nodeapi(&$node, $op, $teaser, $page) {
  if ($node->type == 'donation_form') {
  switch ($op) {
    case 'load':
      $result = db_query("SELECT single_recordtype_id, recurring_recordtype_id, fields FROM {fundraiser_salesforce_map} WHERE nid = %d", $node->nid);
      while($row = db_fetch_object($result)) {
        $fields = unserialize($row->fields);
        if (is_array($fields)) {
          foreach($fields as $k => $v) {
            $map['salesforce_map'][$v] = $k;  
          }
        }
        $map['single_recordtype_id'] = $row->single_recordtype_id;			   
        $map['recurring_recordtype_id'] = $row->recurring_recordtype_id;
      }
	  return $map;
      break;
      
    case 'delete':
       db_query("DELETE FROM {fundraiser_salesforce_map} WHERE nid = %d", $node->nid);
      break;
    }
  }
}

/**
 * Implementation of hook_sf_donation().
 */
function sf_donation_sf_donation($op, $order_id, $sfid, $message) {
  $aids = _trigger_get_hook_aids('sf_donation', $op);
  $context = array(
    'hook' => 'sf_donation',
    'op' => $op,
    'order_id' => $order_id,
		'sfid' => $sfid,
		'message' => $message,
  );
	$dummy = new stdClass();
  actions_do(array_keys($aids), $dummy, $context, $order_id, $sfid, $message);
}

/**
 * Implemenation of hook_menu_alter().
 */
function sf_donation_menu_alter(&$items) {
	// not sure why this is needed, but the custom trigger was not showing up without it
	$items['admin/build/trigger/sf_donation']['access callback'] = TRUE;
}

/**
 * Implementation of hook_form_alter().
 */
function sf_donation_form_alter(&$form, $form_state, $form_id) {
  switch($form_id) {
    case 'webform_component_edit_form':
      if ($form['form_key']['#default_value'] == 'cid') {
        // turn it into a select field
        // get campaigns from salesforce
        $campaigns = _sf_donation_get_campaigns();
        if (!empty($campaigns)) {
          $campaigns = array('' => '-- Select --')+$campaigns;
          $form['value']['#type'] = 'select';
          $form['value']['#options'] = $campaigns;
        }
      }
      break;

    case 'salesforce_management_api_settings_form':
      // get campaigns from salesforce
      $campaigns = _sf_donation_get_campaigns();
      $integrator = _sf_donation_current_donation_integrator();
      if (empty($integrator)) {
        drupal_set_message('The <strong>Salesforce Donation Application</strong> has not been set. Some options in the Donation integration section will not be available until one has been selected.');
      }
      $type = $integrator['donation_object']['type'];
      array_unshift($campaigns, '-- Please select --');

      $form['sf_donation'] = array(
        '#type' => 'fieldset',
        '#title' => t('Donation integration'),
        '#description' => t('Fundraiser module integration settings.'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#weight' => -1,
      );

      $form['sf_donation']['sf_donation_debug'] = array(
        '#type' => 'checkbox',
        '#title' => t('Debug mode'),
        '#description' => t('Log detailed information about each API call.'),
        '#default_value' => variable_get('sf_donation_debug', 0),
      );

      $form['sf_donation']['sf_donation_default_campaign'] = array(
        '#type' => 'select',
        '#title' => t('Default campaign'),
        '#description' => t('The default campaign to which donations will be assigned.'),
        '#options' => $campaigns,
        '#default_value' => variable_get('sf_donation_default_campaign', ''),
      );

      // get a list of installed donation integration modules
      $integrators = _sf_donation_integration_list();
      $options = array();
      foreach ($integrators as $integrator) {
        $options[$integrator['id']] = $integrator['name'];
      }

      if (count($options) == 0) {
        $message = t('There are no donation integration modules enabled. Donations will not be exported until one is enabled');
        drupal_set_message($message);
        watchdog('salesforce donation', $message, NULL, WATCHDOG_INFO);
      }

      $form['sf_donation']['sf_donation_backend'] = array(
        '#type' => 'select',
        '#title' => t('Salesforce Donation Application'),
        '#description' => t('The application Salesforce is using to process donations.'),
        '#options' => $options,
        '#default_value' => variable_get('sf_donation_backend', 'npsp'),
      );

      $type = $integrator['donation_object']['type'];
      $record_types = salesforce_management_api_get_object_recordtypes($type);
      // default single donation record type
      $form['sf_donation']['sf_donation_default_single_donation_recordtype'] = array(
        '#type' => 'select',
        '#title' => t('Default single donation record type'),
        '#description' => t('The default record type to use for single donations when auto-mapping a new donation form.'),
        '#options' => $record_types,
        '#default_value' => variable_get('sf_donation_default_single_donation_recordtype', ''),
      );

      // default recurring donation record type
      $form['sf_donation']['sf_donation_default_recurring_donation_recordtype'] = array(
        '#type' => 'select',
        '#title' => t('Default recurring donation record type'),
        '#description' => t('The default record type to use for recurring donations when auto-mapping a new donation form.'),
        '#options' => $record_types,
        '#default_value' => variable_get('sf_donation_default_recurring_donation_recordtype', ''),
      );

			break;
	}
}

/**
 * Implementation of hook_hook_info(). 
 */
function sf_donation_hook_info() {
	return array(
		'sf_donation' => array(
			'sf_donation' => array(
				'fails' => array(
					'runs when' => t('When a salesforce donation synchronization fails'),
				),
			),
		),
	);
}

/**
 * Implemenation of hook_queue_salesforce_info().
 */
function sf_donation_queue_salesforce_info($type, $action) {

	// since donations do not use fieldmaps in a traditional sense, we manually assign their Salesforce types here
	$integrator = _sf_donation_current_donation_integrator();
	
	switch ($type) {
		
		case FUNDRAISER_SINGLE_DONATION_TYPE:
			
			$data = array(
				'salesforce' => $integrator['donation_object']['type'],
				'dedupe_key' => $integrator['donation_object']['dedupe_key'],
			);
			break;
			
    case FUNDRAISER_RECURRING_DONATION_TYPE:
      $data = array(
        'salesforce' => $integrator['recurring_donation_object']['type'],
        'dedupe_key' => $integrator['recurring_donation_object']['dedupe_key'],
      );
      break;
    
    case FUNDRAISER_DONATION_REFUND_TYPE:
      // For refunds, use the same object as donations
      $data = array(
        'salesforce' => $integrator['donation_object']['type'],
        'dedupe_key' => '',
      );
      break;
    
	}
	
	return $data;
	
}


/**
 * Implementation of queue_preprocess_batch_alter().
 */
function sf_donation_queue_preprocess_batch_alter(&$batch) {

	if (in_array($batch['type'], array(FUNDRAISER_SINGLE_DONATION_TYPE, FUNDRAISER_RECURRING_DONATION_TYPE, FUNDRAISER_DONATION_REFUND_TYPE))) {
		foreach ($batch['records'] as $record) {
		  // If it's a refund, load the order ID from the refund record
		  if ($batch['type'] == FUNDRAISER_DONATION_REFUND_TYPE) {
		    $refund = db_fetch_object(db_query('SELECT * FROM {fundraiser_refund} WHERE refund_id = %d', array($record->oid)));
		    $order_id = $refund->order_id;
		  }
		  else {
		    $order_id = $record->oid;
		  }
		  		  
			// get additional details about the order
			$details = db_fetch_object(db_query("SELECT f.sid, u.uid FROM {uc_orders} u INNER JOIN {fundraiser_webform_order} f ON f.order_id = u.order_id WHERE u.order_id = %d", $order_id));
		
			// if empty, then the donation was part of a recurring series
			if (empty($details)) {
				$details = db_fetch_object(db_query("SELECT f.sid, u.uid FROM {uc_orders} u INNER JOIN {fundraiser_recurring} fr ON fr.order_id = u.order_id INNER JOIN
					{fundraiser_webform_order} f on f.order_id = fr.master_order_id WHERE u.order_id = %d", $order_id));
			}
			
			$user_ids = _sf_donation_load_user_salesforce_ids($details->uid);
			
			switch ($batch['type']) {
				case FUNDRAISER_SINGLE_DONATION_TYPE:
					$object = _sf_donation_create_single_donation($order_id, $user_ids->salesforce_account_id, $details->sid);
					if ($batch['action'] == 'update' && !empty($record->sfid)) {
						$object['Id'] = $record->sfid;
					}
					$record->object = $object;
					break;
					
				case FUNDRAISER_RECURRING_DONATION_TYPE:
					$donation_count = _sf_donation_recurring_donation_count($order_id, $user);
					$donation_count++; // account for original order
					$object = _sf_donation_create_recurring_donation($order_id, $user_ids, $donation_count);
					if ($batch['action'] == 'update' && !empty($record->sfid)) {
						$object['Id'] = $record->sfid;
					}
					$record->object = $object;
					break;
				
				case FUNDRAISER_DONATION_REFUND_TYPE:
				  // Get a regular Donation opportunity object
					$object = _sf_donation_create_single_donation($order_id, $user_ids->salesforce_account_id, $details->sid);
					if ($batch['action'] == 'update' && !empty($record->sfid)) {
						$object['Id'] = $record->sfid;
					}
					
					// Set refund-specific values
					$object['Amount'] = abs($refund->amount) * -1;
					$object['StageName'] = 'Refunded'; 
					$object['Cancellation_Reason__c'] = $refund->reason; 
					
					// Get the date/time of the refund
					$transaction_date = db_result(db_query("SELECT received FROM {uc_payment_receipts} WHERE receipt_id = %d", $refund->receipt_id));
					$object['Transaction_Date_Time__c'] = gmdate('c', $transaction_date);
					
					// Link the refund to the original donation
					$donation_sfid = db_result(db_query('SELECT sfid FROM {fundraiser_webform_order} WHERE order_id = %d', array($order_id)));
					$object['Parent_Donation__c'] = $donation_sfid;
					
					// Since it's a refund, the probability is 0
					$object['Probability'] = 0;

					$record->object = $object;
					break;
			
			}
		}
	}
}

/**
 * Implemenation of hook_queue_postprocess_batch().
 */
function sf_donation_queue_postprocess_batch($batch, $responses, $item_count) {
	
	switch ($batch['type']) {
		case FUNDRAISER_SINGLE_DONATION_TYPE:
		case FUNDRAISER_DONATION_REFUND_TYPE:
			if ($batch['action'] == create) {
				// determine integrator
	      $integrator = _sf_donation_current_donation_integrator();
	      $function = $integrator['donation_object']['postprocess'];
	      $function($batch, $responses, $item_count);
			}
			break;
			
		case FUNDRAISER_RECURRING_DONATION_TYPE:

      // determine integrator
      $integrator = _sf_donation_current_donation_integrator();
      $function = $integrator['recurring_donation_object']['postprocess'];
      $function($batch, $responses, $item_count);
			
			break;	
	}
	
}

/**
 * Exports opportunity contact role objects to Salesforce
 */
function sf_donation_export_opportunity_contact_roles() {

	$sf = salesforce_management_api_connect();
	// only continue if we got a valid connection
	if ($sf) {	
		
		// get all un-exported records
		$result = db_query("SELECT contact_id, opportunity_id, role FROM {sf_donation_opportunity_contact_role} WHERE exported = %d", 0);
		$contact_roles = array();
		while ($data = db_fetch_object($result)) {
			// create the object
			$contact_roles[] = array(
				'ContactId' => $data->contact_id,
				'OpportunityId' => $data->opportunity_id,
				'Role' => $data->role,
			);
		}
	
		// divide them up if we've got more than 200
		$pieces = ceil(count($contact_roles) / 200);
		$batches = _sf_donation_array_split($contact_roles, $pieces);
		
		foreach($batches as $batch) {
			$response = _normalize_salesforce_response($sf->client->create($batch, 'OpportunityContactRole'));

			// Process responses
			$items_in_batch = count($batch);
			for ($i = 0; $i < $items_in_batch; $i++) {
				if ($response[$i]->success) {
					db_query("UPDATE {sf_donation_opportunity_contact_role} SET exported = %d WHERE contact_id = '%s' AND opportunity_id = '%s'", 1, $batch[$i]['ContactId'], $batch[$i]['OpportunityId']);
				}
				else {
					watchdog('salesforce donation', t('Unable to create opportunity contact roles for opportunity !id.', array('!id' => $batch[$i]['OpportunityId'])), NULL, WATCHDOG_CRITICAL);		
				}
			}
		}
	}
	else {
		watchdog('salesforce donation', t('Could not connect to Salesforce. Opportunity Contact Roles were not created at this time. They have been saved and will be exported with the next donation.'), NULL, WATCHDOG_CRITICAL);
	}

}


/**
 * Returns the salesforce ids of a given user (prevents having to call node_load())
 */
function _sf_donation_load_user_salesforce_ids($uid) {
	$result = db_query("SELECT 
		CASE WHEN instr(u.data, 'salesforce_account_id') THEN substring(u.data, instr(u.data, 'salesforce_account_id')+29, 18)
		ELSE NULL
		END AS salesforce_account_id,
		CASE WHEN instr(u.data, 'salesforce_contact_id') THEN substring(u.data, instr(u.data, 'salesforce_contact_id')+29, 18)
		ELSE NULL
		END AS salesforce_contact_id 
		FROM {users} u 
		WHERE u.uid = %d", $uid);
		
	return db_fetch_object($result);	
}

/**
 * Uses an order id to look up the user's Salesforce ids.
 */
function _sf_donation_load_user_salesforce_ids_from_order($order_id) {
	$result = db_query("SELECT 
		CASE WHEN instr(u.data, 'salesforce_account_id') THEN substring(u.data, instr(u.data, 'salesforce_account_id')+29, 18)
		ELSE NULL
		END AS salesforce_account_id,
		CASE WHEN instr(u.data, 'salesforce_contact_id') THEN substring(u.data, instr(u.data, 'salesforce_contact_id')+29, 18)
		ELSE NULL
		END AS salesforce_contact_id 
		FROM {users} u INNER JOIN
		{uc_orders} o ON o.uid = u.uid WHERE o.order_id = %d", $order_id);
		
	return db_fetch_object($result);
}

/**
 * Creates an array that represents a salesforce opportunity object
 * 
 * @param $order_id
 * Int
 * 
 * @param $account_id
 * Int
 * 
 * @param $sid
 * Int
 * 
 * @return
 * 
 */
function _sf_donation_create_single_donation($order_id, $account_id, $sid) {
  $integrator = _sf_donation_current_donation_integrator();
  $function = $integrator['donation_object']['create'];
  return $function($order_id, $account_id, $sid);
}

/*
 * Creates an array that represents a salesforce recurring donation object
 */
function _sf_donation_create_recurring_donation($order_id, $user_ids, $count) {
	$order = uc_order_load($order_id);

	// determine integrator
	$integrator = _sf_donation_current_donation_integrator();
  $function = $integrator['recurring_donation_object']['create'];
  $donation = $function($order, $user_ids, $count);
	
  // clear the credit card cache
	uc_credit_cache('clear');
	return $donation;
}

/* 
 * Updates an opportunity when a donation payment processes.
 */
function sf_donation_update_donation_status($order_id) {
	// get the sfid from the recurring orders table
	$sfid = db_result(db_query("SELECT sf_opportunity_id FROM {fundraiser_recurring} WHERE order_id = %d", $order_id));
	if ($sfid) {
		// get order payment so we can get the transaction date
		$payments = uc_payment_load_payments($order_id);
		// deal with sf date handling
		$transaction_date = strtotime(date('H:i:s d-M-Y T', $payments[0]->received));
		
		$opportunity = array(
			'Id' => $sfid,
			'Transaction_Date_Time__c' => gmdate('c', $transaction_date),
			'Probability' => 100.00,
			'StageName' => 'Posted',
		);
		
		$sf = salesforce_management_api_connect();
		$results = $sf->client->update(array($opportunity), 'Opportunity');
		
		if (!$results->success) {
			// Log failure
			watchdog('error', "Opportunity $sfid was not updated in salesforce after a recurring payment was processed. Errors: $results->errors");
			// Trigger failure
			//module_invoke_all('sf_donation', 'fails', $order_id, $sfid, "Opportunity $sfid was not updated in salesforce after a recurring payment was processed. Errors: $results->errors");
			$params = array(
				'order_id' => $order_id,
				'errors' => $results->errors,
				'donation' => print_r($opportunity, true),
			);
			drupal_mail('sf_donation', 'recurring_donation_payment_failure', 'phillip.cave@jacksonriver.com,tom.williamson@jacksonriver.com,tj.griffin@jacksonriver.com', language_default(), $params);
		}
		else {
			watchdog('salesforce', t('Opportunity !sfid updated to stage Posted at !time. Order Id is !order_id', array('!sfid'=>$sfid, '!time'=>gmdate('c', $transaction_date), '!order_id'=>$order_id)), NULL, WATCHDOG_INFO);
		}
	}
} 

/**
 * Updates the donation amount of recurring orders
 */
function sf_donation_update_donation_amount($order_ids, $amount) {
	// get all of the recurring donations that have not been processed
	$sql = "select sf_opportunity_id from {fundraiser_recurring} where order_id in (%s)";
	$results = db_query($sql, implode(",", $order_ids));
	
	$donations = array();
	
	while ($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'Amount' => $amount,
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			$errors = print_r($errors, TRUE);
			watchdog('error', "Donation amount for opportunity $sfid was not updated in salesforce. Errors: $errors");
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Donation amount for opportunity $sfid was not updated in salesforce. Errors: $errors");
		}
	}
}

/**
 * Updates an opportunity to cancelled.
 */
function sf_donation_canel_recurring_donations($order_id) {
	$sql = "select sf_opportunity_id, cancellation_reason from {fundraiser_recurring} where master_order_id = %d and gateway_resp = 'canceled'";
		
	$results = db_query($sql, $order_id);
	$donations = array();
	
	while ($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'StageName' => 'Withdrawn',
			'Cancellation_Reason__c' => $data->cancellation_reason,
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			watchdog('error', "Opportunity $sfid was not withdrawn in salesforce. Errors: " . print_r($errors, TRUE));
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Opportunity $sfid was not withdrawn in salesforce. Errors: " . print_r($errors, TRUE));
		}
	}
}

/*
 * Loads the donation -> salesforce map for this webform and populates it
 * with data from the actual webform submission
 */
function _sf_donation_load_salesforce_map($sid) {
	$map = array();
	
	$results = db_query(
	 "
	   SELECT f.map_id, c.form_key, s.data 
	   FROM {fundraiser_salesforce_map} f 
	   INNER JOIN {webform_component} c ON c.cid = f.cid AND c.nid = f.nid
		 INNER JOIN {webform_submitted_data} s ON s.cid = c.cid AND s.nid = c.nid 
		 WHERE s.sid = %d
	 ", 
	 $sid
	 );
	 
	while ($data = db_fetch_object($results)) {
		$map[$data->map_id] = $data->data;
	}	

	return $map;
}

/*
 * Gets the number of times a given donation recurs
 */
function _sf_donation_recurring_donation_count($order_id) {
	return db_result(db_query("select count(order_id) from {fundraiser_recurring} where master_order_id = %d", $order_id));
}

/*
 * Updates a webform created order with the id from salesforce
 * TODO: is this function still in use?
 */
function _sf_donation_update_webform_order($order_id, $sfid) {
	db_query("update {fundraiser_webform_order} set sfid = '%s' where order_id = %d", $sfid, $order_id);
}

/**
 * Theme the mapping form
 */
function theme_sf_donation_mapping_form($form) {
	$output = drupal_render($form['user_mappings']);
	$output .= drupal_render($form['single_record_type']);
	$output .= drupal_render($form['recurring_record_type']);

	$row = array();
	$row[] = 'Donation Properties';
	$row[] = '&nbsp;';
	$rows[] = $row;
	foreach ($form['mapping']['donation'] as $property=>$value) {
	  if (strpos($property, '#') === FALSE) {
      $row = array();
      $row[] = drupal_render($form['mapping']['donation'][$property]);
      $row[] = drupal_render($form['mapping']['salesforce'][$property]);
      $rows[] = $row;
		}
	}
	
	$row = array();
	$row[] = 'Webform Components';
	$row[] = '&nbsp;';
	$rows[] = $row;
	foreach ($form['mapping']['component'] as $key => $cid) {
		if (strpos($key, '#') === FALSE) {
			$row = array();
			$row[] = drupal_render($form['mapping']['component'][$key]);
			$row[] = drupal_render($form['mapping']['salesforce'][$key]);
			$rows[] = $row;
		}
	}
	
	$row = array();
	$row[] = drupal_render($form['submit']);
	$row[] = '&nbsp;';
	$rows[] = $row;

	$header = array("Drupal Field", "Opportunity Field");
	$output .= theme('table', $header, $rows, array('id' => 'sf_donation_mapping_form'));
	$output .= drupal_render($form);

	return $output;
}

/**
 * Get In Progress campaigns from Salesforce
 * Returns an array in the format campaignID => campaignName
 */
function _sf_donation_get_campaigns() {

	$sf = salesforce_management_api_connect();
	$campaigns = array();
	// only continue if we got a valid connection
	if (is_object($sf)) {
		$results = $sf->client->query("select Id, Name from Campaign where Status = 'In Progress'");
		if (count($results->records)) {
			foreach($results->records as $campaign) {
				$campaigns[$campaign->Id] = $campaign->Name;
			}
		}
	}
	return $campaigns;
}

/**
 * Mail handling function
 */
function sf_donation_mail($key, &$message, $params) {
	switch($key) {
		case 'single_donation_failure':
			$message['subject'] = t("Single donation export failure");
			break;
			
		case 'recurring_donation_failure':
			$message['subject'] = t("Recurring donation export failure");
			break;
			
		case 'recurring_donation_update_failure':
			$message['subject'] = t("Recurring donation update failure");
			break;
		
		case 'recurring_donation_payment_failure':
			$message['subject'] = t("Recurring donation payment failure");
			break;
	}
	$message['body'][] = t("Order !order_id has failed to export to Salesforce.\n", array('!order_id' => $params['order_id']));
	$message['body'][] = t("API Error\n\n!errors", array('!errors' => $params['errors']));
	$message['body'][] = t("Failed Object\n\n!object", array('!object' => $params['donation']));
}

/**
 * Returns an array of predefined mapped fields so that they do not show up twice 
 * in the mapping list.
 */
function _sf_donation_get_mapping_config() {
  $fields = array(
    'predefined' => array(
      'card_number' => 'CC_Last_4__c',
      'card_expiration_date' => 'CC_Exp_Month__c',
      'amount' => 'Amount',
      'address' => 'Billing_Street__c',
      'address_line_2' => 'Billing_Street_Line_2__c',
      'city' => 'Billing_City__c',
      'country' => 'Billing_Country__c',
      'state' => 'Billing_State__c',
      'zip' => 'Billing_Zip__c',
      'recurs_monthly' => 'NOT MAPPED',
      'card_cvv' => 'NOT MAPPED',
      'other_amount' => 'NOT MAPPED',
      'first_name' => 'NOT MAPPED',
      'last_name' => 'NOT MAPPED',
      'email' => 'NOT MAPPED',
      'card_expiration_month' => 'NOT MAPPED',
      'card_expiration_year' => 'NOT MAPPED',
    ),
  );
  return $fields;
}

/**
 * Returns information about all installed donation integrators.
 */
function _sf_donation_integration_list() {
  $integrators = module_invoke_all('donation_integration');
  return $integrators;
}

/**
 * Returns the currently configured donation integrator.
 */
function _sf_donation_current_donation_integrator() {
  $integrators = _sf_donation_integration_list();
  $current_integrator = variable_get('sf_donation_backend', 'npsp');
  // find the currently selected integrator and return it
  foreach ($integrators as $integrator) {
    if ($integrator['id'] == $current_integrator) {
      return $integrator;
    }
  }

  return NULL;
}

/**
 * Returns the SFID and close date of a recurring donation for an individual order
 */
function _sf_donation_get_recurring_details($order_id) {
  $recurring_info = array();
  
  $result = db_query(
    "
      SELECT f.next_charge, s.sfid 
      FROM {salesforce_management_object_map} s
      INNER JOIN {fundraiser_recurring} f ON f.master_order_id = s.oid
      WHERE f.order_id = %d AND s.drupal_type = 'recurring_donation'
    ",
    $order_id
  );
  
  while ($data = db_fetch_object($result)) {
    $recurring_info['close_date'] = $data->next_charge;
    $recurring_info['sfid'] = $data->sfid;
  }
  
  return $recurring_info;
}

/**
 * Splits an array into a specified number of new arrays
 */
function _sf_donation_array_split($array, $pieces = 2)
{  
	if ($pieces < 2) {
		return array($array);
	}
	
	$newCount = ceil(count($array)/$pieces);
	$a = array_slice($array, 0, $newCount);
	$b = _sf_donation_array_split(array_slice($array, $newCount), $pieces-1);
	return array_merge(array($a),$b);
} 
