<?php
// $Id: sf_donation.module,v 1.0.0.0 2009/08/14 06:44:28 pcave Exp $

/**
 * @file
 * Integrates webform submissions with the Salesforce API.
 */

/**
 * Implementation of hook_menu().
 */
function sf_donation_menu() {
	$items['node/%webform_menu/edit/salesforce-donation-mapping'] = array(
	    'title' => 'Salesforce Donation Mapping',
	    'page callback' => 'drupal_get_form',
	    'page arguments' => array('sf_donation_mapping_form', 1),
	    'access callback' => 'mapping_form_access',
	    'weight' => 35,
	    'type' => MENU_LOCAL_TASK,
	);

	$items['admin/store/orders/%uc_order/export'] = array(
		'title' => t('Export to Salesforce'),
		'page callback' => 'drupal_get_form',
		'page arguments' => array('sf_donation_export_confirm_form'),
		'access callback' => 'check_order_export_status',
		'access arguments' => array(3),
		'weight' => 20,
		'type' => MENU_LOCAL_TASK,
	);
	
	$items['fix_one_offs'] = array(
		'title' => 'Fix one off donation errors',
		'page callback' => 'fix_one_off_errors',
		'access callback' => TRUE,
		'type' => MENU_CALLBACK,
	);

	return $items;
}

/**
 * Function to check whether or not an order has been exported to salesforce
 */
function check_order_export_status($order) {
	$sfid = db_result(db_query("SELECT sfid FROM {fundraiser_webform_order} WHERE order_id = %d UNION
		SELECT sf_opportunity_id AS sfid FROM {fundraiser_recurring} WHERE order_id = %d", $order->order_id, $order->order_id));

	if (!empty($sfid)) {
		return TRUE;
	}
	
	return FALSE;
}



/**
 * Confirmation form for manually exporting order to salesforce
 */
function sf_donation_export_confirm_form() {
	$order_id = arg(3);
	// get the user
	$user = db_fetch_object(db_query("SELECT billing_first_name, billing_last_name FROM {uc_orders} WHERE order_id = %d", $order_id));
	$donations = get_orders_for_export($order_id);
	
	// get recurring donations for close dates
	$result = db_query("SELECT order_id, next_charge FROM {fundraiser_recurring} WHERE master_order_id = %d", $order_id);
	while ($data = db_fetch_object($result)) {
		$close_dates[$data->order_id] = date('m-d-Y', $data->next_charge);
	}
	
	$output = '<h3>Donations</h3>';
	$header = array('Order ID', 'Salesforce ID', 'Donor Name', 'Amount', 'Close Date', 'Transaction Date');
	$rows = array();
	
	foreach ($donations as $key => $donation) {
		$rows[] = array(
			$donation['fields']['Order_ID__c'],
			$donation['fields']['Id'],
			$user->billing_first_name . ' ' . $user->billing_last_name,
			$donation['fields']['Amount'],
			$donation['fields']['CloseDate'] ? date('m-d-Y', strtotime($donation['fields']['CloseDate'])) : $close_dates[$donation['fields']['Order_ID__c']],
			$donation['fields']['Transaction_Date_Time__c'] ? date('m-d-Y h:i A', strtotime($donation['fields']['Transaction_Date_Time__c'])) : 'N/A',
		);
	}
	
	$output .= theme('table', $header, $rows);
	
	$form['order_id'] = array(
		'#type' => 'hidden',
		'#value' => $order_id,
	);
	return confirm_form($form, "Are you sure you want to re-export order $order_id to Salesforce?", 'admin/store/orders/'. $order_id, $output . "<p>Any values that have been changed in Salesforce will be overwritten.</p>", $yes = "Export", $no = "Cancel", $name = 'confirm');
}

/**
 * Logic to manually export an order to Salesforce
 */
function sf_donation_export_confirm_form_submit($form, &$form_state) {
	
	// get the webform submission id for mapped fields
	$order_id = $form_state['values']['order_id'];
	$donations = get_orders_for_export($order_id);
	
	// pop off the actual objects
	$donations_to_update = array();
	foreach ($donations as $value) {
		$donations_to_update[] = $value['fields'];
	}
	
	$sf = salesforce_management_api_connect();
	// only continue if we got a valid connection
	if ($sf) {
		$results = $sf->client->update($donations_to_update, 'Opportunity');
	}
	
	$failure_count = 0;
	$success_count = 0;
	$count = count($donations);
	
	// deal with salesforce's inconsistent returns
	if (!is_array($results)) {
		$temp = $results;
		$results = array();
		$results[] = $temp;
	}
	
	for ($i = 0; $i < $count; $i++) {
		if (!$results[$i]->success) {
			watchdog('salesforce', t('Order !order_id failed to update in Salesforce. Error: !error', array('!order_id' => $donations[$i]['order_id'], '!error' => print_r($results[$i]->error, true))), NULL, WATCHDOG_ERROR);
			$failure_count++;
		}
		else {
			$success_count++;
			uc_order_comment_save($donations[$i]['order_id'], 0, 'Order manually exported to Salesforce.', 'admin'); 
		}
	}
	
	drupal_set_message($success_count . ' orders successfully updated in Salesforce. ' . $failure_count . ' failed.');
	$form_state['redirect'] = 'admin/store/orders/' . $order_id;
}

function get_orders_for_export($order_id) {
	
	// only allow export en-mass (e.g., don't allow a single donation in a series, instead, get the whole series)
	$count = db_result(db_query("SELECT count(order_id) FROM {fundraiser_webform_order} WHERE order_id = %d", $order_id));
	if ($count == 0) {
		$order_id = db_result(db_query("SELECT master_order_id FROM {fundraiser_recurring} WHERE order_id = %d", $order_id));
	}
	
	$result = db_query("SELECT f.sid, f.sfid, u.uid FROM {fundraiser_webform_order} f INNER JOIN 
		{uc_orders} u on u.order_id = f.order_id WHERE f.order_id = %d", $order_id);
	
	while ($data = db_fetch_object($result)) {
		$sid = $data->sid;
		$uid = $data->uid;
		$sfid = $data->sfid;
	}
	
	$order_ids_to_export[] = array(
		'order_id' => $order_id,
		'sfid' => $sfid,
	);
	
	// see if it is a recurring donation
	$result = db_query("SELECT order_id, sf_opportunity_id FROM {fundraiser_recurring} WHERE master_order_id = %d", $order_id);
	
	while ($data = db_fetch_object($result)) {
		$order_ids_to_export[] = array(
			'order_id' => $data->order_id,
			'sfid' => $data->sf_opportunity_id,
		);
	}

	$donations = array();
	
	if ($sid) {
		// load the user
		$user = user_load($uid);
		foreach($order_ids_to_export as $key => $value) {			
			$donation = _create_single_donation($value['order_id'], $user, $sid);
			// remove the name because we don't want to overwrite what was set orginally
			unset($donation['fields']['Name']);
			$donation['order_id'] = $value['order_id'];
			$donation['fields']['Id'] = $value['sfid'];
			$donations[] = $donation;
		}
	}

	return $donations;
}

/**
* Implementation of hook_theme().
*/
function sf_donation_theme() {
	return array(
		'sf_donation_mapping_form' => array(
		'arguments' => array(),
	)
	);
}

function sf_donation_mapping_form($form_state, $node) {
	$form = array(
    '#tree' => TRUE,
    '#node' => $node,
    'mapping' => array(),
  );

  $form['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );

	$sf = salesforce_management_api_connect();
	$donation = $sf->client->describeSObject("Opportunity");
	$donation_fields = array('' => '--Select One--');
	$mapping_config = _get_mapping_config();

	$output = '';
	foreach($mapping_config['predefined'] as $key => $value) {
		$output .= '<li>' . $key . ' = ' . $value . '</li>';
	}
	
	$form['predefined'] = array(
		'#prefix' => '<div id="sf_donation_predefined_mappings"><h3>Predefined Mappings</h3><div>The following fields will be mapped automatically.</div><ul>',
		'#value' => $output,
		'#suffix' => '</ul><div>',
	);
	
	$form['user_mappings'] = array(
		'#value' => '<h3>User Mappings</h3><div>Use this form to map additional fields to the opportunity object in salesforce.</div>',
		'#weight' => -1,
	);

	foreach($donation->fields as $field) {
		// exclude pre-mapped fields
		if (!in_array($field->name, $mapping_config['unmappable'])) {
			$donation_fields[$field->name] = $field->label;
		}
	}
	
	$node = $form['#node'];
	foreach($node->webform['components'] as $cid => $component) {
		if($component['type'] != 'fieldset' && !array_key_exists($component['form_key'], $mapping_config['predefined'])) {
			// component
			$form['mapping']['cid'][$cid] = array(
			'#type' => 'item',
			'#description' => t($component['name']." - (".$component['type'].")"),
			);
			// opportunity field
			$form['mapping']['salesforce'][$cid] = array(
				'#type' => 'select',
				'#options' => $donation_fields,
				'#default_value' => $node->salesforce_map[$cid],
			);
		}
	}
	
	$form['submit'] = array('#type' => 'submit', '#value' => t('Save'));

	return $form;
}

/**
 * Implementation of hook_perm().
 */
function sf_donation_perm() {
  return array('sync donations with salesforce');
}

/*
 * Saves salesforce donation map
 */
function sf_donation_mapping_form_submit($form, &$form_state) {
	// remove salesforce mappings
	$sql = "delete from {fundraiser_salesforce_map} where nid = %d";
	db_query($sql, $form['#node']->nid);
	// re-add mappings
	foreach($form_state['values']['mapping']['salesforce'] as $key => $value) {
		if (!empty($value)) {
			$sql = "insert into {fundraiser_salesforce_map} set nid = %d, cid = %d, map_id = '%s'";
			db_query($sql, $form['#node']->nid, $key, $value);
		}
	}
	drupal_set_message(t('Salesforce mapping has been saved'));
}

/**
 * Clones a salesforce donation map
 */
function sf_donation_clone_map($nid, $new_nid) {
	// get profile map for the original donation form
	$result = db_query("select f.nid, f.cid, f.map_id, c.form_key from {fundraiser_salesforce_map} f inner join
		{webform_component} c on c.cid = f.cid and c.nid = f.nid where f.nid = %d", $nid);
	
	// loop over mapped components and find new component in cloned donation form
	while ($data = db_fetch_object($result)) {
		$cid = db_result(db_query("SELECT cid FROM {webform_component} WHERE form_key = '%s' AND nid = %d", $data->form_key, $new_nid));
		if ($cid) {
			db_query("INSERT INTO {fundraiser_salesforce_map} (nid, cid, map_id) VALUES (%d, %d, '%s')", $new_nid, $cid, $data->map_id);
		}
	}
}

/**
 * Implementaion of hook_nodeapi().
 */
function sf_donation_nodeapi(&$node, $op, $teaser, $page) {
	if($node->type == 'webform') {
		$parts = explode("/",$_GET['q']);
		
		if($parts[0]=='node' && $parts[2]=='edit' && $parts[3] == 'salesforce-donation-mapping' && $op == 'load'){
			$result = db_query("select cid, map_id from {fundraiser_salesforce_map} where nid = %d", $node->nid);
			while($row = db_fetch_object($result)) {
				$map['salesforce_map'][$row->cid] = $row->map_id;
			}
			return $map;
		}
	}
}

/**
 * Implementation of hook_sf_donation().
 */
function sf_donation_sf_donation($op, $order_id, $sfid, $message) {
  $aids = _trigger_get_hook_aids('sf_donation', $op);
  $context = array(
    'hook' => 'sf_donation',
    'op' => $op,
    'order_id' => $order_id,
		'sfid' => $sfid,
		'message' => $message,
  );
	$dummy = new stdClass();
  actions_do(array_keys($aids), $dummy, $context, $order_id, $sfid, $message);
}

/**
 * Implemenation of hook_menu_alter().
 */
function sf_donation_menu_alter(&$items) {
	// not sure why this is needed, but the custom trigger was not showing up without it
	$items['admin/build/trigger/sf_donation']['access callback'] = TRUE;
}

/**
 * Implementation of hook_form_alter().
 */
function sf_donation_form_alter(&$form, $form_state, $form_id) {
	switch($form_id) {
		case 'webform_component_edit_form':
			if ($form['advanced']['form_key']['#default_value'] == 'cid') {
				// turn it into a select field
				// get campaigns from salesforce
				$campaigns = _get_campaigns();
				if (!empty($campaigns)) {
					$form['value']['#type'] = 'select';
					$form['value']['#options'] = $campaigns;
				}
			}
			break;
			
		case 'salesforce_management_api_settings_form':
			// get campaigns from salesforce
			$campaigns = _get_campaigns();
			array_unshift($campaigns, '-- Please select --');
			
			$form['sf_donation'] = array(
	      '#type' => 'fieldset',
	      '#title' => t('Donation integration'),
	      '#description' => t('Fundraiser module integration settings.'),
	      '#collapsible' => TRUE,
	      '#collapsed' => TRUE,
	      '#weight' => -1,
	    );

			$form['sf_donation']['sf_donation_debug'] = array(
				'#type' => 'checkbox',
				'#title' => t('Debug mode'),
				'#description' => t('Log detailed information about each API call.'),
				'#default_value' => variable_get('sf_donation_debug', 0),
			);

			$form['sf_donation']['sf_donation_default_campaign'] = array(
				'#type' => 'select',
				'#title' => t('Default campaign'),
				'#description' => t('The default campaign to which donations will be assigned.'),
				'#options' => $campaigns,
				'#default_value' => variable_get('sf_donation_default_campaign', ''),
			);


			break;
	}
}

/**
 * Implementation of hook_hook_info(). 
 */
function sf_donation_hook_info() {
	return array(
		'sf_donation' => array(
			'sf_donation' => array(
				'fails' => array(
					'runs when' => t('When a salesforce donation synchronization fails'),
				),
			),
		),
	);
}

/**
 * Implemenation of hook_queue_salesforce_info().
 */
function sf_donation_queue_salesforce_info($type, $action) {

	// since donations do not use fieldmaps in a traditional sense, we manually assign their Salesforce types here
	switch ($type) {
		
		case FUNDRAISER_SINGLE_DONATION_TYPE:
			
			$data = array(
				'salesforce' => 'Opportunity',
				'dedupe_key' => '',
			);
			break;
			
		case FUNDRAISER_RECURRING_DONATION_TYPE:
			$data = array(
				'salesforce' => 'npe03__Recurring_Donation__c',
				'dedupe_key' => '',
			);
			break;
		
	}
	
	return $data;
	
}


/**
 * Implementation of queue_preprocess_batch_alter().
 */
function sf_donation_queue_preprocess_batch_alter(&$batch) {

	if ($batch['type'] == 'donation' || $batch['type'] == 'recurring_donation') {
		foreach ($batch['records'] as $record) {
			// get additional details about the order
			$details = db_fetch_object(db_query("SELECT f.sid, u.uid FROM {uc_orders} u INNER JOIN {fundraiser_webform_order} f ON f.order_id = u.order_id WHERE u.order_id = %d", $record->oid));
		
			// if empty, then the donation was part of a recurring series
			if (empty($details)) {
				$details = db_fetch_object(db_query("SELECT f.sid, u.uid FROM {uc_orders} u INNER JOIN {fundraiser_recurring} fr ON fr.order_id = u.order_id INNER JOIN
					{fundraiser_webform_order} f on f.order_id = fr.master_order_id WHERE u.order_id = %d", $record->oid));
			}
			
			$user_ids = _sf_donation_load_user_salesforce_ids($details->uid);
			
			switch ($batch['type']) {
				case FUNDRAISER_SINGLE_DONATION_TYPE:
					$object = _create_single_donation($record->oid, $user_ids->salesforce_account_id, $details->sid);
					if ($batch['action'] == 'update' && !empty($record->sfid)) {
						$object['Id'] = $record->sfid;
					}
					$record->object = $object;
					break;
					
				case FUNDRAISER_RECURRING_DONATION_TYPE:
					$donation_count = _recurring_donation_count($record->oid, $user);
					$donation_count++; // account for original order
					$record->object = _create_recurring_donation($record->oid, $user_ids->salesforce_contact_id, $donation_count);
					break;
			}
		}
	}

}

/**
 * Implemenation of hook_queue_postprocess_batch().
 */
function sf_donation_queue_postprocess_batch($batch, $responses, $item_count) {
	
	switch ($batch['type']) {
		case FUNDRAISER_SINGLE_DONATION_TYPE:

			if ($batch['action'] == create) {
				
				for ($i = 0; $i < $item_count; $i++) {
					if ($responses[$i]->success) {	
						$sfid = $responses[$i]->id;
						db_query("UPDATE {fundraiser_webform_order} SET sfid = '%s' WHERE order_id = %d", $sfid, (int)$batch['records'][$i]->oid);
						$user_ids = _sf_donation_load_user_salesforce_ids_from_order((int)$batch['records'][$i]->oid);
						
						// the single order may be an extension to an existing recurring donation series, so try and update it there as well
						db_query("UPDATE {fundraiser_recurring} SET sf_opportunity_id = '%s' WHERE order_id = %d", $sfid, (int)$batch['records'][$i]->oid);
						
						// create and save the contact roles						
						$table = 'sf_donation_opportunity_contact_role';
						$record = new stdClass();
						$record->contact_id = $user_ids->salesforce_contact_id;
						$record->opportunity_id = $sfid;
						$record->role = 'Donor';
						drupal_write_record($table, $record);
								
					}
				}
				
				// export them
				sf_donation_export_opportunity_contact_roles();	
			}
			break;
			
		case FUNDRAISER_RECURRING_DONATION_TYPE:

			$sf = salesforce_management_api_connect();
			// only continue if we got a valid connection
			if ($sf) {	
				for ($i = 0; $i < $item_count; $i++) {
					if ($responses[$i]->success) {
						// we need to re-query salesforce and get all the opportunities that were created
						$sfid = $responses[$i]->id;
						$master_order_id = (int)$batch['records'][$i]->oid;

						$opportunities = $sf->client->query("select Id, Name, CloseDate from Opportunity WHERE npe03__Recurring_Donation__c = '$sfid' ORDER BY CloseDate");
						
						// get all recurring orders in drupal
						$result = db_query("SELECT order_id FROM {fundraiser_recurring} WHERE master_order_id = %d ORDER BY next_charge", $master_order_id);
						$recurring_orders = array();
						
						// add all recurring orders to an array in the same orders as the opportunities
						while ($data = db_fetch_object($result)) {
							$recurring_orders[] = $data;
						}
						
						// loop over the donations that were created
						for ($j = 0; $j < $opportunities->size; $j++) {
							if ($j == 0) {
								// first opportunity is the master. now that we have it's opportunity id, add it  
								db_query("UPDATE {fundraiser_webform_order} SET sfid = '%s' WHERE order_id = %d", $opportunities->records[$j]->Id, $master_order_id);
								//db_query("UPDATE {fundraiser_recurring} SET sf_opportunity_id = '%s' WHERE order_id = %d", $opportunities->records[$j]->Id, $master_order_id);
								salesforce_management_api_id_save(FUNDRAISER_SINGLE_DONATION_TYPE, $master_order_id, $opportunities->records[$j]->Id, 0);
								sf_queue_insert($master_order_id, FUNDRAISER_SINGLE_DONATION_TYPE, 'update');
							}
							else {
								db_query("UPDATE {fundraiser_recurring} SET sf_opportunity_id = '%s' WHERE order_id = %d", $opportunities->records[$j]->Id, $recurring_orders[$j-1]->order_id);
								salesforce_management_api_id_save(FUNDRAISER_SINGLE_DONATION_TYPE, $recurring_orders[$j-1]->order_id, $opportunities->records[$j]->Id, 0);
								sf_queue_insert($recurring_orders[$j-1]->order_id, FUNDRAISER_SINGLE_DONATION_TYPE, 'update');
							}	
						}
					}
				}
			}	
			
			break;	
	}
	
}

/**
 * Exports opportunity contact role objects to Salesforce
 */
function sf_donation_export_opportunity_contact_roles() {

	$sf = salesforce_management_api_connect();
	// only continue if we got a valid connection
	if ($sf) {	
		
		// get all un-exported records
		$result = db_query("SELECT contact_id, opportunity_id, role FROM {sf_donation_opportunity_contact_role} WHERE exported = %d", 0);
		$contact_roles = array();
		while ($data = db_fetch_object($result)) {
			// create the object
			$contact_roles[] = array(
				'ContactId' => $data->contact_id,
				'OpportunityId' => $data->opportunity_id,
				'Role' => $data->role,
			);
		}
	
		// divide them up if we've got more than 200
		$pieces = ceil(count($contact_roles) / 200);
		$batches = array_split($contact_roles, $pieces);
		
		foreach($batches as $batch) {
			$response = _normalize_salesforce_response($sf->client->create($batch, 'OpportunityContactRole'));

			// Process responses
			$items_in_batch = count($batch);
			for ($i = 0; $i < $items_in_batch; $i++) {
				if ($response[$i]->success) {
					db_query("UPDATE {sf_donation_opportunity_contact_role} SET exported = %d WHERE contact_id = '%s' AND opportunity_id = '%s'", 1, $batch[$i]['ContactId'], $batch[$i]['OpportunityId']);
				}
				else {
					watchdog('salesforce donation', t('Unable to create opportunity contact roles for opportunity !id.', array('!id' => $batch[$i]['OpportunityId'])), NULL, WATCHDOG_CRITICAL);		
				}
			}
		}
	}
	else {
		watchdog('salesforce donation', t('Could not connect to Salesforce. Opportunity Contact Roles were not created at this time. They have been saved and will be exported with the next donation.'), NULL, WATCHDOG_CRITICAL);
	}

}

/**
 * Splits an array into a specified number of new arrays
 */
function array_split($array, $pieces=2)
{  
	if ($pieces < 2) {
		return array($array);
	}
	
	$newCount = ceil(count($array)/$pieces);
	$a = array_slice($array, 0, $newCount);
	$b = array_split(array_slice($array, $newCount), $pieces-1);
	return array_merge(array($a),$b);
} 

/**
 * Returns the salesforce ids of a given user (prevents having to call node_load())
 */
function _sf_donation_load_user_salesforce_ids($uid) {

	$result = db_query("SELECT 
		CASE WHEN instr(u.data, 'salesforce_account_id') THEN substring(u.data, instr(u.data, 'salesforce_account_id')+29, 18)
		ELSE NULL
		END AS salesforce_account_id,
		CASE WHEN instr(u.data, 'salesforce_contact_id') THEN substring(u.data, instr(u.data, 'salesforce_contact_id')+29, 18)
		ELSE NULL
		END AS salesforce_contact_id 
		FROM {users} u 
		WHERE u.uid = %d", $uid);
		
	return db_fetch_object($result);
	
}

function _sf_donation_load_user_salesforce_ids_from_order($order_id) {

	$result = db_query("SELECT 
		CASE WHEN instr(u.data, 'salesforce_account_id') THEN substring(u.data, instr(u.data, 'salesforce_account_id')+29, 18)
		ELSE NULL
		END AS salesforce_account_id,
		CASE WHEN instr(u.data, 'salesforce_contact_id') THEN substring(u.data, instr(u.data, 'salesforce_contact_id')+29, 18)
		ELSE NULL
		END AS salesforce_contact_id 
		FROM {users} u INNER JOIN
		{uc_orders} o ON o.uid = u.uid WHERE o.order_id = %d", $order_id);
		
	return db_fetch_object($result);

}

/*
 * Creates an array that represents a salesforce opportunity object
 */
function _create_single_donation($order_id, $account_id, $sid) {

	global $base_url;

	// load up the order 
	$order = uc_order_load($order_id);

	// load up the payments because we need the received date of the payment
	$payments = uc_payment_load_payments($order_id);
	$txn_details = _sf_donation_get_transaction_details($order_id);
	$donation_name = t('Donation - !first !last (!date)', array('!first' => $order->billing_first_name, '!last' => $order->billing_last_name, '!date' => gmdate('Y-m-d H:i:s\Z', $order->created)));
	
	$donation = array(
		'Name' => $donation_name,
		'Amount' => $order->order_total,
		'AccountID' => $account_id,
		'Order_ID__c' => $order->order_id,
		'Donation_Form_Name__c' => $order->products[0]->title,
		'Donation_Form_URL__c' => $base_url . '/node/' . $order->products[0]->nid,
		'CC_Last_4__c' => !empty($order->payment_details['cc_number']) ? substr($order->payment_details['cc_number'], -4) : '',
		'CC_Type__c' => $order->payment_details['cc_type'],
		'CC_Exp_Month__c' => $order->payment_details['cc_exp_month'],
		'CC_Exp_Year__c' => $order->payment_details['cc_exp_year'],
		'Billing_Street__c' => $order->billing_street1,
		'Billing_Street_Line_2__c' => $order->billing_street2,
		'Billing_City__c' => $order->billing_city,
		'Billing_Country__c' => _convert_billing_country($order->billing_country),
		'Billing_State__c' => uc_get_zone_code($order->billing_zone),
		'Billing_Zip__c' => $order->billing_postal_code,
		'Type' => 'Donation',
		'Payment_Gateway__c' => $txn_details['gateway'],
    'Transaction_Id__c' => $txn_details['txn_id'],
	);

   // if this donation is part of a recurring series it will have some additional information that needs to be added
	$recurring_details = _sf_donation_get_recurring_details($order_id);
	if (!empty($recurring_details)) {
    $donation['CloseDate'] = date('Y-m-d', $recurring_details['close_date']);
    $donation['npe03__Recurring_Donation__c'] = $recurring_details['sfid'];
    if ($recurring_details['status'] == 'canceled') {
      $donation['StageName'] = 'Withdrawn';  
      $donation['Cancellation_Reason__c'] = $recurring_details['cancellation_reason'];
    }
    else {
      $donation['StageName'] = 'Pledged';
    }
	}
	
	// add payment details if available
	if ($payments) {
		// deal with sf date handling
		$transaction_date = strtotime(date('H:i:s d-M-Y T', $payments[0]->received));
		$donation['CloseDate'] = date('Y-m-d', $transaction_date);
		$donation['Transaction_Date_Time__c'] = gmdate('c', $transaction_date);
		$donation['Probability'] = 100.00;
		$donation['StageName'] = 'Posted';
	}
  
	// 7/19/2010 - pcave: Bug fix. If this order was part of a recurring donation series, make sure the correct CloseDate is set in Salesforce in case the
	// 									  order doesn't export on the day it was created
	$close_date = db_result(db_query("SELECT next_charge FROM {fundraiser_recurring} WHERE order_id = %d", $order_id));
	if ($close_date) {
		$donation['CloseDate'] = date('Y-m-d', $close_date);
	}
	
	$donation = array_merge($donation, _load_salesforce_map($sid));
	
	// clear the credit card cache
	uc_credit_cache('clear');

	return $donation;
}

/**
 * Gets the transaction details for a specific order.
 */
function _sf_donation_get_transaction_details($order_id) {
  $details = array();
  $result = db_query(
    "
      SELECT order_id, gateway, txn_id 
      FROM {fundraiser_webform_order} 
      WHERE order_id = %d
      UNION
      SELECT order_id, gateway, txn_id
      FROM {fundraiser_recurring}
      WHERE order_id = %d
    ",
    $order_id, $order_id
  );
      
  while ($data = db_fetch_object($result)) {
    $details['gateway'] = $data->gateway;
    $details['txn_id'] = $data->txn_id;
  }
  return $details;
}

/**
 * Returns the SFID and close date of a recurring donation for an individual order
 */
function _sf_donation_get_recurring_details($order_id) {
  $recurring_info = array();
  
  $result = db_query(
    "
      SELECT f.next_charge, s.sfid, f.gateway_resp, f.cancellation_reason 
      FROM {salesforce_management_object_map} s
      INNER JOIN {fundraiser_recurring} f ON f.master_order_id = s.oid
      WHERE f.order_id = %d AND s.drupal_type = 'recurring_donation'
    ",
    $order_id
  );
  
  while ($data = db_fetch_object($result)) {
    $recurring_info['close_date'] = $data->next_charge;
    $recurring_info['sfid'] = $data->sfid;
    $recurring_info['status'] = $data->gateway_resp;
    $recurring_info['cancellation_reason'] = $data->cancellation_reason;
  }
  
  return $recurring_info;
}

/**
 * Converts a numeric country id to it's ISO code.
 */
function _convert_billing_country($country_id) {
	return db_result(db_query("select country_iso_code_2 from {uc_countries} where country_id = %d", $country_id));
}

/*
 * Creates an array that represents a salesforce recurring donation object
 */
function _create_recurring_donation($order_id, $contact_id, $count) {

	$order = uc_order_load($order_id);
	$donation_name = t('Recurring Donation - !first !last (!date)', array('!first' => $order->billing_first_name, '!last' => $order->billing_last_name, '!date' => gmdate('Y-m-d H:i:s\Z', $order->created)));
	
	$donation = array(
		'Name' => $donation_name,
		'npe03__Amount__c' => $order->order_total,
		'npe03__Contact__c' => $contact_id,
		'npe03__Installment_Period__c' => 'Monthly',
		'npe03__Schedule_Type__c' => 'Multiply By',
		'npe03__Installments__c' => $count,
	);
	
	// clear the credit card cache
	uc_credit_cache('clear');
	return $donation;

}

/* 
 * Updates an opportunity when a donation payment processes.
 */
function sf_donation_update_donation_status($order_id) {
	// get the sfid from the recurring orders table
	$sfid = db_result(db_query("select sf_opportunity_id from {fundraiser_recurring} where order_id = %d", $order_id));
	if ($sfid) {
		// get order payment so we can get the transaction date
		$payments = uc_payment_load_payments($order_id);
		// deal with sf date handling
		$transaction_date = strtotime(date('H:i:s d-M-Y T', $payments[0]->received));
		
		$opportunity = array(
			'Id' => $sfid,
			'Transaction_Date_Time__c' => gmdate('c', $transaction_date),
			'Probability' => 100.00,
			'StageName' => 'Posted',
		);
		
		$sf = salesforce_management_api_connect();
		$results = $sf->client->update(array($opportunity), 'Opportunity');
		
		if (!$results->success) {
			// Log failure
			watchdog('error', "Opportunity $sfid was not updated in salesforce after a recurring payment was processed. Errors: $results->errors");
			// Trigger failure
			//module_invoke_all('sf_donation', 'fails', $order_id, $sfid, "Opportunity $sfid was not updated in salesforce after a recurring payment was processed. Errors: $results->errors");
			$params = array(
				'order_id' => $order_id,
				'errors' => $results->errors,
				'donation' => print_r($opportunity, true),
			);
			drupal_mail('sf_donation', 'recurring_donation_payment_failure', 'phillip.cave@jacksonriver.com,tom.williamson@jacksonriver.com,tj.griffin@jacksonriver.com', language_default(), $params);
		}
		else {
			watchdog('salesforce', t('Opportunity !sfid updated to stage Posted at !time. Order Id is !order_id', array('!sfid'=>$sfid, '!time'=>gmdate('c', $transaction_date), '!order_id'=>$order_id)), NULL, WATCHDOG_INFO);
		}
	}
} 

/**
 * Updates the donation amount of recurring orders
 */
function sf_donation_update_donation_amount($order_ids, $amount) {
	// get all of the recurring donations that have not been processed
	$sql = "select sf_opportunity_id from {fundraiser_recurring} where order_id in (%s)";
	$results = db_query($sql, implode(",", $order_ids));
	
	$donations = array();
	
	while ($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'Amount' => $amount,
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			$errors = print_r($errors, TRUE);
			watchdog('error', "Donation amount for opportunity $sfid was not updated in salesforce. Errors: $errors");
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Donation amount for opportunity $sfid was not updated in salesforce. Errors: $errors");
		}
	}
}

/**
 * Updates an opportunity to cancelled.
 */
function sf_donation_canel_recurring_donations($order_id) {
	$sql = "select sf_opportunity_id, cancellation_reason from {fundraiser_recurring} where master_order_id = %d and gateway_resp = 'canceled'";
		
	$results = db_query($sql, $order_id);
	$donations = array();
	
	while ($data = db_fetch_object($results)) {
		$donation = array(
			'Id' => $data->sf_opportunity_id,
			'StageName' => 'Withdrawn',
			'Cancellation_Reason__c' => $data->cancellation_reason,
		);
		$donations[] = $donation;
	}
	
	$sf = salesforce_management_api_connect();
	$results = $sf->client->update($donations, 'Opportunity');
	
	// process results
	$count = count($donations);
	for ($i=0; $i < $count; $i++) {
		// salesforce does not return an array if only one object is created
		if ($count == 1) {
			$success = $results->success;
			$sfid = $results->id;
			$errors = $results->errors;
		}
		else {
			$success = $results[$i]->success;
			$sfid = $results[$i]->id;
			$errors = $results[$i]->errors;
		}
		if (!$success) {
			// Log failure
			watchdog('error', "Opportunity $sfid was not withdrawn in salesforce. Errors: " . print_r($errors, TRUE));
			// Trigger failure
			module_invoke_all('sf_donation', 'fails', NULL, $sfid, "Opportunity $sfid was not withdrawn in salesforce. Errors: " . print_r($errors, TRUE));
		}
	}
}

/*
 * Loads the donation -> salesforce map for this webform and populates it
 * with data from the actual webform submission
 */
function _load_salesforce_map($sid) {
	$sql = "SELECT f.map_id, c.form_key, s.data FROM {fundraiser_salesforce_map} f inner join {webform_component} c on c.cid = f.cid and c.nid = f.nid
		inner join {webform_submitted_data} s on s.cid = c.cid and s.nid = c.nid where s.sid = %d";
	
	$map = array();
	
	$results = db_query($sql, $sid);
	while ($data = db_fetch_object($results)) {
		$map[$data->map_id] = $data->data;
	}	

	return $map;
}

/*
 * Gets the number of times a given donation recurs
 */
function _recurring_donation_count($order_id) {
	return db_result(db_query("select count(order_id) from {fundraiser_recurring} where master_order_id = %d", $order_id));
}

/*
 * Updates a webform created order with the id from salesforce
 */
function _update_webform_order($order_id, $sfid) {
	db_query("update {fundraiser_webform_order} set sfid = '%s' where order_id = %d", $sfid, $order_id);
}

/**
 * Theme the mapping form
 */
function theme_sf_donation_mapping_form($form) {
	$output = drupal_render($form['user_mappings']);
	
	if ($form['mapping']['cid']) {
		foreach ($form['mapping']['cid'] as $key=>$cid) {
			if (is_numeric($key)) {
				$row = array();
				$row[] = drupal_render($form['mapping']['cid'][$key]);
				$row[] = drupal_render($form['mapping']['salesforce'][$key]);
				$rows[] = $row;
			}
		}
		$row = array();
		$row[] = drupal_render($form['submit']);
		$row[] = '&nbsp;';
		$rows[] = $row;
	
		$header = array("Webform Component","Opportunity Field");
	
		$output .= theme('table', $header, $rows, array('id' => 'sf_donation_mapping_form'));
		$output .= drupal_render($form);
	}
	else {
		$output = "<p>You must add some fields to the webform before you can map them.</p>";
	}
	return $output;
}

function _get_campaigns() {
	$sf = salesforce_management_api_connect();
	$campaigns = array();
	// only continue if we got a valid connection
	if ($sf) {
		$results = $sf->client->query("select Id, Name from Campaign where Status = 'In Progress'");
		if (count($results->records)) {
			foreach($results->records as $campaign) {
				$campaigns[$campaign->Id] = $campaign->Name;
			}
		}
	}
	return $campaigns;
}

/**
 * Mail handling function
 */
function sf_donation_mail($key, &$message, $params) {
	switch($key) {
		case 'single_donation_failure':
			$message['subject'] = t("Single donation export failure");
			break;
			
		case 'recurring_donation_failure':
			$message['subject'] = t("Recurring donation export failure");
			break;
			
		case 'recurring_donation_update_failure':
			$message['subject'] = t("Recurring donation update failure");
			break;
		
		case 'recurring_donation_payment_failure':
			$message['subject'] = t("Recurring donation payment failure");
			break;
	}
	$message['body'][] = t("Order !order_id has failed to export to Salesforce.\n", array('!order_id' => $params['order_id']));
	$message['body'][] = t("API Error\n\n!errors", array('!errors' => $params['errors']));
	$message['body'][] = t("Failed Object\n\n!object", array('!object' => $params['donation']));
}
function _get_mapping_config() {
	$fields = array(
		'unmappable' => array(
			'Name',
			'AccountID',
			'Probability',
			'StageName',
			'Order_ID__c',
			'CloseDate',
			'Transaction_Date_Time__c',
			'Donation_Form_Name__c',
			'Donation_Form_URL__c',
			'CC_Last_4__c',
			'CC_Type__c',
			'CC_Exp_Month__c',
			'CC_Exp_Year__c',
			'Type',
		),
		'predefined' => array(
			'card_number' => 'CC_Last_4__c',
			'card_expiration_date' => 'CC_Exp_Month__c',
			'amount' => 'Amount',
			'billing_address' => 'Billing_Street__c',
			'billing_address_2' => 'Billing_Street_Line_2__c',
			'billing_city' => 'Billing_City__c',
			'billing_country' => 'Billing_Country__c',
			'billing_state' => 'Billing_State__c',
			'billing_zipcode' => 'Billing_Zip__c',
		),
	);
	return $fields;
}