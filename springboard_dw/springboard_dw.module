<?php
/**
 * @file
 * Base Springboard data warehouse functions.
 */

require_once 'includes/springboard_dw.menu.inc';
require_once 'includes/springboard_dw.api.inc';
require_once 'includes/springboard_dw.queue.inc';
require_once 'includes/springboard_dw.utility.inc';

/**
 * Success hook for advocacy actions and submissions.
 * Implements advocacy_hook_success()
 * @param $node
 * @param $contact
 * @param $data
 * @param $sid
 */
function springboard_dw_action_success($node, $contact, $data, $sid)
{

  $webform_submission_data = springboard_dw_webform_submission_data_keyed($node->nid, $sid);

  $action = new stdClass();
  $action->node = $node;
  $action->contact = $contact;
  $action->data = $data;
  $action->webform = $webform_submission_data;
  $action->sid = $sid;

  // If the submission is a message action
  if($action->node->type == 'sba_message_action') {
    springboard_dw_advocacy_message_action_submission($node, $action);
  }

  // If the submission is a message action
  if($action->node->type == 'springboard_petition') {
    springboard_dw_petition_submission($node, $action);
  }

  // If the submission is a message action
  if($action->node->type == 'sba_social_action') {
    springboard_dw_social_action_submission($node, $action);
  }
}

/** Field a message action submission for warehousing.
 * @param $node
 * @param $action
 */
function springboard_dw_advocacy_message_action_submission($node, $action) {

  // Get the Drupal data warehouse queue
  $queue = DrupalQueue::get("springboard_dw_export");

  // Create the Advocacy action item in the queue if not warehoused
  if (!springboard_dw_item_is_warehoused('advocacy action', $node->nid)) {

    $message_action_item = springboard_dw_map_advocacy_action_item($action);

    $queue->createItem($message_action_item);
  }

  // If the Advocacy action messages have not been warehoused, add them
  if (!empty($action->data['message_ids'])) {

    // Loop through the messages
    foreach ($action->data['message_ids'] as $key => $message) {

      if (!springboard_dw_item_is_warehoused('advocacy message', $message->{'$id'})) {

        // Get the Advocacy message object id and prep for warehousing (sb_message)
        $message_item = array();
        $message_item['queue_type'] = 'advocacy message';
        $message_item['message_id'] = $message->{'$id'};
        $message_item['action_id'] = $action->node->advocacy_id;

        $queue->createItem($message_item);
      }
    }
  }


}

/** Field a petition submission for warehousing.
 * @param $node
 * @param $action
 */
function springboard_dw_petition_submission($node, $action) {

  // Get the Drupal data warehouse queue
  $queue = DrupalQueue::get("springboard_dw_export");

  // Create the Advocacy action item in the queue if not warehoused
  if (!springboard_dw_item_is_warehoused('petition', $node->nid)) {

    $petition_item = springboard_dw_map_petition_item($action);

    $queue->createItem($petition_item);
  }

  // Create the Advocacy action item in the queue if not warehoused
  if (!springboard_dw_item_is_warehoused('submission', $node->nid)) {

    $petition_item = springboard_dw_map_petition_submission_item($action);

    $queue->createItem($petition_item);
  }

}

/** Field a social action submission for warehousing.
 * @param $node
 * @param $action
 */
function springboard_dw_social_action_submission($node, $action) {
}


/**
 * Get the webform submission dated keyed according to submission.
 * @param $nid
 * @param $sid
 * @return array
 */
function springboard_dw_webform_submission_data_keyed($nid, $sid)
{
  $data = array();
  $node = node_load($nid);

  module_load_include('inc', 'webform', 'includes/webform.submissions');
  $submission = webform_get_submission($nid, $sid);

  foreach ($node->webform['components'] AS $key => $component) {
    if (isset($submission->data[$key])) {
      $data[$component['form_key']] = $submission->data[$key];
    }
  }

  return $data;
}

/**
 * Implements hook_fundraiser_donation_success().
 * @param $donation
 */
function springboard_dw_fundraiser_donation_success($donation)
{
  // Get the Drupal data warehouse queue
  $queue = DrupalQueue::get("springboard_dw_export");

  // Queue the donation object which should not be in the queue, so there's no need to check if this item is warehoused
  $donation_item = springboard_dw_map_donation_item($donation);
  $queue->createItem($donation_item);

}

/**
 * Hook to listen for new form items to ship to the data warehouse.
 * Implements hook_node_insert().
 * @param $node
 */
function springboard_dw_node_insert($node)
{

  // Create the form item
  if ($node->is_webform_user) {
    // Get the Drupal data warehouse queue
    $queue = DrupalQueue::get("springboard_dw_export");

    // Create the form item in the queue if not warehoused
    if (!springboard_dw_item_is_warehoused('form', $node->nid)) {
      $form_item = springboard_dw_map_form_item($node);
      $queue->createItem($form_item);
    }
  }
}

/**
 * Ship an updated form record to the data warehouse.
 * Implements hook_node_update().
 * @param $node
 */
function springboard_dw_node_update($node)
{

  // Map the node
  $node_item = springboard_dw_map_form_item($node, True); // Update operation

  // Create the queue item to update the node record
  $queue = DrupalQueue::get("springboard_dw_export");
  $queue->createItem($node_item);

}


/**
 * Ship a user record to the data warehouse.
 * Implements hook_user_insert().
 * @param $edit
 * @param $account
 * @param $category
 */
function springboard_dw_user_insert(&$edit, $account, $category)
{

  // Create the user item in the queue if not warehoused
  if (!springboard_dw_item_is_warehoused('contact', $account->uid)) {

    // Take the account object and prep for contact mapping
    $user_obj = entity_metadata_wrapper('user', $account);
    $user_data = get_all_entity_properties($user_obj);

    // Map the user contact
    $contact_item = springboard_dw_map_contact_item($account->uid, $user_data);

    // Create the queue item to update the contact record
    $queue = DrupalQueue::get("springboard_dw_export");
    $queue->createItem($contact_item);
  }

}

/**
 * Ship an updated user record to the data warehouse.
 * Implements hook_user_update().
 * @param $edit
 * @param $account
 * @param $category
 */
function springboard_dw_user_update(&$edit, $account, $category)
{

  /**
   * TODO - this runs on general form submissions which is bad, we don't want to try to update the contact record every time.
   * @author - cameronkingzett
   * @date - 3/21/16
   * @time -  4:23 PM
   */

  // Take the account object and prep for contact mapping
  $user_obj = entity_metadata_wrapper('user', $account);
  $user_data = get_all_entity_properties($user_obj);

  // Map the user contact
  $contact_item = springboard_dw_map_contact_item($account->uid, $user_data, True); // Update operation

  // Create the queue item to update the contact record
  $queue = DrupalQueue::get("springboard_dw_export");
  $queue->createItem($contact_item);

}

/**
 * Map the Advocacy action object to an array formatted for an API call for data warehousing.
 * @param $donation
 * @return array
 */
function springboard_dw_map_advocacy_action_item($message_action)
{

  // Get the Advocacy action object details and prep for warehousing (sb_action)
  $advocacy_item = array();

  $advocacy_item['queue_type'] = 'advocacy action';
  $advocacy_item['action_id'] = $message_action->node->advocacy_id;
  $advocacy_item['action_type'] = $message_action->node->type;
  $advocacy_item['group_id'] = ''; // Will come later
  $advocacy_item['contact_id'] = $message_action->node->uid;
  $advocacy_item['form_id'] = $message_action->node->nid;

  // TODO: Fix these
  $advocacy_item['quick_submit'] = 0;
  $advocacy_item['click_submit'] = 0;

  $advocacy_item['ip_address'] = ip_address();

  $advocacy_item['ms'] = $message_action->webform['ms']['value'][0];
  $advocacy_item['cid'] = $message_action->webform['cid']['value'][0];
  $advocacy_item['referrer'] = $message_action->webform['referrer']['value'][0];
  $advocacy_item['initial_referrer'] = $message_action->webform['initial_referrer']['value'][0];
  $advocacy_item['search_engine'] = $message_action->webform['search_engine']['value'][0];
  $advocacy_item['search_string'] = $message_action->webform['search_string']['value'][0];
  $advocacy_item['user_agent'] = $message_action->webform['user_agent']['value'][0];
  $advocacy_item['device_type'] = $message_action->webform['device_type']['value'][0];
  $advocacy_item['device_name'] = $message_action->webform['device_name']['value'][0];
  $advocacy_item['device_os'] = $message_action->webform['device_os']['value'][0];
  $advocacy_item['device_browser'] = $message_action->webform['device_browser']['value'][0];

  // Legislative and organizational issues get added as CSV strings if they exist
  $legislative_issues = '';
  $organizational_issues = '';

  // If the message action has legislative issues included, add them
  if (!empty($message_action->node->field_sba_legislative_issues)) {

    // Load up and loop through the legislative issues and add them as csv strings
    foreach ($message_action->node->field_sba_legislative_issues['und'] as $issue) {
      $issue_taxonomy = taxonomy_term_load($issue['tid']);
      $legislative_issues .= $issue_taxonomy->name . ',';
    }
  }

  // If the message action has organizational issues included, add them
  if (!empty($message_action->node->field_sba_organizational_issues)) {

    // Load up and loop through the organizational issues and add them as csv strings
    foreach ($message_action->node->field_sba_organizational_issues['und'] as $issue) {
      $issue_taxonomy = taxonomy_term_load($issue['tid']);
      $organizational_issues .= $issue_taxonomy->name . ',';
    }
  }

  // Cleanup the legislative issues and organizational issues list before adding to the action array
  $legislative_issues = rtrim($legislative_issues, ', ');
  $organizational_issues = rtrim($organizational_issues, ', ');

  $advocacy_item['legislative_issues'] = $legislative_issues;
  $advocacy_item['organization_issues'] = $organizational_issues;

  $advocacy_item['created_at'] = $message_action->node->created;
  $advocacy_item['updated_at'] = $message_action->node->changed;

  return $advocacy_item;

}

/**
 * Map the Advocacy petition object to an array formatted for an API call for data warehousing.
 * @param $petition
 * @return array
 */
function springboard_dw_map_petition_item($petition)
{

  // Get the Advocacy petition object details and prep for warehousing (sb_action)
  $advocacy_item = array();

  $advocacy_item['queue_type'] = 'petition';
  $advocacy_item['action_id'] = '';
  $advocacy_item['action_type'] = $petition->node->type;
  $advocacy_item['group_id'] = ''; // Will come later
  $advocacy_item['contact_id'] = $petition->node->uid;
  $advocacy_item['form_id'] = $petition->node->nid;

  // TODO: Fix these
  $advocacy_item['quick_submit'] = 0;
  $advocacy_item['click_submit'] = 0;

  $advocacy_item['ip_address'] = ip_address();

  $advocacy_item['ms'] = $petition->webform['ms']['value'][0];
  $advocacy_item['cid'] = $petition->webform['cid']['value'][0];
  $advocacy_item['referrer'] = $petition->webform['referrer']['value'][0];
  $advocacy_item['initial_referrer'] = $petition->webform['initial_referrer']['value'][0];
  $advocacy_item['search_engine'] = $petition->webform['search_engine']['value'][0];
  $advocacy_item['search_string'] = $petition->webform['search_string']['value'][0];
  $advocacy_item['user_agent'] = $petition->webform['user_agent']['value'][0];
  $advocacy_item['device_type'] = $petition->webform['device_type']['value'][0];
  $advocacy_item['device_name'] = $petition->webform['device_name']['value'][0];
  $advocacy_item['device_os'] = $petition->webform['device_os']['value'][0];
  $advocacy_item['device_browser'] = $petition->webform['device_browser']['value'][0];

  // organizational issues get added as CSV strings if they exist
  $organizational_issues = '';

  // If the message action has organizational issues included, add them
  if (!empty($petition->node->field_sba_organizational_issues)) {

    // Load up and loop through the organizational issues and add them as csv strings
    foreach ($petition->node->field_sba_organizational_issues['und'] as $issue) {
      $issue_taxonomy = taxonomy_term_load($issue['tid']);
      $organizational_issues .= $issue_taxonomy->name . ',';
    }
  }

  // Cleanup the organizational issues list before adding to the action array
  $organizational_issues = rtrim($organizational_issues, ', ');
  $advocacy_item['organization_issues'] = $organizational_issues;

  $advocacy_item['created_at'] = $petition->node->created;
  $advocacy_item['updated_at'] = $petition->node->changed;

  return $advocacy_item;

}


/**
 * Map the Advocacy petition submission object to an array formatted for an API call for data warehousing.
 * @param $petition
 * @return array
 */
function springboard_dw_map_petition_submission_item($petition)
{

  // Get the Advocacy petition object details and prep for warehousing (sb_action)
  $advocacy_item = array();

  $advocacy_item['queue_type'] = 'submission';
  $advocacy_item['submission_id'] = $petition->sid;
  $advocacy_item['group_id'] = ''; // Will come later
  $advocacy_item['contact_id'] = $petition->node->uid;
  $advocacy_item['form_id'] = $petition->node->nid;
  $advocacy_item['ms'] = $petition->webform['ms']['value'][0];
  $advocacy_item['cid'] = $petition->webform['cid']['value'][0];
  $advocacy_item['referrer'] = $petition->webform['referrer']['value'][0];
  $advocacy_item['initial_referrer'] = $petition->webform['initial_referrer']['value'][0];
  $advocacy_item['search_engine'] = $petition->webform['search_engine']['value'][0];
  $advocacy_item['search_string'] = $petition->webform['search_string']['value'][0];
  $advocacy_item['user_agent'] = $petition->webform['user_agent']['value'][0];
  $advocacy_item['device_type'] = $petition->webform['device_type']['value'][0];
  $advocacy_item['device_name'] = $petition->webform['device_name']['value'][0];
  $advocacy_item['device_os'] = $petition->webform['device_os']['value'][0];
  $advocacy_item['device_browser'] = $petition->webform['device_browser']['value'][0];

  // organizational issues get added as CSV strings if they exist
  $organizational_issues = '';

  // If the message action has organizational issues included, add them
  if (!empty($petition->node->field_sba_organizational_issues)) {

    // Load up and loop through the organizational issues and add them as csv strings
    foreach ($petition->node->field_sba_organizational_issues['und'] as $issue) {
      $issue_taxonomy = taxonomy_term_load($issue['tid']);
      $organizational_issues .= $issue_taxonomy->name . ',';
    }
  }

  // Cleanup the organizational issues list before adding to the action array
  $organizational_issues = rtrim($organizational_issues, ', ');
  $advocacy_item['organization_issues'] = $organizational_issues;

  $advocacy_item['created_at'] = $petition->node->created;
  $advocacy_item['updated_at'] = $petition->node->changed;

  return $advocacy_item;

}




/**
 * Map the Advocacy message to an array formatted for an API call for data warehousing.
 * @param $donation
 * @return array
 */
function springboard_dw_map_advocacy_message_item($message, $full_message)
{

  $message_item = $message;

  $full_message = json_decode(json_encode($full_message), True);

  $message_item['message_id'] = $message['message_id'];
  $message_item['action_id'] = $message['action_id'];
  $message_item['group_id'] = $message['group_id'];
  $message_item['message_id'] = $message['message_id'];
  $message_item['action_id'] = $message['action_id'];
  $message_item['subject'] = $full_message['message']['subject'];
  $message_item['body'] = $full_message['message']['body'];
  // $message_item['user_edited'] = $full_message->;  Todo: fix this
  $message_item['target_id'] = $full_message['target']['id'];
  $message_item['target_salutation'] = $full_message['target']['salutation'];
  $message_item['target_first_name'] = $full_message['target']['firstName'];
  $message_item['target_last_name'] = $full_message['target']['lastName'];
  $message_item['target_gender'] = $full_message['target']['gender'];
  $message_item['target_state'] = $full_message['target']['state'];
  $message_item['target_party'] = $full_message['target']['party'];
  $message_item['target_district_code'] = $full_message['target']['districtCode'];
  $message_item['target_district_name'] = $full_message['target']['districtName'];
  // $message_item['target_fec_id'] = $full_message['target']['districtCode']; Todo: Add fec ID
  $message_item['target_role'] = $full_message['target']['role'];
  $message_item['target_person_id'] = $full_message['target']['personId'];
  $message_item['created_at'] = $full_message['delivery']['createdAt']['sec'];
  $message_item['updated_at'] = $full_message['delivery']['updatedAt']['sec'];
  $message_item['extra_props'] = array();

  return $message_item;

}

/**
 * Map the donation object to an array formatted for an API call for data warehousing.
 * @param $donation
 * @return array
 */
function springboard_dw_map_donation_item($donation)
{
  // Get the donation object details and prep for warehousing (sb_donation)
  $donation_item = array();

  $donation_item['queue_type'] = 'donation';
  $donation_item['donation_id'] = $donation->did;
  $donation_item['group_id'] = ''; // Will come later
  $donation_item['amount'] = $donation->amount;
  $donation_item['currency'] = $donation->currency;
  // Legacy property so check for it first.
  $donation_item['quantity'] = array_key_exists('quantity', $donation->donation) ? $donation->donation['quantity'] : 1;

  // Todo: Where do these come from ?
  // 3/17/2016: pcave - These have not been implemented for donations yet. Eventually
  // they will be available in the $donation->donation data structure albeit
  // probably with a different name. Setting to 0 until those are implemented.
  $donation_item['quick_submit'] = 0;
  $donation_item['click_submit'] = 0;

  $donation_item['ms'] = $donation->donation['ms'];
  $donation_item['cid'] = $donation->donation['cid'];
  $donation_item['first_name'] = $donation->donation['first_name'];
  $donation_item['last_name'] = $donation->donation['last_name'];
  $donation_item['email'] = $donation->donation['mail'];
  $donation_item['address'] = $donation->donation['address'];
  $donation_item['address_line_2'] = $donation->donation['address_line_2'];
  $donation_item['city'] = $donation->donation['city'];
  $donation_item['state'] = $donation->donation['state'];
  $donation_item['country'] = $donation->donation['country'];
  $donation_item['zip'] = $donation->donation['zip'];
  $donation_item['referrer'] = $donation->donation['referrer'];
  $donation_item['initial_referrer'] = $donation->donation['initial_referrer'];
  $donation_item['payment_method'] = $donation->donation['payment_method'];
  $donation_item['recurs_monthly'] = $donation->donation['recurs_monthly'];
  $donation_item['search_engine'] = $donation->donation['search_engine'];
  $donation_item['search_string'] = $donation->donation['search_string'];
  $donation_item['user_agent'] = $donation->donation['user_agent'];
  $donation_item['device_type'] = $donation->donation['device_type'];
  $donation_item['device_name'] = $donation->donation['device_name'];
  $donation_item['device_os'] = $donation->donation['device_os'];
  $donation_item['device_browser'] = $donation->donation['device_browser'];
  $donation_item['form_id'] = $donation->nid;
  $donation_item['user_id'] = $donation->uid;
  $donation_item['submission_id'] = $donation->sid;
  $donation_item['status'] = $donation->status;
  $donation_item['transaction_id'] = $donation->txn_id;
  $donation_item['gateway'] = $donation->gateway['id'];
  $donation_item['card_type'] = $donation->data['payment_fields']['credit']['card_type'];
  $donation_item['card_last_4'] = $donation->data['payment_fields']['credit']['card_number'];
  $donation_item['card_expiration_month'] = $donation->data['payment_fields']['credit']['card_expiration_month'];
  $donation_item['card_expiration_year'] = $donation->data['payment_fields']['credit']['card_expiration_year'];

  # Todo: fix these
  // 3/17/2016: pcave - We'll probably end up with some sort of payment_method switch in here
  // at some point.
  $donation_item['bank_account_mask'] = '';
  /**
   * 3/17/2016: pcave - IP address comes from the submission, which isn't available with the donation
   * object and I don't want to load it here. We'll need to have the fundraiser_webform module
   * add that so it will be readily available.
   */
  $donation_item['ip_address'] = '';

  $donation_item['created_at'] = date('U');
  $donation_item['updated_at'] = date('U');

  // Add the extra props attributes
  $donation_item['extra_props'] = json_encode(springboard_dw_extract_donation_extra_props($donation, $donation_item));

  return $donation_item;
}

/**
 * Extracts non-standard fields out of the donation and returns an array of extra_props.
 *
 * @param $donation
 *   The donation from which properties are to be extracted.
 * @param $donation_item
 *   The donation item being prepared for the queue.
 */
function springboard_dw_extract_donation_extra_props($donation, $donation_item)
{
  // Maintain a field blacklist because there are some donation properties that should
  // never be exported. The payment_fields array will contain full credit card numbers!
  $field_blacklist = variable_get('springboard_dw_donation_field_blacklist', array('mail', 'payment_fields', 'other_amount'));

  // Extract items in $donation->donation that are not already explicitly added to
  // $donation_item. Any custom fields that were added to a donation form will be
  // in the $donation->donation data structure.
  $extra_props = array();
  foreach ($donation->donation as $key => $value) {
    if (!in_array($key, $field_blacklist) && !array_key_exists($key, $donation_item)) {
      $extra_props[$key] = $value;
    }
  }

  return $extra_props;
}

/**
 * Map the donation object to a contact array formatted for an API call for data warehousing.
 * @param $donation
 * @return array
 */
function springboard_dw_map_contact_item($contact_id, $user_data = array(), $update = False)
{

  // If the $user_data parameter is empty we can assume this is a new record we need to insert
  if(empty($user_data)) {
    $user = user_load($contact_id);
    $user_obj = entity_metadata_wrapper('user', $user);
    $user_data = get_all_entity_properties($user_obj);
  }

  // Get the user account details and prep for warehousing (sb_contact)
  $contact_item = array();
  $contact_item['queue_type'] = 'contact';

  // If user data is being passed to update, flag this queue item for an update
  if (!empty($user_data) && $update == True) {
    $contact_item['queue_item_update'] = True;
  }

  $contact_item['contact_id'] = $contact_id;
  $contact_item['group_id'] = ''; // Will come later
  $contact_item['username'] = $user_data['name'];
  $contact_item['email'] = $user_data['mail'];
  $contact_item['first_name'] = $user_data['sbp_first_name'];
  $contact_item['last_name'] = $user_data['sbp_last_name'];
  $contact_item['address'] = $user_data['sbp_address'];
  $contact_item['address_line_2'] = $user_data['sbp_address_line_2'];
  $contact_item['city'] = $user_data['sbp_city'];
  $contact_item['state'] = $user_data['sbp_state'];
  $contact_item['country'] = $user_data['sbp_country'];
  $contact_item['zip'] = $user_data['sbp_zip'];
  $contact_item['ms'] = $user_data['sbp_ms'];
  $contact_item['cid'] = $user_data['sbp_cid'];
  $contact_item['referrer'] = $user_data['sbp_referrer'];
  $contact_item['initial_referrer'] = $user_data['sbp_initial_referrer'];
  $contact_item['search_engine'] = $user_data['sbp_search_engine'];
  $contact_item['search_string'] = $user_data['sbp_search_string'];
  $contact_item['user_agent'] = $user_data['sbp_user_agent'];
  $contact_item['salesforce_account_id'] = $user_data['sbp_salesforce_account_id'];
  $contact_item['salesforce_contact_id'] = $user_data['sbp_salesforce_contact_id'];
  $contact_item['created_at'] = $user_data['created'];
  $contact_item['updated_at'] = $user_data['created'];

  // Add the extra props attributes
  $contact_item['extra_props'] = json_encode(springboard_dw_extract_contact_extra_props($user_data, $contact_item));

  return $contact_item;
}

/**
 * Extracts non-standard fields out of a user object and returns an array of extra_props.
 *
 * @param $user
 *   The user object from which properties are to be extracted.
 * @param $contact_item
 *   The contact item being prepared for the queue.
 */
function springboard_dw_extract_contact_extra_props($user, $contact_item)
{
  // Maintain a field blacklist because there are some donation properties that should
  // never be exported. The payment_fields array will contain full credit card numbers!
  $field_blacklist = variable_get('springboard_dw_contact_field_blacklist', array('status', 'theme', 'created', 'edit_url', 'url', 'mail', 'name', 'uid', 'roles'));

  // Extract items in $user that are not already explicitly added to
  // $contact_item. Any custom profile fields that were added to a contact and mapped
  // via the user map will be in the $user data structure.
  $extra_props = array();
  foreach ($user as $key => $value) {
    if (!in_array($key, $field_blacklist) && !array_key_exists($key, $contact_item) && substr($key, 0, 4) != 'sbp_') {
      $extra_props[$key] = $value;
    }
  }

  return $extra_props;
}

/**
 * Map the donation object to a form array formatted for an API call for data warehousing.
 * @param $donation
 * @return array
 */
function springboard_dw_map_form_item($node, $update = False)
{

  // Get the user account details and prep for warehousing (sb_contact)
  $form_item = array();
  $form_item['queue_type'] = 'form';

  // If form data is being passed to update, flag this queue item for an update
  if ($update == True) {
    $form_item['queue_item_update'] = True;
  }

  $form_item['form_id'] = $node->nid;
  $form_item['group_id'] = ''; // Todo: Will come later
  $form_item['form_type'] = $node->type;
  $form_item['name'] = $node->title;
  $form_item['url'] = drupal_get_path_alias('node/' . $node->nid);

  $form_item['created_at'] = $node->created;
  $form_item['updated_at'] = $node->changed;

  // Todo: Add the extra props attributes
  $form_item['extra_props'] = json_encode(array());

  return $form_item;

}

/**
 * Sends an item to the data warehouse receiver app.
 */
function springboard_dw_export_item($item)
{
  // watchdog('springboard data warehouse', 'sending item to the warehouse...');
  if ($item['queue_type'] == 'donation') {
    return springboard_dw_donation($item);
  } elseif ($item['queue_type'] == 'contact') {
    return springboard_dw_contact($item);
  } elseif ($item['queue_type'] == 'form') {
    return springboard_dw_form($item);
  } elseif ($item['queue_type'] == 'advocacy action') {
    return springboard_dw_advocacy_action($item);
  } elseif ($item['queue_type'] == 'advocacy message') {
    return springboard_dw_advocacy_message($item);
  } elseif ($item['queue_type'] == 'petition') {
    return springboard_dw_petition($item);
  } elseif ($item['queue_type'] == 'social action') {
    return springboard_dw_advocacy_action($item);
  } elseif ($item['queue_type'] == 'submission') {
  return springboard_dw_submission($item);
}
  // ... other queues
}

/**
 * Returns a new instance of Guzzle Http client.
 * @return \GuzzleHttp\Client
 */
function springboard_api_client()
{

  // Composer Vendor autoload
  drush_autoload("sites/all/vendor/autoload.php");

  // Load Guzzle client
  $guzzle = new GuzzleHttp\Client(['http_errors' => false]);

  // Return an instance of the client
  return $guzzle;
}

/**
 * Removes the queue type used to distinguish api calls and adds authentication token and client ID to the item params.
 * @param $item
 */
function springboard_api_prep_call($item)
{
  // Remove the queue type from the item
  unset($item['queue_type']);

  // Add the authentication token and client id
  $item['authenticationToken'] = variable_get('authentication_token', NULL);
  $item['sbClientId'] = variable_get('client_id', NULL);

  return $item;
}

/**
 * Returns the endpoint used to make API calls to the data warehouse receiver app.
 */
function springboard_dw_api_endpoint($endpoint)
{
  // TODO: point this to a gospringboard.io subdomain
  return 'http://159.203.115.210/' . ltrim($endpoint, '/');
}

/**
 * Helper function to query the data warehouse table to determine if this item has been recorded as being warehoused already.
 * @param $type
 * @param $drupal_id
 */
function springboard_dw_item_is_warehoused($type, $drupal_id)
{

  // Query items from the data warehouse table that match the item id and type
  $query = db_query("select * from {springboard_data_warehouse} where drupal_id = :drupal_id and type = :type", array(':type' => $type, ':drupal_id' => $drupal_id));

  // If an item is found, we do not need to warehouse this item
  if ($query->rowCount() > 0) {
    return true;
  }

  // If this item is not warehoused, return false
  return false;

}

/**
 * Send a contact record to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_contact($item)
{

  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('contact/create');

  // If the queue item is an update, change the API call accordingly
  if (isset($item['queue_item_update']) && $item['queue_item_update']) {
    $endpoint = springboard_dw_api_endpoint('contact/update');
  }

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // Looks like the api response was good
  if ($res->getStatusCode() == 200) {

    // If the item hasn't been warehoused then this is an insert and we should consider the item tracked in Drupal
    if (!isset($item['queue_item_update']) && !springboard_dw_item_is_warehoused('contact', $item['contact_id'])) {
      // Insert the user account into the Drupal data warehouse table
      db_insert('springboard_data_warehouse')->fields(array(
        'type'      => 'contact',
        'drupal_id' => $item['contact_id'],
        'created'   => time()
      ))->execute();
    }

    return true;

  } else {
    drush_log('Error sending contact API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }

}

/**
 * Send a donation record to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_donation($item)
{

  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('donation/create');

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // If the response is successful, add the user_warehoused parameter to the Drupal user account so we can skip this check in subsequent donations
  if ($res->getStatusCode() == 200) {
    // Insert the user account into the Drupal data warehouse table
    db_insert('springboard_data_warehouse')->fields(array(
      'type'      => 'donation',
      'drupal_id' => $item['donation_id'],
      'created'   => time()
    ))->execute();

    // Respond back successfully to the queue to remove the item
    return true;

  } else {
    drush_log('Error sending donation API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }

}

/**
 * Send a form record to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_form($item)
{

  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('form/create');

  // If the queue item is an update, change the API call accordingly
  if (isset($item['queue_item_update']) && $item['queue_item_update']) {
    $endpoint = springboard_dw_api_endpoint('form/update');
  }

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // Looks like the api response was good
  if ($res->getStatusCode() == 200) {
    //if ($res->getStatusCode() == 200 && $resBody['message'] == 'Successfully created form.') {

    // If the item hasn't been warehoused then this is an insert and we should consider the item tracked in Drupal
    if (!isset($item['queue_item_update']) && !springboard_dw_item_is_warehoused('form', $item['form_id'])) {

      // Insert the user account into the Drupal data warehouse table
      db_insert('springboard_data_warehouse')->fields(array(
        'type'      => 'form',
        'drupal_id' => $item['form_id'],
        'created'   => time()
      ))->execute();
    }

    // Respond back successfully to the queue to remove the item
    return true;

  } else {

    // Log the API error
    drush_log('Error sending form API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }

}

/**
 * Send an advocacy message record to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_advocacy_message($item)
{
  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('message/create');

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  $transaction_server_api_call = springboard_advocacy_api_call();
  $full_message = $transaction_server_api_call->invokeClientMethod('getMessage', $item['message_id']);

  $item = springboard_dw_map_advocacy_message_item($item, $full_message->data[0]);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // Looks like the api response was good
  if ($res->getStatusCode() == 200) {

    // Insert the user account into the Drupal data warehouse table
    db_insert('springboard_data_warehouse')->fields(array(
      'type'      => 'advocacy message',
      'drupal_id' => $item['message_id'],
      'created'   => time()
    ))->execute();

    // Respond back successfully to the queue to remove the item
    return true;

  } else {

    // Log the API error
    drush_log('Error sending message API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }
}

/**
 * Send an advocacy record to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_advocacy_action($item)
{
  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('action/create');

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // Looks like the api response was good
  if ($res->getStatusCode() == 200) {

    // Insert the user account into the Drupal data warehouse table
    db_insert('springboard_data_warehouse')->fields(array(
      'type'      => 'advocacy action',
      'drupal_id' => $item['form_id'],
      'created'   => time()
    ))->execute();

    // Respond back successfully to the queue to remove the item
    return true;

  } else {

    // Log the API error
    drush_log('Error sending form API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }
}

/**
 * Send an advocacy petition record to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_petition($item)
{
  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('action/create');

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // Looks like the api response was good
  if ($res->getStatusCode() == 200) {

    // Insert the user account into the Drupal data warehouse table
    db_insert('springboard_data_warehouse')->fields(array(
      'type'      => 'petition',
      'drupal_id' => $item['form_id'],
      'created'   => time()
    ))->execute();

    // Respond back successfully to the queue to remove the item
    return true;

  } else {

    // Log the API error
    drush_log('Error sending petition/action API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }
}

/**
 * Send a submission to the Springboard data warehouse API.
 * @param $item
 */
function springboard_dw_submission($item)
{
  // Define the endpoint
  $endpoint = springboard_dw_api_endpoint('submission/create');

  // Instantiate an API client instance
  $api_client = springboard_api_client();

  // Clean up the item and add authentication to the form params
  $item = springboard_api_prep_call($item);

  // Attempt Guzzle client request
  $res = $api_client->request('POST', $endpoint, array(
    'form_params' => $item
  ));

  // Response body
  $resBody = json_decode($res->getBody());

  // Looks like the api response was good
  if ($res->getStatusCode() == 200) {

    // Insert the user account into the Drupal data warehouse table
    db_insert('springboard_data_warehouse')->fields(array(
      'type'      => 'submission',
      'drupal_id' => $item['submission_id'],
      'created'   => time()
    ))->execute();

    // Respond back successfully to the queue to remove the item
    return true;

  } else {

    // Log the API error
    drush_log('Error sending submission API call.', 'warning');
    drush_print($endpoint . '?' . http_build_query($item));
    drush_print_r($resBody);

    // Respond back with failure to retry in the queue
    return false;
  }
}


/**
 * Implements hook_cron_queue_info().
 */
function springboard_dw_cron_queue_info()
{
  $queues['springboard_dw_export'] = array(
    'worker callback' => 'springboard_dw_export_item',
    'time'            => 60,
    'skip on cron'    => true,
  );

  return $queues;
}

/**
 * STOLEN FROM drupal_cron_run. Needs improvement.
 * Ideas:
 *  - Add a time argument.
 *  - Add a queue argument (like salesforce queue).
 *  - Make sure this is locked correctly.
 */
function springboard_dw_process_queue()
{
  $callback = 'springboard_dw_export_item';

  $end = time() + 60;

  // Get an instance of the Drupal data warehouse queue
  $queue = DrupalQueue::get('springboard_dw_export');

  // Lock and claim an item for queue processing
  while (time() < $end && ($item = $queue->claimItem())) {

    // If the api responds back correctly, remove the queue item
    if (call_user_func($callback, $item->data)) {
      $queue->deleteItem($item);
    } else {
      // Release the item back onto the queue for retry
      //
      drush_log('Bad API call, releasing item. ', 'warning');
      // drush_print_r($item);
      $queue->releaseItem($item);
      break;
    }

    /*
     * WHAT DO WE BENEFIT WITH USING WATCHDOG EXCEPTION DIRECTLY?
     *
        try {
          $queue->deleteItem($item);

        } catch (Exception $e) {

          // In case of exception log it and leave the item in the queue
          // to be processed again later.
          watchdog_exception('cron', $e);

          // Release the item back onto the queue for retry
          // $queue->releaseItem($item);
        }
    */

  }

}