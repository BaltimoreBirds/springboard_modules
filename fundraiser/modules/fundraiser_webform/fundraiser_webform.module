<?php

/**
 * @file
 * Field management functions for the fundraiser module
 */

/**
 * Implements hook_menu_alter().
 */
function fundraiser_webform_menu_alter(&$items) {
  // Move fundraisers confirmation paths to webform menu paths, for UI.
  $items['node/%node/webform/confirmations'] = $items['node/%node/fundraiser/confirmations'];
  $items['node/%node/webform/confirmations']['type'] = MENU_LOCAL_TASK;
  // Remove fundraiser tab, we don't want it if we're using webform.
  unset($items['node/%node/fundraiser']);
  unset($items['node/%node/fundraiser/confirmations']);
  // Alter some built-in webform menu items.
  $items['node/%webform_menu/webform/configure']['access callback'] = 'fundraiser_webform_configure_access';
  $items['node/%webform_menu/webform/configure']['access arguments'] = array('update', 1);
}

/**
 * Menu access callback. Permission check for donation form settings tab.
 */
function fundraiser_webform_configure_access($perm, $node) {
  // Don't show the 'Form settings' tab on donation forms.
  if (fundraiser_is_donation_type($node->type)) { // From fundraiser.module.
    return FALSE;
  }
  else {
    return node_access($perm, $node);
  }
}

/**
 * Implements hook_node_type_insert().
 */
function fundraiser_webform_node_type_insert($info) {
  if (fundraiser_is_donation_type($info->type)) { // From fundraiser.module.
    webform_node_type('update', $info); // From webform.module.
    // Add as a primary type too.
    $webform_types = webform_variable_get('webform_node_types_primary');
    $webform_types[] = $info->type;
    variable_set('webform_node_types_primary', $webform_types);
  }
}

/**
 * Implements hook_node_type_update().
 */
function fundraiser_webform_node_type_update($info) {
  fundraiser_webform_node_type_insert($info);
}

/**
 * Implements hook_node_type_delete().
 */
function fundraiser_webform_node_type_delete($info) {
  if (fundraiser_is_donation_type($info->type)) { // From fundraiser.module.
    webform_node_type('delete', $info); // From webform.module.
    // Remove as a primary type too.
    $webform_types = webform_variable_get('webform_node_types_primary');
    unset($webform_types[ $info->type] );
    variable_set('webform_node_types_primary', $webform_types);
  }
}

/**
 * Implements hook_webform_submission_presave().
 */
function fundraiser_webform_webform_submission_presave($node, &$submission) {
  // Remove any non-component form fields from the submitted data.
  unset($submission->data['']);
  // Remove senstive form data before the submission is saved to the database.
  if (fundraiser_is_donation_type($node->type)) { // From fundraiser.module.
    $results = _fundraiser_webform_get_components_by_keys($node->nid, array('card_number', 'card_cvv', 'card_expiration_date'));
    foreach ($results as $result) {
      // Set sensitive info to NULL.
      $submission->data[$result->cid]['value'][0] = NULL;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
// Alter the webform component delete form to prevent the deletion of required fundraiser fields
// Why not handle this by removing delete options from the interface? Because edit/delete operations are added at theme layer.
// Unfortunately the theme layer adds the values and immediately renders, negating any chance for us to make changes.
// In order to remove delete properly, we will need a patch in webform addressing this issue.
// TODO look into using preprocess to intercept?
function fundraiser_webform_form_webform_component_delete_form_alter(&$form, &$form_state, $form_id) {
  // Make sure we are dealing with a donation form.
  if (fundraiser_is_donation_type($form['node']['#value']->type)) { // From fundraiser.module.
    // Check vs. required fields to make sure we can't delete them.
    $required_fields = _fundraiser_get_field_keys();
    $cid = $form['component']['#value']['cid'];
    $component = $form['node']['#value']->webform['components'][$cid];
    // Check to see if the form_key is in our required fields array
    if (in_array($component['form_key'], $required_fields)) {
      $message = t('<strong>!name</strong> is a required fundraiser field and cannot be deleted from this form.',
        array('!name' => $component['name']));
      $form['description']['#markup'] = $message;
      unset($form['actions']['submit']);
    }
  }
}

/**
 * Implements hook_form_alter().
 * Alter content type settings to add "Enable fundraiser?" checkbox.
 */
function fundraiser_webform_form_node_type_form_alter(&$form, &$form_state) {
  $form['#submit'][] = 'fundraiser_webform_form_node_type_form_alter_submit';
}

/**
 * Submit callback for fundraiser_webform_form_node_type_form_alter()
 */
function fundraiser_webform_form_node_type_form_alter_submit($form, &$form_state) {
  $is_enabled = $form_state['values']['fundraiser'];
  $webform_node_types = variable_get('webform_node_types', array('webform'));
  $webform_node_types_primary = variable_get('webform_node_types_primary', array('webform'));
  $type = $form_state['values']['type'];
  // Make sure this content type is enabled for webform if not already.
  // Add the selected node types to the webform_node_types_primary so a webform is added by default.
  if ($is_enabled) {
    if (!in_array($type, $webform_node_types)) {
      $webform_node_types = array_merge($webform_node_types, array($type));
    }
    if (!in_array($type, $webform_node_types_primary)) {
      $webform_node_types_primary = array_merge($webform_node_types_primary, array($type));
    }
  }
  // Re-save the variables.
  variable_set('webform_node_types', $webform_node_types);
  variable_set('webform_node_types_primary', $webform_node_types_primary);
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Adds the admin form for webform to the fundraiser settings form.
 */
function fundraiser_webform_form_fundraiser_admin_settings_alter(&$form, &$form_state) {
  if (module_exists('webform_user')) {
    $form['fundraiser_webform'] = array(
      '#type' => 'fieldset',
      '#title' => t('Fundraiser webform'),
      '#description' => t('Configure fundraiser webform settings.'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['fundraiser_webform']['webform_users'] = array(
      '#type' => 'fieldset',
      '#title' => t('Webform user integration'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['fundraiser_webform']['webform_users']['help'] = array(
      '#markup' => '<div>' . t('Webform user creates webform components. Because Fundraiser also creates components for user ' .
      'data we need to avoid doubling up on component creation. Therefore a map of fundraiser components to user profile components ' .
      'needs to be created. This will prevent webform user from creating the same components that fundraiser already handles. ' .
      'For each profile field listed here set which (if any) fundraiser field will handle creating a component for it instead. ' .
      'Fields left unmapped will be created by webform user.').'</div>',
    );
    // If the module exists, we can use it's functions.
    $profile_fields = _webform_user_get_profile_fields();
    $fundraiser_fields = _fundraiser_webform_get_nonfieldset_keys();
    $current_map = variable_get('fundraiser_webform_to_user_map', array('mail' => 'mail'));
    $form['fundraiser_webform']['webform_users']['mapping'] = array(
      '#prefix' => '<div id="webform-user-field-mapping">',
      '#suffix' => '</div>',
      '#tree' => TRUE,
      '#theme' => 'table',
      '#header' => array(t('Profile field'), t('Matching component will be created by this Fundraiser field') ),
      '#rows' => array(),
    );
    $options = array('0' => t('--Not handled by Fundraiser--'));
    foreach ($fundraiser_fields as $field_key => $fundraiser_field) {
      $options[$field_key] = $fundraiser_field['#title'];      
    }
    // Now we just need to note which of these fields map to which fundraiser fields.
    foreach ($profile_fields as $profile_field) {
      $name = $profile_field['name'];
      // Mail is a special case, and should be doubled up on always.
      // It is required by both modules, and field name has been coordinated to match.
      $form['fundraiser_webform']['webform_users']['mapping'][$name] = array(
        '#id' => 'field-' . $name,
        '#type' => 'select',
        '#options' => $options,
        '#default_value' => isset($current_map[$name]) ? $current_map[$name] : '',
      );
      if ($name == 'mail') {
        $form['fundraiser_webform']['webform_users']['mapping'][$name]['#default_value'] = 'mail';
        $form['fundraiser_webform']['webform_users']['mapping'][$name]['#disabled'] = TRUE;
        $form['fundraiser_webform']['webform_users']['mapping'][$name]['#description'] =
          t('Mail field is required by both modules and the field names match by default.');
      }
      $form['fundraiser_webform']['webform_users']['mapping']['#rows'][] = array(
        array('data' => $profile_field['title']),
        array('data' => &$form['fundraiser_webform']['webform_users']['mapping'][$name]), // Pointer is important.
      );
    }
    $form['#submit'][] = 'fundraiser_webform_to_webform_user_map_submit';
  }
}

/**
 * Submit handler for mapping fundraiser fields to webform object objects.
 */
function fundraiser_webform_to_webform_user_map_submit($form, &$form_state) {
  variable_set('fundraiser_webform_to_user_map', $form_state['values']['mapping']);
}

/**
 * Implements hook_webform_user_profile_fields_alter().
 */
function fundraiser_webform_webform_user_profile_fields_alter(&$fields, $node) {
  // ONLY do this for fundraiser nodes. Other nodes that are also webform are to be left alone.
  if (fundraiser_is_donation_type($node->type)) {
    // For every field that fundraiser will be handling the creation, remove it from webform user creation.
    $mapping = variable_get('fundraiser_webform_to_user_map', array('mail' => 'mail'));
    foreach ($fields as $index => $profile_field) {
      $name = $profile_field['name'];
      if (isset($mapping[ $name ]) &&  $mapping[ $name ]) {
        // This field will be created by fundraiser, so we don't need to set it up in webform user.
        unset($fields[$index]);
      }
    }
  }
}

/**
 * Implements hook_form_alter().
 * Why hook_form_alter and not hook_form_FORM_ID_alter? Because webform's form id varies: webform_client_form_NID.
 */
function fundraiser_webform_form_alter(&$form, &$form_state, $form_id) {

  // Alter the webform client form.
  if (strstr($form_id, 'webform_client_form') !== FALSE) {
    // Handle donation form edit submission pg.
    if (fundraiser_is_donation_type($form['#node']->type) && arg(2) == 'submission') { // From fundraiser.module.
      fundraiser_webform_submission_display($form, $form_state);
    }
    // Handle the donation form display.
    if (fundraiser_is_donation_type($form['#node']->type)  && arg(2) != 'submission') { // From fundraiser.module.
      // From fundraiser.module, calls hooks to create form and submission paths.
      fundraiser_donation_form($form, $form_state); // From fundraiser.module.
    }
  }

  // Do not allow users to muck with defined form keys in component editting form.
  // They're named what they're named for a reason and we need those keys to remain unharmed.
  if ($form_id == 'webform_component_edit_form') {
    $node = node_load($form['nid']['#value']);
    if (fundraiser_is_donation_type($node->type)) {
      // Walk array of defined fields to gather keys.
      $preserved_keys = _fundraiser_get_field_keys();
      $form_key = $form['form_key']['#default_value'];
      if (in_array($form_key, $preserved_keys)) {
        $form['form_key']['#access'] = FALSE;
        $form['form_key']['#value'] = $form['form_key']['#default_value'];
      }
    }
  }
  return $form;
}

/**
 * Form, alters the display of webform submissions to prevent edits / display of confusing info.
 */
function fundraiser_webform_submission_display(&$form, &$form_state) {
  // Set up a view only display of the donation amount.
  if ('other' != $form['submitted']['donation']['amount']['#default_value']) {
    $amount = $form['submitted']['donation']['amount']['#default_value'];
  }
  else {
    $amount = $form['submitted']['donation']['other_amount']['#default_value'];
  }
  // Add new fields.
  $form['submitted']['donation']['display_amount'] = array(
    '#markup' => '<div class="form-item"><label>' . t('Donation Amount') .
      ':</label>' . '$' . number_format($amount, 2) . '</div>', // TODO this should be updated for an international audience.
  );
  // Show whether or not it's a recurring donation.
  if (isset($form['submitted']['credit_card_information']['recurs_monthly'])) {
    $recurs = t('No');
    if (isset($form['submitted']['credit_card_information']['recurs_monthly']['#default_value'][0])
      && ($form['submitted']['credit_card_information']['recurs_monthly']['#default_value'][0] == 'recurs')) {
      $recurs = t('Yes');
    }
    $form['submitted']['donation']['recurring'] = array(
      '#markup' => '<div class="form-item"><label>' . t('Recurring Donation?') .
        ':</label>' . $recurs . '</div>',
    );
  }
  // Clean up the donor info section - replace the form fields with read only info
  $form['submitted']['donor_information']['#title'] = t('Donor Information');
  $form['submitted']['donor_information']['first_name_readonly'] = array(
    '#markup' => '<div class="form-item"><label>' . t('First Name') . ':</label>' .
      $form['submitted']['donor_information']['first_name']['#default_value'] . '</div>',
  );
  $form['submitted']['donor_information']['last_name_readonly'] = array(
    '#markup' => '<div class="form-item"><label>' . t('Last Name') . ':</label>' .
      $form['submitted']['donor_information']['last_name']['#default_value'] . '</div>',
  );
  $form['submitted']['donor_information']['email_readonly'] = array(
    '#markup' => '<div class="form-item"><label>' . t('Email') . ':</label>' .
      $form['submitted']['donor_information']['mail']['#default_value'] . '</div>',
  );
  $form['submitted']['donor_information']['first_name']['#prefix'] =
    $form['submitted']['donor_information']['last_name']['#prefix'] =
      $form['submitted']['donor_information']['mail']['#prefix'] = '<div style="display:none">';
  $form['submitted']['donor_information']['first_name']['#suffix'] =
    $form['submitted']['donor_information']['last_name']['#suffix'] =
      $form['submitted']['donor_information']['mail']['#suffix'] = '</div>';
  // Remove sections no one really needs to see here.
  unset($form['submitted']['donation']['amount']);
  unset($form['submitted']['donation']['other_amount']);
  unset($form['submitted']['credit_card_information']);
}

/**
 * Implements hook_fundraiser_get_form_field().
 */
function fundraiser_webform_fundraiser_get_form_field($form, $field_key) {
  // Walks a given form looking for the given key. Returns it when found.
  return _fundraiser_webform_find_field($form, _fundraiser_webform_parse_component($form['#node']->nid, $field_key));
}

/**
 * Implements hook_fundraiser_update_form_field().
 */
function fundraiser_webform_fundraiser_update_form_field($form, $field_key, $new_field) {
  // Walks a given form looking for the given key. Returns it when found.
  $field =& _fundraiser_webform_find_field($form, _fundraiser_webform_parse_component($form['#node']->nid, $field_key));
  // Update the field in the form.
  $field = $new_field;
  // Return the form for the calling function.
  return $form;
}

/**
 * Implements hook_fundraiser_donation_form().
 */
function fundraiser_webform_fundraiser_donation_form($form, $form_state) {
  // Grab the node.
  $node = node_load($form['#node']->nid);

  // Create a data structure that will tell us exactly where each webform component lives in the FAPI array.
  $components = $node->webform['components'];
  $component_hierarchy = _fundraiser_webform_parse_components($node->nid, $components);

  // Add js and css as needed.
  $base = drupal_get_path('module', 'fundraiser_webform');
  drupal_add_js( $base . '/js/jquery.alphanumeric.js', 'file');
  drupal_add_js( $base . '/js/fundraiser.js', 'file');
  drupal_add_css( $base . '/css/fundraiser-donation-form.css', 'file');

  // Modify form displays according to callback settings.
  $form['#calling_module'] = 'fundraiser_webform';
  fundraiser_display_form_fields('fundraiser_webform', $form, $form_state);

  // Combine expiration month and year into a single component.
  $cc_exp_month_field =& _fundraiser_webform_find_field($form, $component_hierarchy['card_expiration_month']);
  $cc_exp_year_field =& _fundraiser_webform_find_field($form, $component_hierarchy['card_expiration_year']);
  $cc_info_field =& _fundraiser_webform_find_field($form, $component_hierarchy['credit_card_information']);
  $cc_exp_month_field['#default_value'] = date('n');
  $cc_exp_year_field['#default_value'] = date('Y');

  // Make sure the year field always has a good range of years.
  $this_year = date('Y');
  $years = array($this_year => $this_year);
  for ($i = 1; $i <= 10; $i++) { // Up to 10 years out.
    $years[$this_year + $i] = $this_year + $i;
  }
  $cc_exp_year_field['#options'] = $years;

  // Check to see if the credit card information fieldset still exists because it may have been removed.
  if (is_array($cc_info_field)) {
    $cc_info_field['expiration_date'] = array();
    $cc_info_field['expiration_date']['card_expiration_month'] = $cc_exp_month_field;
    $cc_info_field['expiration_date']['card_expiration_year'] = $cc_exp_year_field;
    $cc_info_field['expiration_date']['#weight'] = isset($cc_exp_month_field['#weight']) ? $cc_exp_month_field['#weight'] : 0;
    $cc_info_field['expiration_date']['#theme'] = 'fundraiser_credit_card_expiration_date';
  }
  else {
    // Add the new expiration_date directly to the form with the same weight as the cc_exp_month field.
    $form['expiration_date'] = array();
    $form['expiration_date']['card_expiration_month'] = $cc_exp_month_field;
    $form['expiration_date']['card_expiration_year'] = $cc_exp_year_field;
    $form['expiration_date']['#weight'] = $cc_exp_month_field['#weight'];
    $form['expiration_date']['#theme'] = 'fundraiser_credit_card_expiration_date';
  }
  // Remove old fields from form layout after moving them to their new location.
  $cc_exp_month_field = NULL;
  $cc_exp_year_field = NULL;

  // And lastly add a user facing message for submit.
  $form['submit']['#suffix'] = '<div class="fundraiser_submit_message">' .
    theme('image', array('path' =>  drupal_get_path('module', 'fundraiser_webform') . '/images/padlock.gif' )) .
    t('By clicking SUBMIT DONATION your credit card will be securely processed.') .
    '</div>';

  // Add a submit handler in advance of the webform_client_form_submit to cleanup after our move.
  // This handler moves the expiration date stuff back where webform expects it to be.
  // Important: It needs to run before webform runs, so it's getting put at the front of the array.
  array_unshift($form['#submit'], '_fundraiser_webform_pre_submit_cleanup');
  return $form;
}

/**
 * Submit callback, this moves the expiration month and year back into the structure where they
 * are expected, and removes 'expiration_date' from the list. If 'expiration_date' remained in the
 * submission, webform will try to look up a cid for it and reference it as if the component exists.
 * (Aka: there's no check to make sure a cid was recieved before acting on it.
 * So: We put everything back after we're done so that webform never knows the difference.
 */
function _fundraiser_webform_pre_submit_cleanup($form, &$form_state) {
  $form_state['values']['submitted']['credit_card_information']['card_expiration_month'] =
      $form_state['values']['submitted']['credit_card_information']['expiration_date']['card_expiration_month'];
  $form_state['values']['submitted']['credit_card_information']['card_expiration_year'] =
      $form_state['values']['submitted']['credit_card_information']['expiration_date']['card_expiration_year'];
  // Remove 'expiration_date' so webform doesn't get confused when it tries to process.
  unset($form_state['values']['submitted']['credit_card_information']['expiration_date']);
}

/**
 * Implements hook_fundraiser_donation_validate().
 */
function fundraiser_webform_fundraiser_donation_validate($form, $form_state) {
  // Submission fields are keyed according to the fields in fundraiser_field_info().
  $submission_fields = _fundraiser_webform_submission_flatten($form['#node']->nid, $form_state['values']['submitted']);
  $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields); // From fundraiser.module.

  // Create watchdog entry on validation errors.
  if ($errors) {
    $message = "The following donation form fields failed local validation:\n\n";
    $check_errors = form_get_errors();
    $validation_errors = is_array($check_errors) ? array_keys($check_errors) : array();
    foreach ($validation_errors as $field) {
      $keys = explode('][', $field);
      $message .= array_pop($keys) . "\n";
    }

    // SCRUB DATA. We do not want to save these in the error watchdog message.
    // We can be sure these fields are in the set, since they're declared in fundraiser.
    $submission_fields['card_number'] = substr_replace($submission_fields['card_number'],
      str_repeat('*', drupal_strlen($submission_fields['card_number'])), 0);
    $submission_fields['card_cvv'] = substr_replace($submission_fields['card_cvv'],
      str_repeat('*', drupal_strlen($submission_fields['card_cvv'])), 0);

    $message .= "\n\nSubmitted Values:\n\n";
    foreach ($submission_fields as $key => $value) {
      $message .= $key . ': ' . $value . "\n";
      watchdog('fundraiser_webform', $message, NULL, WATCHDOG_DEBUG, NULL);
    }
    // Provide data to fundraiser about the node that failed to validate.
    $errors = array();
    $errors['nid'] = $form_state['values']['details']['nid'];
    return $errors; // So fundraiser can pick up on the failure.
  }
}

/**
 * Implements hook_fundraiser_donation_submit().
 */
function fundraiser_webform_fundraiser_donation_submit($form, $form_state, $donation) {
  // Given the set of fields defined in fundraiser, gab results here that match those fields.
  // Since we used the fundraiser_field_info keys to generate our webform components with the same form keys
  // And we prevent those values from being overwritten, we can pass the results as an automatic map between the two.
  // Other modules will have to be more particular.
  $submission_fields = _fundraiser_webform_submission_flatten($form['#node']->nid, $form_state['values']['submitted_tree']);
  $donation->donation = $submission_fields;
  $donation->sid = $form_state['values']['details']['sid'];
}

/**
 * Implements hook_fundraiser_donation_post_submit().
 */
function fundraiser_webform_fundraiser_donation_post_submit($form, $form_state, $donation) {
  // Handle behavior if it was a failure.
  if (!isset($donation->result['success']) || (isset($donation->result['success']) && $donation->result['success'] == FALSE) ) {
    // Tell webform we're not done and rebuild the form.
    unset($form_state['values']['details']['sid']);
    if (!isset($donation->result['message']) || empty($donation->result['message'])) {
      $donation->result['message'] = t('Your card has been denied. Please try another.');
    }
    form_set_error('card_number', $donation->result['message']);
    $form_state['values']['details']['finished'] = 0;
    $form_state['rebuild'] = TRUE;
  }
  return $form_state;
}

/**
 * Implements hook_fundraiser_get_fundraiser_alter().
 */
function fundraiser_webform_fundraiser_get_fundraiser_alter($fundraiser) {
  // Get the webform data for this node. This overrides the saved amount values in fundraiser itself.
  // Add the amount_values for the fundraiser information on load.
  if (is_numeric($fundraiser->nid)) {
    $amounts = _fundraiser_webform_get_extra_by_key($fundraiser->nid, 'amount');
    if (isset($amounts['items'])) {
      $amounts = preg_split('/\n/', trim($amounts['items']));
      $amounts = array_unique($amounts);
      $donation_amounts = array();
      for ($i = 0; $i < count($amounts); ++$i) {
        $donation_amounts[] = explode('|', $amounts[$i]);
      }
      $fundraiser->donation_amounts = $donation_amounts;
    }
  }
}

/**
 * Implements hook_fundraiser_create_fundraiser_alter().
 */
function fundraiser_webform_fundraiser_create_fundraiser_alter($fundraiser) {
  // Construct an array of donation amounts.
  $donation_amounts = array();
  if (isset($fundraiser->donation_amounts)) {
    $amount_sets = explode(',', $fundraiser->donation_amounts);
    $amount_sets = array_unique($amount_sets);
    foreach ($amount_sets as $amount_set) {
      $amount_set = explode('|', $amount_set);
      if (count($amount_set) == 2) {
        $donation_amounts[$amount_set[0]] = $amount_set[1];
      }
    }
    ksort($donation_amounts, SORT_NUMERIC);
  }
  $fundraiser->donation_amounts = $donation_amounts;
  // Create the components for the fundraiser, amount and otherwise.
  _fundraiser_webform_update_components($fundraiser);
}

/**
 * Implements hook_fundraiser_update_fundraiser_alter().
 */
function fundraiser_webform_fundraiser_update_fundraiser_alter($fundraiser) {
  // Construct an array of donation amounts.
  $donation_amounts = array();
  if (isset($fundraiser->donation_amounts)) {
    $amount_sets = explode(',', $fundraiser->donation_amounts);
    $amount_sets = array_unique($amount_sets);
    foreach ($amount_sets as $amount_set) {
      $amount_set = explode('|', $amount_set);
      if (count($amount_set) == 2) {
        $donation_amounts[$amount_set[0]] = $amount_set[1];
      }
    }
    ksort($donation_amounts, SORT_NUMERIC);
  }
  $fundraiser->donation_amounts = $donation_amounts;
  // Update the amount components for the fundraiser.
  _fundraiser_webform_update_components($fundraiser);
}

/**
 * Implements hook_fundraiser_field_info_alter().
 */
function fundraiser_webform_fundraiser_field_info_alter($fields) {
  $email_map = array('amount', 'other_amount', 'first_name', 'last_name', 'mail', 'address', 'address_line_2',
    'city', 'zip', 'country', 'state');
  foreach (element_children($fields) as $key) {
    $fields[$key] = _fundraiser_webformfundraiser_field_info_alter($key, $fields[$key], $email_map);
  }
  return $fields;
}

/**
 * Handles recursion for fundraiser_sustainersfundraiser_field_info_alter().
 */
function _fundraiser_webformfundraiser_field_info_alter($field_key, $field, $map) {
  if (in_array($field_key, $map)) {
    $field['#email'] = 1;
  }
  // Check for children. Recursion occurs here.
  foreach (element_children($field) as $key) {
    $field[$key] = _fundraiser_webformfundraiser_field_info_alter($key, $field[$key], $map);
  }
  return $field;
}

/**
 * Helper functions below.
 */

/**
 * Helper function, flatten webforms submitted tree into an array mapping fields to values.
 * Technically this isn't fully flat, so much as it puts values for all defiend fields at the top level.
 * There is still nesting for field sets going on.
 */
function _fundraiser_webform_submission_flatten($nid, $submit_tree, $submission_keys = NULL, $fieldset_keys = NULL) {
  if ($submission_keys == NULL) {
    $components = _fundraiser_webform_get_components_by_nid($nid);
    foreach ($components as $component) {
      if ($component->type != 'fieldset') {
        $submission_keys[] = $component->form_key;
      }
    }
  }
  $flat_array = array();
  foreach ($submit_tree as $key => $value) {
    $flat_array[$key] = $value;
    if (is_array($value)) {
      $flat_array = array_merge($flat_array, _fundraiser_webform_submission_flatten($nid, $value, $submission_keys, $fieldset_keys));
    }
  }
  // Filter to only submission key results.
  $flat_array = array_intersect_key($flat_array, array_combine($submission_keys, $submission_keys));
  return $flat_array;
}

/**
 * Helper function.
 * Creates a nested array of where components exist in the FAPI array for all components in a webform.
 * This is needed because the webform module allows the user to move components around. Therefore
 * we must be able to find them if they are not in their usual spot.
 */
function _fundraiser_webform_parse_components($nid, $components, $reset = FALSE) {
  $component_hierarchy = array();
  foreach ($components as $cid => $component) {
    $component_path = 'submitted[' . implode('][', _fundraiser_webform_walk_component_hierarchy($nid, $cid, $reset)) . ']';
    parse_str($component_path, $output); // Convert string to a nested array.
    $component_hierarchy[$component['form_key']] = $output;
  }
  return $component_hierarchy;
}

/**
 * Helper function. Creates a nested array of where a component exists in the FAPI array.
 */
function _fundraiser_webform_parse_component($nid, $form_key, $reset = FALSE) {
  $results = _fundraiser_webform_get_components_by_keys($nid, array($form_key));
  foreach ($results as $result) {
    $cid = $result->cid;
  }
  $component_path = 'submitted[' . implode('][', _fundraiser_webform_walk_component_hierarchy($nid, $cid, $reset)) . ']';
  parse_str($component_path, $output); // Convert string to a nested array.
  return $output;
}

/**
 * Helper function.
 * Builds a path from the webform component to it's topmost parent.
 * Recursion is here. Be careful.
 */
function _fundraiser_webform_walk_component_hierarchy($nid, $cid, $reset = FALSE, &$path = array()) {
  // Store all the components for this node in a static cache to reduce the number of duplicated database hits.
  static $component_hierarchy = array();
  if (empty($component_hierarchy[$nid]) || $reset == TRUE) {
    $component_hierarchy[$nid] = array();
    $results = _fundraiser_webform_get_components_by_nid($nid);
    foreach ($results as $data) {
      $this_cid = $data->cid;
      $component_hierarchy[$nid][$this_cid][] = $data;
    }
  }
  // Build a path from the webform component to its topmost parent.
  if (isset($component_hierarchy[$nid][$cid])) {
    foreach ($component_hierarchy[$nid][$cid] as $data) {
      array_unshift($path, $data->form_key);
      if ($data->pid > 0) {
        _fundraiser_webform_walk_component_hierarchy($nid, $data->pid, FALSE, $path);
      }
    }
  }
  return $path;
}

/**
 * Helper function, returns a reference to an element of a FAPI array based on a known path.
 * This returns a reference to the form variable, allowing for manipulation into the form array.
 */
function &_fundraiser_webform_find_field(&$form, $path) {
  foreach (array_keys($path) as $v) {
    if (is_array($path[$v]) && count($path[$v])) {
      // Recurse if there are more keys.
      return _fundraiser_webform_find_field($form[$v], $path[$v]);
    }
    else {
      return $form[$v];
    }
  }
}

/**
 * Helper function, creates all donation specific webform components
 */
function _fundraiser_webform_update_components($fundraiser) {
  // Poll other modules for the information they would normally provide to the donation form.
  $fields = fundraiser_field_info();
  // Start creating fields based on the component.
  $components = array();
  $child_weight = 0;
  foreach ($fields as $field_key => $field) {
    _fundraiser_webform_update_component($fundraiser, $field_key, $field, 0, $child_weight);
    $child_weight++;
  }
}

/**
 * Helper function, handles recursion for _fundraiser_webform_update_components().
 */
function _fundraiser_webform_update_component($fundraiser, $field_key, $field, $pid = 0, $weight = 0) {
  // Include the webform module that allows components to be created.
  module_load_include('inc', 'webform', 'includes/webform.components');
  // Tweak the field with a callback as needed.
  if (isset($field['#create_callback']) && function_exists($field['#create_callback'])) {
    $field = call_user_func($field['#create_callback'], $fundraiser, $field);
  }
  if (empty($field) || $field === FALSE) {
    // The submit callback has the option of returning nothing to cancel creating the field, or to delete it.
    if ($field === FALSE) {
      // Delete the field.
      _fundraiser_webform_delete_component($fundraiser->nid, $field_key);
      // We do NOT use a standard webform_component_delete here. That's a recursive and submission destructive act.
      //webform_component_delete($fundraiser, $component); //START
    }
    // If so, return to skip.
    return;
  }
  if (!isset($field['#type'])) {
    drupal_set_message(t('Error in creating component: %field', array('%field' => print_r($field, TRUE))));
    return;
  }
  // Check if empty.
  if (!empty($field)) {
    // Create the field array.
    $component = array();
    $component['nid'] = $fundraiser->nid;
    $component['pid'] = $pid;
    $component['form_key'] = $field_key;
    $component['name'] = isset($field['#title']) ? $field['#title'] : '';
    if (isset($field['#value'])) {
      $component['value'] = $field['#value'];
    }
    $component['type'] = isset($field['#type']) ? $field['#type'] : '';
    $component['extra'] = isset($field['#extra']) ? $field['#extra'] : array('description' => '');
    $component['mandatory'] = isset($field['#required']) ? $field['#required'] : '';
    $component['email'] = isset($field['#email']) ? 1 : 0;
    if (isset($field['#profile_map'])) {
      $component['maps_to'] = $field['#profile_map'];
    }
    $component['weight'] = $weight;

    // Now that the array has been created, with all the right create callbacks. Figure out if we're updating or inserting.
    $orig_field = _fundraiser_webform_get_component_by_nid_key($fundraiser->nid, $component['form_key']);
    if (isset($orig_field->cid) && !empty($orig_field->cid)) {
      $pid = $orig_field->cid;
      $component = array_merge((array) $orig_field, (array) $component);
      webform_component_update($component);
    }
    else {
      $pid = webform_component_insert($component);
    }

    // Check for children. Recursion occurs here.
    $child_weight = 0;
    foreach (element_children($field) as $key) {
      _fundraiser_webform_update_component($fundraiser, $key, $field[$key], $pid, $child_weight);
      $child_weight++;
    }
  }
}

/**
 * Helper function, given the array from field_info - get the listed fields for NON fieldset fields, flattened.
 * WARNING: Recursion is here to walk the field info array to gather form keys.
 */
function _fundraiser_webform_get_nonfieldset_keys($field_info = NULL, $fields = array()) {
  if ($field_info == NULL) {
    $field_info = fundraiser_field_info();
  }
  $children = element_children($field_info);
  foreach ($children as $child) {
    // If this child is a defined field, but not a fieldset, add it.
    if (isset($field_info[$child]['#title']) && $field_info[$child]['#type'] != 'fieldset') {  
      $fields[$child] = $field_info[$child];
    }
    if (is_array($field_info[$child]) && !empty($field_info[$child])) {
      $fields = _fundraiser_webform_get_nonfieldset_keys($field_info[$child], $fields);
    }
  }
  return $fields;
}

/**
 * DB functions.
 */

/**
 * DB function, given a nid and field key, get and *unserialize* the extra field from webform component.
 */
function _fundraiser_webform_get_extra_by_key($nid, $form_key) {
  $results = _fundraiser_webform_get_component_by_nid_key($nid, $form_key);
  if ($results) {
    return unserialize($results->extra);
  }
  return FALSE;
}

/**
 * DB function, get webform component form elements.
 */
function _fundraiser_webform_get_components_by_nid($nid) {
  return db_query('SELECT * FROM {webform_component} ' .
    'WHERE nid = :nid',
    array(':nid' => $nid))->fetchAll();
}

/**
 * DB function, select webform component given node, form key info.
 */
function _fundraiser_webform_get_component_by_nid_key($nid, $form_key) {
  return db_query('SELECT * FROM {webform_component} ' .
    'WHERE nid = :nid ' .
    'AND form_key = :form_key',
    array(':nid' => $nid, ':form_key' => $form_key))->fetchObject();
}

/**
 * DB function, get webform component form elements.
 */
function _fundraiser_webform_get_components_by_keys($nid, $form_keys) {
  if (!is_array($form_keys)) {
    $form_keys = array($form_keys);
  }
  return db_query('SELECT * FROM {webform_component} ' .
    'WHERE nid = :nid ' .
    'AND form_key IN (:form_keys)',
    array(':nid' => $nid, ':form_keys' => $form_keys))->fetchAll();
}

/**
 * DB function, delete webform component given node, form key info.
 */
function _fundraiser_webform_delete_component($nid, $form_key) {
  db_delete('webform_component')
    ->condition('nid', $nid)
    ->condition('form_key', $form_key)
    ->execute();
}

/**
 * DB function, get webform component form elements.
 */
function _fundraiser_webform_get_amount_count($nid) {
  $results = db_query('SELECT COUNT(nid) as count FROM {webform_component} ' .
    'WHERE nid = :nid ' .
    'AND form_key LIKE \'amount\' ' .
    'AND type = \'select\'',
    array(':nid' => $nid));
  foreach ($results as $result) {
    return $result->count;
  }
}
