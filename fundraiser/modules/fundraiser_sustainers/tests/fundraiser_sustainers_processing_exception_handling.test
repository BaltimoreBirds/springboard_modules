<?php
/**
 * @file
 * Fundraiser sustainer tests for failed sustainer processing.
 */

/**
 *
 */
class FundraiserSustainersProcessingExceptionHandlingTestCase extends FundraiserSetup {

  /**
   * The donation form.
   *
   * @var stdClass
   */
  protected $node;

  /**
   * The credit card expiration date.
   *
   * @var \DateTime
   */
  protected $expiration;

  /**
   * Implements getInfo(). Declares this test class to fundraiser testing.
   */
  public static function getInfo() {
    return array(
      'name' => 'Fundraiser sustainers processing exception handling',
      'description' => 'Tests fundraiser sustainers failed processing.',
      'group' => 'Fundraiser Sustainers',
    );
  }

  /**
   * Implements setUp().
   */
  public function setUp($additional_modules = array()) {
    $additional_modules[] = 'fundraiser_sustainers';
    parent::setUp($additional_modules);

    $this->node = $this->createDonationForm();
    $this->expiration = new DateTime('now +3 months');
  }

  /**
   *
   */
  public function testExceptionHandling() {
    $series = array();

    // For some reaosn I get a 403 when I first visit this, but a 200
    // all other times.
    $this->drupalGet('node/' . $this->node->nid);

    for ($i = 0; $i < 1; $i++) {
      $this->submitRecurringDonation($this->node->nid, $this->expiration);
      $master_did = $this->getMaxMasterDid();
      $series[$i] = array(
        'master_did' => $master_did,
        'advance_did' => $this->advanceCharge($master_did),
      );
    }

    $this->runFundraiserCron();

    $checks = new FundraiserSustainersHealthChecks();
    $results = $checks->checkStuckSustainers();
    $this->assertTrue(empty($results), 'No stuck sustainers found.');

    foreach ($series as $thing) {
      $this->assertDonationIsSuccessfullyProcessed($thing['advance_did']);
    }

    foreach ($series as $i => $thing) {
      $series[$i]['advance_did'] = $this->advanceCharge($series[$i]['master_did']);
    }

//    debug($series);
//    debug(_fundraiser_sustainers_cron_get_recurring());
//    fundraiser_sustainers_process_recurring_donations();
//    db_query("DELETE FROM {commerce_order} WHERE order_id = :did", array(':did' => $series[1]['advance_did']));

//    debug(db_query("SELECT * FROM {fundraiser_sustainers}")->fetchAllAssoc('did'));



    $limit = 200;
    $now = strtotime('now');
    $max_processing_attempts = variable_get('fundraiser_sustainers_max_processing_attempts', 3);
    // Lock them (faster to lock, then query, than the other way around).
    // Since large data set returns => delay.
    $donations = db_query('SELECT r.did FROM {fundraiser_sustainers} r ' .
      'WHERE (r.gateway_resp IS NULL OR r.gateway_resp = :status) ' .
      'AND r.next_charge < :now ' .
      'AND (r.attempts < :max_attempts OR r.attempts IS NULL) ' . // If already been tried X times, Stop Trying.
      'AND r.lock_id = 0 ' . // And not locked.
      'LIMIT 0, ' . $limit,
      array(':status' => FUNDRAISER_SUSTAINERS_RETRY_STATUS, ':now' => $now, ':max_attempts' => $max_processing_attempts)
    )->fetchAllKeyed(0, 0);
    debug($donations);



    $this->runFundraiserCron();



    $limit = 200;
    $now = strtotime('now');
    $max_processing_attempts = variable_get('fundraiser_sustainers_max_processing_attempts', 3);
    // Lock them (faster to lock, then query, than the other way around).
    // Since large data set returns => delay.
    $donations = db_query('SELECT r.did FROM {fundraiser_sustainers} r ' .
      'WHERE (r.gateway_resp IS NULL OR r.gateway_resp = :status) ' .
      'AND r.next_charge < :now ' .
      'AND (r.attempts < :max_attempts OR r.attempts IS NULL) ' . // If already been tried X times, Stop Trying.
      'AND r.lock_id = 0 ' . // And not locked.
      'LIMIT 0, ' . $limit,
      array(':status' => FUNDRAISER_SUSTAINERS_RETRY_STATUS, ':now' => $now, ':max_attempts' => $max_processing_attempts)
    )->fetchAllKeyed(0, 0);
    debug($donations);



    $this->assertDonationIsSuccessfullyProcessed($series[0]['advance_did']);
//    $this->assertDonationIsNotSuccessfullyProcessed($series[1]['advance_did']);
//    $this->assertDonationIsSuccessfullyProcessed($series[2]['advance_did']);
//
//    $this->assertWatchdogContains('Exception thrown while processing a sustainer');
//
//    $checks = new FundraiserSustainersHealthChecks();
//    $results = $checks->checkStuckSustainers();
//    $dids = explode(',', $results['variables']['%dids']);
//    $this->assertEqual(count($dids), 1, 'One stuck sustainer found.');
//    $this->assertEqual($dids[0], $series[1]['advance_did'], 'The correct donation ID is the stuck sustainer.');

    debug(db_query("SELECT * FROM {fundraiser_sustainers}")->fetchAllAssoc('did'));
  }

  protected function getMaxMasterDid() {
    return db_query("SELECT max(master_did) FROM {fundraiser_sustainers}")->fetchField();
  }

  protected function advanceCharge($master_did) {
    $did = db_query("SELECT MIN(did) FROM {fundraiser_sustainers} WHERE master_did = :master_did AND lock_id = 0 AND gateway_resp IS NULL", array(':master_did' => $master_did))
      ->fetchField();

//    db_query("UPDATE {fundraiser_sustainers} SET next_charge = 100, attempts = 0, gateway_resp = NULL, lock_id = 0 WHERE did = :did", array(':did' => $did));

    $recurring = array(
      'did' => $did,
      'new_state' => 'scheduled',
      'next_charge' => REQUEST_TIME - 10,
    );

    _fundraiser_sustainers_update_recurring($recurring);

    return $did;
  }

  protected function runFundraiserCron() {
    $this->drupalGet('fundraiser_cron');
  }

  protected function assertDonationIsSuccessfullyProcessed($did) {
    $donation = fundraiser_donation_get_donation($did);
    debug($donation->did . ' ' . $donation->recurring->gateway_resp . ' ' . $donation->recurring->next_charge, 'donation');
    $this->assertEqual($donation->recurring->gateway_resp, 'success', 'Donation is successfully processed.');
  }

  protected function assertDonationIsNotSuccessfullyProcessed($did) {
    $donation = fundraiser_donation_get_donation($did);

    $this->assertNotEqual($donation->recurring->gateway_resp, 'success', 'Donation is not successfully processed.');
  }

  protected function assertWatchdogContains($message) {
    // Login the admin user.
    $this->drupalLogin($this->drupalCreateUser(array('access site reports')));
    // View the database log report.
    $this->drupalGet('admin/reports/dblog');
    $this->assertResponse(200);

    // After filter_xss(), HTML entities should be converted to their character
    // equivalents because assertLink() uses this string in xpath() to query the
    // Document Object Model (DOM).
    $this->assertLink($message);
  }
}
