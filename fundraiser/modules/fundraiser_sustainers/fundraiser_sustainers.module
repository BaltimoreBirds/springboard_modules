<?php

/**
 * @file
 * Sustainer page callbacks for the fundraiser module.
 *
 * Why? Footprint again. Not all sites need recurring / sustainer maintained fundraising.
 * (Use this module to model behavior and actions for peer-to-peer and other fundraiser types.)
 */

/**
 * Implements hook_cron().
 */
function fundraiser_sustainers_cron() {
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    return 0;
  }
  else {
    watchdog('fundraiser_cron', 'Standard cron run.', NULL, WATCHDOG_INFO);
    fundraiser_sustainer_standalone_cron();
  }
}

/**
 * Implements hook_permission().
 */
function fundraiser_sustainers_permission() {
  return array(
    'cancel future donations' => array(
      'title' => t('Cancel future donations'),
      'description' => t('Cancel future donations.'),
    ),
    'administrate recurring donations' => array(
      'title' => t('Administrate recurring donations'),
      'description' => t('Administrate recurring donations.'),
    ),
    'fastforward recurring donations' => array(
      'title' => t('Fastforward recurring donations'),
      'description' => t('Fastforward recurring donations.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_sustainers_menu() {
  // Add the cron handler if it's enabled.
  $items['fundraiser_cron'] = array(
    'page callback' => 'fundraiser_sustainer_standalone_cron',
    'access callback' => 'fundraiser_sustainers_standalone_cron_access',
    'type' => MENU_CALLBACK,
  );
  // User interface.
  $items['user/%user/recurring_overview'] = array(
    'title' => 'My recurring donations',
    'page callback' => 'fundraiser_sustainers_user_overview',
    'page arguments' => array(1),
    'access callback' => '_fundraiser_sustainers_user_has_recurring_donations',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['user/%user/recurring_overview/%'] = array(
    'title' => 'My recurring donations',
    'page callback' => 'fundraiser_sustainers_edit',
    'page arguments' => array(1, 3),
    'access callback' => '_fundraiser_sustainers_user_has_recurring_donations',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['fundraiser_sustainers/ffwd/%'] = array(
    'title' => 'Charge recurring donation now',
    'page callback' => 'fundraiser_sustainers_charge_now',
    'page arguments' => array(2),
    'access arguments' => array('fastforward recurring donations'),
    'type' => MENU_CALLBACK,
  );
  // Admin interface.
  $items['admin/config/system/fundraiser/recurring'] = array(
    'title' => 'Recurring donations',
    'page callback' => 'fundraiser_sustainers_admin',
    'access arguments' => array('administrate recurring donations'),
    'file' => 'fundraiser_sustainers.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/system/fundraiser/recurring/%'] = array(
    'title' => 'View donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_CALLBACK,
    'tab_parent' => 'admin/config/system/fundraiser/recurring',
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/view'] = array(
    'title' => 'View donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/edit'] = array(
    'title' => 'Edit donation',
    'page callback' => 'fundraiser_sustainers_admin_edit',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  // If Ubercart exists. Show these as a tab there as well.
  if (module_exists('uc_order')) {
    $items['admin/store/orders/%/recurring'] = array(
      'title' => 'Recurring donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/recurring'] = array(
      'title' => 'View donation set',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/edit'] = array(
      'title' => 'Edit donation set',
      'page callback' => 'fundraiser_sustainers_admin_edit',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'file' => 'fundraiser_sustainers.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }
  return $items;
}

/**
 * Access callback for running standalone cron.
 */
function fundraiser_sustainers_standalone_cron_access() {
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Menu access callback, check if the order has recurring orders (as master id).
 */
function fundraiser_sustainers_check_access($did) {
  // First check if this even has a recurring donation.
  $donations = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  if (!$donations) {
    return FALSE;
  }
  // Then check if the user is allowed.
  return user_access('administrate recurring donations');
}

/**
 * Menu callback function, determines if a user has any recurring donations.
 */
function _fundraiser_sustainers_user_has_recurring_donations($user) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Menu callback for the standalone cron.
 */
function fundraiser_sustainer_standalone_cron() {
  // Process recurring donations.
  if (fundraiser_sustainers_processor_key_match()) {
    fundraiser_sustainers_process_recurring_donations();
  }
  else {
    $message = t('The fundraiser sustainer key has not been configured correctly. Recurring donations will not be processed.');
    drupal_set_message($message, 'warning');
    watchdog('fundraiser_cron', $message, NULL, WATCHDOG_CRITICAL);
  }
}

/**
 * Menu callback to ffwd a charge (for testers).
 */
function fundraiser_sustainers_charge_now($did) {
  // Given a did, update the charge date to now.
  $donation->did = $did;
  $donation->next_charge = strtotime('now');
  _fundraiser_sustainers_update_recurring($donation);
  drupal_set_message(t('The charge date for donation #@did has been advanced to @date. It will be charged on the next Fundraiser cron.',
    array('@did' => $did, '@date' => format_date(strtotime('now')) )));
  // Afterwards return where we came from.
  drupal_goto( drupal_get_destination() );
}

/**
 * Implemenation of hook_mail().
 */
function fundraiser_sustainer_mail($key, &$message, &$params) {
  switch ($key) {
    case 'fundraiser_cc_notification':
      $message['subject'] = variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire');
      $message['body'] = $params['fundraiser_sustainers_body'];
      break;
  }
}

/**
 * Implements hook_fundraiser_donation_delete().
 */
function fundraiser_sustainers_fundraiser_donation_delete($donation) {
  if ($donation->donation['recurs_monthly'] == TRUE) {
    // If a recurring donation has been cancelled, we should drop it out of the recurring table.
    _fundraiser_sustainers_delete_recurring($donation->did);
  }
}

/**
 * Helper function, kick off recurring donations for payment. Called on cron usually.
 */
function fundraiser_sustainers_process_recurring_donations() {
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_recurring');
  $successes = 0;
  $fails = 0;
  $donations = _fundraiser_sustainers_cron_get_recurring();
  // Loop over the found orders
  foreach ($donations as $recurring) {
    // Get the donation information that we need.
    $donation = fundraiser_donation_get_donation($recurring->did);
    // Then go through each one of these to charge.
    // Since we already created the donation (and saved any CC info at that time).
    // All we need to do is process it and respond afterwards as needed.
    fundraiser_donation_process($donation);
    if (!isset($donation->result['message'])) {
      $donation->result['message'] = '';
    }
    // The results should be at $donation->result, ready to respond to the aftermath.
    if (isset($donation->result['success']) && $donation->result['success']) {
      fundraiser_donation_success($donation);
      // Record the success.
      $successes++;
    }
    else {
      $donation->result['success'] = FALSE;
      fundraiser_donation_decline($donation);
      // Record the fail.
      $fails++;
    }
  }
  if ($successes > 0 || $fails > 0) {
    watchdog('fundraiser_sustainers', '!successes recurring donations processed successfully; !fails failed.',
      array('!successes' => $successes, '!fails' => $fails));
  }
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_post_recurring');
}

/**
 * Menu callback for the my recurring payments tab of the user profile.
 */
function fundraiser_sustainers_user_overview($user) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    drupal_set_message(t('You have no recurring donations.'), 'warning');
    drupal_goto('user/' . $user->uid);
  }
  else {
    if (count($donations) == 1) {
      // Forward user to the donation IFF the user only has one.
      drupal_goto('user/' . $user->uid . '/recurring_overview/' . $donations[0]->master_did);
    }
    else {
      // Else display the list.
      // Get the whole set of user donations (in case there's more than just this one). IIF the user owns this one.
      $donations_header = array('Amount', 'Start Date', 'Next Charge Date', 'Expire Date', 'Status');
      $donations_rows = array();
      foreach ($donations as $master_donation) {
        $this_donation = fundraiser_donation_get_donation($master_donation->master_did);
        // Grab the next to be charged for misc info.
        $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($master_donation->master_did);
        $this_next_donation = $this_donation;
        if ($remaining) {
          $this_next_donation = fundraiser_donation_get_donation($remaining[0]->did);
        }
        $edit_link = l('$' . money_format('%i', $this_next_donation->donation['amount']),
          'user/' . $this_next_donation->user->uid . '/recurring_overview/' . $master_donation->master_did);
        $donations_rows[] = array(
          'data' => array(
            'amount' => $edit_link,
            'start_date' => date('m/d/y', $master_donation->start_date),
            'next_charge' => !empty($master_donation->next_charge) ? date('m/d/y', $master_donation->next_charge) : '--/--/--',
            'expire_date' => date('m/d/y', $master_donation->expire_date),
            'status' => $master_donation->status,
          ),
          'class' => array('recurring-order'),
        );
      }
      $recurring_donations = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));
      return $recurring_donations;
    }
  }
}

/**
 * Implements hook_order().
 * From http://www.ubercart.org/docs/api/hook_order
 * When an order is deleted, keep fundraiser sustainer tables in sync if it's a donation too.
 */
function fundraiser_sustainers_order($op, &$arg1, $arg2) {
  switch ($op) {
    case 'delete':
      $donation = fundraiser_donation_get_donation($arg1->order_id); // Allowed use of order_id, ubercart is passing in an actual order.
      if ($donation) {
        fundraiser_donation_cancel($donation);
      }
      break;
  }
}

/**
 * Implements hook_fundraiser_field_info().
 */
function fundraiser_sustainers_fundraiser_field_info() {
  $fields['credit_card_information']['recurs_monthly'] = array(
    '#title' => 'Recurring Payment',
    '#type' => 'select',
    '#required' => 0,
    '#extra' => array(
      'description' => 'Selecting "Yes" will cause your credit card to be charged once per month until its expiration date.',
      'items' => 'recurs|Yes',
      'multiple' => 'Y',
    ),
  );
  return $fields;
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Adds the admin form for crons to the fundraiser settings form.
 */
function fundraiser_sustainers_form_fundraiser_admin_settings_alter(&$form, &$form_state) {
  // Turn on option to process sustainer donations on own cron.
  $form['fundraiser_sustainers'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fundraiser sustainers'),
    '#description' => t('Configure fundraiser sustainers settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['fundraiser_sustainers']['fundraiser_sustainers_create_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Creation limit'),
    '#description' => t('How many charges max to make off a successful charge.'),
    '#default_value' => variable_get('fundraiser_sustainers_create_limit', 50),
  );
  $form['fundraiser_sustainers']['fundraiser_cron'] = array(
    '#type' => 'fieldset',
    '#title' => t('Cron settings'),
    '#description' => t('Configure cron settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['fundraiser_sustainers']['fundraiser_cron']['fundraiser_standalone_cron_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable standalone cron.'),
    '#description' => t('If this option is enabled all fundraiser related cron tasks will be removed from the ' .
      'standard cron run. These tasks will need to be cronned separately via sitename/fundraiser_cron'),
    '#default_value' => variable_get('fundraiser_standalone_cron_enabled', 0),
  );
  // CC expiration message to send when sustainer donation is almost out.
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message'] = array(
    '#type' => 'fieldset',
    '#title' => t('Credit card expiration email'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_sustainers_send_email'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send expiration email'),
    '#description' => t('If this option is enabled then emails will be sent when a card is about to expire.'),
    '#default_value' => variable_get('fundraiser_sustainers_send_email', TRUE),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_cc_exp_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Email subject'),
    '#default_value' => variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire'),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['fundraiser_cc_exp_body'] = array(
    '#type' => 'textarea',
    '#title' => t('Email body'),
    '#default_value' => variable_get('fundraiser_cc_exp_body',
      'Your card ending in [donation:card_number] is about to expire on [donation:card_expiration_month]/[donation:card_expiration_year].'),
    '#description' => t('The body of the email. Available tokens: [exp_month], [exp_year], [order_total], [cc_last_4], [cc_type], [amount]'),
  );
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['tokens'] = array(
    '#type' => 'fieldset',
    '#title' => t('Donor replacement tokens'),
    '#description' => t('The following tokens are available for sustainer emails.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $token_set = array('donation', 'user', 'node');
  $form['fundraiser_sustainers']['fundraiser_cc_expiration_message']['tokens']['token_help'] = array(
    '#type' => 'item',
    '#title' => t('Drupal tokens'),
    '#description' => theme('token_tree', array('token_types' => $token_set, 'recursion_limit' => 2, 'click_insert' => FALSE)),
  );
  $form['#submit'][] = 'fundraiser_update_cron_settings';
}

/**
 * Submit handler updates cron menu handler.
 */
function fundraiser_update_cron_settings($form, $form_state) {
  $cron_enabled = variable_get('fundraiser_standalone_cron_enabled', 0);
  if ($cron_enabled != $form_state['values']['fundraiser_standalone_cron_enabled']) {
    variable_set('fundraiser_standalone_cron_enabled', $form_state['values']['fundraiser_standalone_cron_enabled']);
    // Refresh menu cache.
    menu_rebuild();
  }
}

/**
 * Menu callback, loads a specific order for the my recurring payments tab.
 */
function fundraiser_sustainers_edit($user, $did) {
  return fundraiser_sustainers_edit_form($did);
}

/**
 * Provide administrative form for editting a donation set.
 */
function fundraiser_sustainers_edit_form($did) {
  // Add js and css to the form.
  $base = drupal_get_path('module', 'fundraiser_sustainers');
  drupal_add_js($base . '/js/sustainer.js');
  drupal_add_css($base . '/css/sustainer.css');

  // Grab all associated donation information.
  $donation = fundraiser_donation_get_donation($did);

  // Check permissions, we don't want to show this to someone who doesn't have permission.
  global $user;
  if (($donation->user->uid != $user->uid) && !user_access('administrate recurring donations')) {
    return t('You do not have access to this recurring donation.');
  }

  // Grab the next to be charged for misc info.
  $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($donation->did);
  $next_donation = $donation;
  if ($remaining) {
    $next_donation = fundraiser_donation_get_donation($remaining[0]->did);
  }

  // Gather further donation data.
  $remaining_donation_count = _fundraiser_sustainers_count_donations_recurr_remaining($did);
  $payment_info = '<div id="payment-info">' .
  '<h2>Recurring Payment Info</h2>' .
  '<dl>' .
  '<dt>Recurring Donation Amount</dt>' .
  '<dd>$' . money_format('%i', $next_donation->donation['amount'] ) . '</dd>' .
  '<dt>Recurring Charges Processed</dt>' .
  '<dd>' . _fundraiser_sustainers_count_donations_recurr_processed($did) . '</dd>' .
  '<dt>Recurring Charges Remaining</dt>' .
  '<dd>' . $remaining_donation_count . '</dd>' .
  '</dl>' .
  '</div>';

  $billing_info = '<div id="billing-info">' .
  '<h2>Billing Address</h2>' .
  '<address>' .
  $donation->donation['address'] . '<br />' .
  $donation->donation['city'] . ', ' . $donation->donation['state'] . ' ' . $donation->donation['zip'] .
  '</address>';
  // If the logged in viewing user is NOT the same as the donation user.
  if ($donation->user->uid != $user->uid) {
    $billing_info .= '<div id="additioanl-billing-info">Customer Account: <a href=\'/user/' . $donation->uid . '\'>' .
      $donation->user->name . '</a>' .
      '<br />Primary email: ' . $donation->user->mail . '</div>';
  }
  $billing_info .= '</div>';

  // Format payment schedule into a data table
  $donation_set = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  $donations_header = array('Amount', 'Charge Date', 'Processed Status');
  if (user_access('fastforward recurring donations')) {
    // Add a button to fastforward this particular donation
    $donations_header[] = t('Advanced Charge to Today');
  }
  $donations_rows = array();
  if ($donation_set) {
    foreach ($donation_set as $this_donation) {
      $this_donation = fundraiser_donation_get_donation($this_donation->did);
      $donations_row['amount'] = '$' . money_format('%i', $this_donation->donation['amount']);
      $donations_row['charge_date'] = date('m/d/y', $this_donation->recurring->next_charge);
      if (empty($this_donation->status)) {
        $this_donation->status = t('Pending');
      }
      $donations_row['status'] = !empty($this_donation->status_label) ? $this_donation->status_label : $this_donation->status;
      if (user_access('fastforward recurring donations')) {
        if (isset($this_donation->status_charged) && !$this_donation->status_charged) {
          // Add a button to fastforward this particular donation
          $donations_row['ffwd'] = l(t('advance charge'), 'fundraiser_sustainers/ffwd/' . $this_donation->did,
            array('query' => drupal_get_destination()) );
        }
        else {
          $donations_row['ffwd'] = t('cannot update');
        }
      }
      $donations_rows[] = $donations_row;
    }
  }
  $future_orders = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));
  $future_orders = '<div id="payment-schedule">' .
  '<h2>Payment Schedule</h2>' .
  $future_orders .
  '</div>';

  // Check if this order is already cancelled.
  $cancelled = isset($next_donation->recurring->cancellation_reason) ? $next_donation->recurring->cancellation_reason : '';

  // Generate forms, or error messages as needed.
  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $donation_amount_form = drupal_render( drupal_get_form('fundraiser_sustainers_donation_amount_form', $donation, $next_donation));
  }
  elseif ($remaining_donation_count == 0) {
    $donation_amount_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $donation_amount_form = t('This recurring donation has been cancelled.');
  }
  $donation_amount_form = '<div id="donation-amount-form"><h2>Update Donation Amount</h2>' . $donation_amount_form . '</div>';

  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $billing_update_form = drupal_render( drupal_get_form('fundraiser_sustainers_billing_update_form', $next_donation));
  }
  elseif ($remaining_donation_count == 0) {
    $billing_update_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $billing_update_form = t('This recurring donation has been cancelled.');
  }
  $billing_update_form = '<div id="donation-billing-form"><h2>Update Your Credit Card Information</h2>' . $billing_update_form . '</div>';

  if ($remaining_donation_count > 0 && empty($cancelled)) {
    $cancel_form = drupal_render( drupal_get_form('fundraiser_sustainers_cancel_form', $donation) );
  }
  elseif ($remaining_donation_count == 0) {
    $cancel_form = t('There are no further charges for this recurring donation.');
  }
  else {
    $cancel_form = t('This recurring donation has been cancelled. Your reason given was: %reason', array('%reason' => $cancelled));
  }
  if (user_access('cancel future donations')) {
    $cancel_form = '<div id="donation-cancel-form"><h2>Cancel Future Donations</h2>' . $cancel_form . '</div>';
  }
  else {
    $cancel_form = '';
  }
  // Put together the output.
  drupal_set_title(t('Recurring donation #@did', array('@did' => $did)));
  $parts = array($payment_info, $billing_info, $future_orders, $donation_amount_form, $billing_update_form, $cancel_form);
  return implode('', $parts);
}

/**
 * Creates a form for donation amount update.
 */
function fundraiser_sustainers_donation_amount_form($form, &$form_state, $donation, $next_donation) {
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['min_amount'] = array(
    '#type' => 'hidden',
    '#value' => $donation->node->minimum_donation_amount,
  );
  $form['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Donation Amount'),
    '#size' => 10,
    '#required' => TRUE,
    '#description' => t('Your current donation amount is %amount. Minimum donation %minimum.',
      array(
        '%amount' => money_format('%i', $next_donation->donation['amount']),
        '%minimum' => money_format('%i', $donation->node->minimum_donation_amount))
      ),
    '#field_prefix' => '$',
  );
  $form['submit'] = array(
    '#type' => 'submit',
     '#value' => t('Update donation amount'),
  );
  return $form;
}

/**
 * Form validation handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['fee_amount'])) {
    form_set_error('amount', t('Donation amount must be a valid number.'));
  }
  if ($form_state['values']['fee_amount'] < $form_state['values']['min_amount']) {
    form_set_error('amount', t('Donation amount must be greater than %minimum',
      array('%minimum' =>  money_format('%i', $form_state['values']['min_amount']))));
  }
}

/**
 * Form submit handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_submit($form, &$form_state) {
  $amount = $form_state['values']['fee_amount'];
  $master_did = $form_state['values']['master_did'];
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($donations as $donation) {
    $donation = fundraiser_donation_get_donation($donation->did);
    $old_amount = $donation->donation['amount'];
    $donation->donation['amount'] = $amount;
    $donation->donation['old_amount'] = $old_amount;
    fundraiser_donation_update($donation);
    // Add a comment.
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'The amount of this gift was changed from $@old_amount to $@new_amount on @date by @username.',
      array('@old_amount' => $donation->donation['old_amount'], '@new_amount' => $donation->donation['amount'],
        '@date' => format_date(strtotime('now')), '@username' => $username));
  }
  drupal_set_message(t('The amount of all future donations has been updated to @amount.', array('@amount' => $amount)));
}

/**
 * Creates form for billing address update.
 */
function fundraiser_sustainers_billing_update_form($form, &$form_state, $donation) {
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $donation->uid,
  );

  // The rest of this is based on fields generated from fundraiser.
  $field_info = fundraiser_field_info();
  // The parts we need to allow for updating: donor info, billing and credit card.
  $form['billing_information'] = array(
    '#type' => 'fieldset',
    '#title' => t('Billing Address'),
    '#attributes' => array('id' => 'billing-address'),
  );
  $billing_fields = array_merge($field_info['donor_information'], $field_info['billing_information']);
  foreach (element_children($billing_fields) as $field_key) {
    $field = $billing_fields[$field_key];
    $form['billing_information'][$field_key] = _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field);
  }

  // CC info.
  $form['credit_card_information'] = array(
    '#type' => 'fieldset',
    '#title' => 'Credit Card Information',
    '#attributes' => array('id' => 'credit-card-info'),
  );
  $cc_fields = $field_info['credit_card_information'];
  foreach (element_children($cc_fields) as $field_key) {
    $field = $cc_fields[$field_key];
    $form['credit_card_information'][$field_key] = _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field);
  }
  // Unset CC number values.
  unset($form['credit_card_information']['card_number']['#default_value']);
  unset($form['credit_card_information']['card_expiration_month']['#default_value']);
  unset($form['credit_card_information']['card_expiration_year']['#default_value']);
  unset($form['credit_card_information']['card_cvv']['#default_value']);

  // Unset the recurring donation option if it exists. We don't want it here.
  if (isset($form['credit_card_information']['recurs_monthly'])) {
    unset($form['credit_card_information']['recurs_monthly']);
  }

  // And add a submit button.
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save changes'),
  );
  // Modify form displays according to callback settings.
  // This allows any other systems to modify the available options with callbacks.
  $form['#calling_module'] = 'fundraiser_sustainers';
  fundraiser_display_form_fields('fundraiser_sustainers', $form, $form_state);
  return $form;
}

/**
 * Helper function, generate fields from given field_info.
 */
function _fundraiser_sustainers_create_field_from_info($donation, $field_key, $field_info) {
  $field = array(
    '#type' => $field_info['#type'],
    '#title' => t('@title', array('@title' => $field_info['#title'])),
    '#required' => (isset($field_info['#required']) && $field_info['#required'] == 1) ? TRUE : FALSE,
    '#default_value' => $donation->donation[$field_key],
  );
  if ($field_info['#type'] == 'select') {
    $options = array();
    $items = $field_info['#extra']['items'];
    $items = explode("\n", $items);
    foreach ($items as $item) {
      $items_values = explode('|', $item);
      $key = trim($items_values[0]);
      $label = isset($items_values[1]) ? trim($items_values[1]) : $key;
      if (!empty($key)) {
        $options[$key] = $label;
      }
    }
    $field['#options'] = $options;
    $field['#multiple'] =
      (isset($field_info['#extra']['multiple']) && $field_info['#extra']['multiple'] == 1) ? TRUE : FALSE;
  }
  return $field;
}

/**
 * Form validation handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_validate($form, &$form_state) {
  // Submission fields are keyed according to the fields in fundraiser_field_info().
  // Select only the ones we want to validate with fundraiser.
  $submission_fields = $form_state['values'];
  $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields); // From fundraiser.module.
  if ($errors) {
    // We've set a form_error by now.
    drupal_set_message(t('Unable to update credit card information.'));
  }
}

/**
 * Form submit handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_submit($form, &$form_state) {
  $master_did = $form_state['values']['master_did'];
  // We only update donations to come, not ones already processed.
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  $submitted_values = $form_state['values'];
  // Remove unnessecary values.
  unset($submitted_values['master_did']);
  unset($submitted_values['uid']);
  foreach ($donations as $donation) {
    // Get the original donation.
    $donation = fundraiser_donation_get_donation($donation->did);
    // Update it.
    $donation->donation = array_merge($donation->donation, $submitted_values);
    // Mark the billing information as needing to be updated.
    $donation->update_billing = TRUE;
    // Save each donation.
    fundraiser_donation_update($donation);
    // Add a comment.
    global $user;
    $username = isset($user->name) ? $user->name : 'Anonymous';
    fundraiser_donation_comment($donation, 'The card to be charged was changed on @date by @username.',
      array('@date' => format_date(strtotime('now')), '@username' => $username));
    watchdog('fundraiser_sustainers', 'Billing information updated for #@did.',
      array('@did' => $donation->did));
  }
  // Load the master donation.
  $master_donation = fundraiser_donation_get_donation($master_did);
  // Create new orders based on expiration date as needed.
  _fundraiser_sustainers_create_future_orders($master_donation, $form_state['values']['card_expiration_month'],
    $form_state['values']['card_expiration_year']);
  drupal_set_message(t('Billing information successfully updated'));
}

/**
 * Helper function, create recurring donations to the limits of the donation card expiration date.
 * If the recurring donations exist already update, cancelling those that are past expiration.
 */
function _fundraiser_sustainers_create_future_orders($donation, $month, $year) {
  // Add the master to the recurring table.
  $recurring_donation = array(
    'did' => $donation->did,
    'master_did' => $donation->did,
    'next_charge' => strtotime('now'),
    'gateway_resp' => 'success',
    'attempts' => 1,
  );
  // Update the recurring table.
  _fundraiser_sustainers_create_recurring($recurring_donation);

  // Handle the rest of the set.
  $start = strtotime("now");
  $stop = mktime(0, 0, 0, $month, 1, $year);
  $months = ((idate('Y', $stop) * 12) + idate('m', $stop)) - ((idate('Y', $start) * 12) + idate('m', $start));
  $processed_months = 0;

  // Start counting.
  $create_limit = variable_get('fundraiser_sustainers_create_limit', 50);
  // Get existing donations, if they exist.
  $existing_recurring = _fundraiser_sustainers_get_donations_recurr_by_masterdid($donation->did);
  unset($existing_recurring[0]); // 0 is the master, we don't need to count it.
  while ($processed_months < $months && $processed_months < $create_limit) {
    $processed_months++;
    // Check if we have a donation for this next month.
    if (!isset($existing_recurring[$processed_months])) {
      // Create a new one.
      $new_donation = clone $donation;
      $new_donation->sid = 0; // Not actually submitted, it's automated, so no sid.
      // Create the new donation object, but do not process it. Processing doesn't occur till cron.
      // New donation has all of the old donation information already loaded.
      fundraiser_donation_create($new_donation);
      $next_charge = strtotime('+ ' . $processed_months . ' months');
      fundraiser_donation_comment($new_donation, 'Sustainer donation scheduled to be charged at @next_charge',
        array('@next_charge' => format_date($next_charge)));
      // After this, the donation did and donation data is set.
      // The new donation object, with new did, needs to be saved to recurring so we can grab it later.
      $recurring_donation = array(
        'master_did' => $donation->did,
        'did' => $new_donation->did,
        'next_charge' => $next_charge,
      );
      // Update the recurring table.
      _fundraiser_sustainers_create_recurring($recurring_donation);
    }
    else {
      // Unset this from the existing recurring.
      // By the time this loop is done, only recurring outside of our range wills till be in the set.
      unset($existing_recurring[$processed_months]); // This donation existed already, mark it off.
    }
  }

  // Done with the loop, everything has been created that needs to be created.
  // But now we need to remove anything that existed in the set beyond our expiration date.
  global $user;
  foreach ($existing_recurring as $key => $recurring) {
    $this_donation = fundraiser_donation_get_donation($recurring->did);
    // Cancel the donation with an informative message.
    watchdog('fundraiser', 'Donation @id was deleted by @user while updating the card expiration date.',
      array('@id' => $donation->did, '@user' => $user->name), WATCHDOG_DEBUG, NULL);
    fundraiser_donation_delete($this_donation);
  }
}

/**
 * Creates form to cancel donations.
 */
function fundraiser_sustainers_cancel_form($form, &$form_state, $donation) {
  // Only allow certain users to cancel future donations.
  $form['#access'] = user_access('cancel future donations');
  // Otherwise, provide cancel button.
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_did,
  );
  $form['reason'] = array(
    '#type' => 'textarea',
    '#title' => t('Reason'),
    '#default_value' => t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.'),
    '#maxlength' => 500,
    '#cols' => 70,
    '#rows' => 3,
    '#resizable' => FALSE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel all future payments'),
  );
  return $form;
}

/**
 * Form submit handler for cancel donations form.
 */
function fundraiser_sustainers_cancel_form_submit($form, &$form_state) {
  global $user;
  $master_did = $form_state['values']['master_did'];
  $reason = $form_state['values']['reason'];
  if (empty($reason) || $reason == t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.')) {
    $reason = t('No reason given.');
  }
  // Cancel the donations.
  $sustainer_donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($sustainer_donations as $sustainer_donation) {
    $donation = fundraiser_donation_get_donation($sustainer_donation->did);
    fundraiser_donation_cancel($donation);
    watchdog('fundraiser_sustainers', 'Donation cancelled for #@did. Reason: @reason',
      array('@did' => $donation->did, '@reason' => $reason));
  }
  _fundraiser_sustainers_cancel_recurring_by_master($master_did, $reason);
  drupal_set_message(t('All future payments cancelled.'));
}

/**
 * Implements hook_fundraiser_donation_get_donation().
 */
function fundraiser_sustainers_fundraiser_donation_get_donation($donation) {
  // Add recurring data to the fundraiser donation.
  $recurring = _fundraiser_sustainers_get_recurring_by_did($donation->did);
  if ($recurring) {
    $donation->recurring = $recurring;
    $donation->donation['recurs_monthly'] = TRUE;
  }
  else {
    $donation->donation['recurs_monthly'] = FALSE;
  }
}

/**
 * Implements hook_fundraiser_donation_create().
 */
function fundraiser_sustainers_fundraiser_donation_create($donation) {
  // If this has been flagged as a recurring dontation, mark it properly so all following systems can understand.
  $recurs = FALSE;
  if (!isset($donation->donation['recurs_monthly'])) { // In case the recurs_monthly field doesn't exist.
    $donation->donation['recurs_monthly'] = FALSE;
  }
  if (is_bool($donation->donation['recurs_monthly'])) {
    $recurs = $donation->donation['recurs_monthly'];
  }
  elseif (is_array($donation->donation['recurs_monthly']) && isset($donation->donation['recurs_monthly'][0])) {
    $recurs = ($donation->donation['recurs_monthly'][0] == 'recurs') ? TRUE : FALSE;
  }
  else {
    $recurs = ($donation->donation['recurs_monthly'] == 'recurs') ? TRUE : FALSE;
  }
  // Set the value for the donation.
  $donation->donation['recurs_monthly'] = $recurs;
}

/**
 * Implements hook_fundraiser_donation_success().
 */
function fundraiser_sustainers_fundraiser_donation_success($donation) {
  // If we don't have a master id already set, check if this is a new recurring order.
  if (!isset($donation->recurring->master_did)) {
    // If this is in fact a recurring donation, then we act.
    if ($donation->donation['recurs_monthly'] == TRUE) {
      $donation->recurring->master_did = $donation->did;
      // This created donation is the master, so passing it in to create the set.
      _fundraiser_sustainers_create_future_orders($donation, $donation->donation['card_expiration_month'], $donation->donation['card_expiration_year']);
    }
  }
  else {
    // For all recurring when processed, check if we need to send a notice about the set almost done.
    if (_fundraiser_sustainers_count_donations_recurr_remaining($donation->recurring->master_did) == 1) {
      _fundraiser_sustainers_send_cc_notification($donation->recurring->master_did, $donation->uid);
    }
    // And update the sustainer table.
    db_query('UPDATE {fundraiser_sustainers} SET ' .
      'gateway_resp = \'success\', attempts = attempts + 1 ' .
      'WHERE did = :did', array(':did' => $donation->did)
    );
  }
}

/**
 * Implements hook_fundraiser_donation_decline().
 */
function fundraiser_sustainers_fundraiser_donation_decline($donation) {
  if ($donation->donation['recurs_monthly'] == TRUE) {
    // Update data internal to fundraiser. TODO move this db stuff.
    db_query('UPDATE {fundraiser_sustainers} SET ' .
      'gateway_resp = \'failed\', attempts = attempts + 1, ' .
      'next_charge = unix_timestamp(timestampadd(DAY, 1, from_unixtime(next_charge))) ' .
      'WHERE did = :did', array(':did' => $donation->did)
    );
    // Get the number of times this order has been attempted
    $attempt_count = db_query('SELECT attempts FROM {fundraiser_sustainers} WHERE did = :did',
      array(':did' => $donation->did))->fetchColumn();
    if ($attempt_count == 3) {
      // Final attempt, add debug alert.
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed 3 times. ' .
        'The donation will not be submitted for payment again. Gateway message: @message',
        array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_DEBUG);
    }
    else {
      // Log this failure
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed @attempts times. It will be processed again in 1 day. Gateway message: @message',
        array('@id' => $donation->did, '@attempts' => $attempt_count, '@message' => $donation->result['message']), WATCHDOG_DEBUG);
    }
  }
}

/**
 * Helper function, loads the recurring donation processor key.
 */
function fundraiser_sustainers_processor_key_match() {
  static $key;
  if (!empty($key)) {
    return ($key == $_SERVER['HTTP_HOST']);
  }
  // This is to check that we have everything configured for safe charging.
  // If not, we should throw an issue about it and not try to process stuff.
  // This value is normally set in the glue module for payment.
  $dir = module_invoke_all('fundraiser_get_credit_encryption_path');
  $dir = $dir[0];
  if ($dir && $dir !== t('Not configured, see below.')) {
    $filename = rtrim($dir, '/\\') . '/sustainer.key';
    if (file_exists($filename)) {
      if (!$file = fopen($filename, 'r')) {
        return FALSE;
      }
      $key = fread($file, filesize($filename));
      if (trim($key) != trim($_SERVER['HTTP_HOST'])) {
        return FALSE;
      }
      fclose($file);
    }
    else {
      return FALSE;
    }
  }
  else {
    return FALSE;
  }
  return TRUE;
}

/**
 * Helper function, kicks off an email to a sustainer to remind them their credit card is about to expire.
 */
function _fundraiser_sustainers_send_cc_notification($master_did, $uid) {
  // Short circuit this email if the configuration for fundraiser says don't send it.
  if (!variable_get('fundraiser_sustainers_send_email', TRUE)) {
    return;
  }
  // Otherwise, send it.
  $user = user_load($uid);
  // Load the last remaining order so we can get some info for the email.
  $did = db_query('SELECT did FROM {fundraiser_sustainers} WHERE master_did = :master_did AND gateway_resp IS NULL LIMIT 0,1', // Coder: this is ok.
    array(':master_did' => $master_did))->fetchColumn();
  $donation = fundraiser_donation_get_donation($did);

  // Do token replacement on body.
  $body = variable_get('fundraiser_cc_exp_body',
    'Your card ending in [donation:card_number] is about to expire on [donation:card_expiration_month]/[donation:card_expiration_year].');
  $token_set = array('node' => $donation->node, 'donation' => $donation, 'user' => $user);
  $body = token_replace($body, $token_set);
  // Pass tokens as param so hook_mail has access.
  $params['fundraiser_sustainers_token_set'] = $token_set;
  $params['fundraiser_sustainers_body'] = $body;
  watchdog('fundraiser_sustainers', 'Credit card expiration email sent to @mail', array('@mail' => $user->mail), WATCHDOG_INFO);
  drupal_mail('fundraiser', 'fundraiser_cc_notification', $user->mail, user_preferred_language($user), $params);
}

/**
 * Database functions.
 */

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_create_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = $donation;
    drupal_write_record('fundraiser_sustainers', $record);
  }
  else {
    _fundraiser_sustainers_update_recurring($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_get_recurring_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_update_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_sustainers_create_recurring($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_sustainers', $record, 'did');
  }
}

/**
 * CRUD style DB function for fundraiser_sustainers.
 */
function _fundraiser_sustainers_delete_recurring($did) {
  db_delete('fundraiser_sustainers')->condition('did', $did)->execute();
}

/**
 * DB function, cancel recurring given a master did. (Do not delete!)
 */
function _fundraiser_sustainers_cancel_recurring_by_master($master_did, $reason) {
  db_query('UPDATE {fundraiser_sustainers} ' .
    'SET gateway_resp = \'canceled\', cancellation_reason = :reason ' .
    'WHERE master_did = :master_did AND (gateway_resp IS NULL OR gateway_resp = \'failed\')',
    array(':reason' => $reason, ':master_did' => $master_did));
}

/**
 * DB funct, get user donation set information that are recurring.
 */
function _fundraiser_sustainers_get_donation_sets_recurr_by_uid($uid) {
  $donation_sets = db_query('SELECT r.master_did, MIN(r.next_charge) AS start_date, ' .
    'MAX(r.next_charge) AS expire_date FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE d.uid = :uid ' .
    'GROUP BY r.master_did ' .
    'ORDER BY r.master_did DESC', array(':uid' => $uid))->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_did);
    if (isset($next_charge->next_charge)) {
      $donation_sets[$index]->next_charge = $next_charge->next_charge;
      $donation_sets[$index]->status = isset($next_charge->cancellation_reason) ? t('Cancelled') : t('Active');
    }
    else {
      $donation_sets[$index]->next_charge = '';
      $donation_sets[$index]->status = t('No next charge');
    }
  }
  return $donation_sets;
}

/**
 * DB funct, get user donation set information that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donation_sets() {
  $donation_sets = db_query('SELECT r.master_did, MIN(r.next_charge) AS start_date, ' .
    'MAX(r.next_charge) AS expire_date FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = r.did ' .
    'GROUP BY r.master_did ' .
    'ORDER BY r.master_did DESC')->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_did);
    $donation_sets[$index]->next_charge = $next_charge->next_charge;
    $donation_sets[$index]->status = isset($next_charge->cancellation_reason) ? 'cancelled' : 'active';
  }
  return $donation_sets;
}


/**
 * DB funct, get order donations that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donations_recurr_by_member($did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE d.did = :did OR r.master_did = :master_did ' .
    'ORDER BY r.next_charge ASC', array(':did' => $did, ':master_did' => $did))->fetchAll();
  return $donations;
}

/**
 * DB func, get the next charge date for a donation set.
 */
function _fundraiser_sustainers_get_donations_next_charge($master_did) {
  $now = strtotime('now');
  return db_query('SELECT * FROM {fundraiser_sustainers} ' .
    'WHERE master_did = :master_did ' .
    'AND next_charge > :now ' .
    'ORDER BY next_charge ASC ' .
    'LIMIT 0, 1',
    array(':master_did' => $master_did, ':now' => $now))->fetchObject();
}

/**
 * DB funct, get order donations that are recurring.
 * Called in admin pages.
 */
function _fundraiser_sustainers_get_donations_recurr_by_masterdid($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are remaining.
 */
function _fundraiser_sustainers_count_donations_recurr_remaining($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  if ($donations) {
    return count($donations);
  }
  return 0;
}

/**
 * DB funct, get order donation sets that are remaining.
 */
function _fundraiser_sustainers_get_donations_recurr_remaining($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'AND (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\' OR r.gateway_resp = \'canceled\') ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are processed.
 */
function _fundraiser_sustainers_count_donations_recurr_processed($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_processed($master_did);
  if ($donations) {
    return count($donations);
  }
  return 0;
}

/**
 * DB funct, get order donation sets that are processed.
 */
function _fundraiser_sustainers_get_donations_recurr_processed($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE r.master_did = :master_did ' .
    'AND r.gateway_resp = \'success\' ' .
    'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB function, get donations ready to be processed.
 */
function _fundraiser_sustainers_cron_get_recurring($limit = 1000) {
  $now = strtotime('now');
  $donations = db_query_range('SELECT * FROM {fundraiser_sustainers} r ' .
    'LEFT JOIN {fundraiser_donation} d on r.did = d.did ' .
    'WHERE (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\') ' .
    'AND r.next_charge < :now ' .
    'AND r.attempts < 3 ' . // If already been tried 3 times, Stop Trying.
    'ORDER BY r.next_charge ASC ', 0, $limit,
    array(':now' => $now))->fetchAll();
  return $donations;
}