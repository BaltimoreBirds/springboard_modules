<?php

/**
 * @file
 * Sustainer page callbacks for the fundraiser module.
 *
 * Why? Footprint again. Not all sites need recurring / sustainer maintained fundraising.
 * (Use this module to model behavior and actions for peer-to-peer and other fundraiser types.)
 */

/**
 * Implements hook_cron().
 */
function fundraiser_sustainers_cron() {
  // If cron.php is being run while standalone cron is enabled, do nothing.
  // This allows this code to still execute if cron is run from the status page.
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    if (preg_match('/cron.php$/', $_SERVER['REQUEST_URI'])) {
      return 0;
    }
    else {
      watchdog('fundraiser_cron', 'Fundraiser cron run.', NULL, WATCHDOG_INFO);
    }
  }
  else {
    watchdog('fundraiser_cron', 'Standard cron run.', NULL, WATCHDOG_INFO);
  }
  // Process recurring donations.
  if (fundraiser_sustainers_processor_key_match()) {
    fundraiser_sustainers_process_recurring_donations();
  }
  else {
    $message = 'The fundraiser sustainer key has not been configured correctly. Recurring donations will not be processed.';
    drupal_set_message(t($message), 'warning');
    watchdog('fundraiser_cron', $message, NULL, WATCHDOG_CRITICAL);
  }
}

/**
 * Implements hook_permission().
 */
function fundraiser_sustainers_permission() {
  return array(
    'cancel future donations' => array(
      'title' => t('Cancel future donations'), 
      'description' => t('Cancel future donations.'),
    ),
    'administrate recurring donations' => array(
      'title' => t('Administrate recurring donations'), 
      'description' => t('Administrate recurring donations.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_sustainers_menu() {
  // Add the cron handler if it's enabled.
  if (variable_get('fundraiser_standalone_cron_enabled', 0)) {
    $items['fundraiser_cron'] = array(
      'page callback' => 'fundraiser_sustainers_cron',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );
  }
  // User interface.
  $items['user/%user/recurring_overview'] = array(
    'title' => 'My Recurring Donations',
    'page callback' => 'fundraiser_sustainers_user_overview',
    'page arguments' => array(1),
    'access callback' => '_fundraiser_sustainers_user_has_recurring_donations',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  $items['user/%user/recurring_overview/%'] = array(
    'title' => 'My Recurring Donations',
    'page callback' => 'fundraiser_sustainers_edit',
    'page arguments' => array(1, 3),
    'access callback' => '_fundraiser_sustainers_user_has_recurring_donations',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );
  // Admin interface.
  $items['admin/config/system/fundraiser/recurring'] = array(
    'title' => 'Recurring',
    'page callback' => 'fundraiser_sustainers_admin',
    'access arguments' => array('administrate recurring donations'),
    'file' => 'fundraiser_sustainers.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/system/fundraiser/recurring/%'] = array(
    'title' => 'View Donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_CALLBACK,
    'tab_parent' => 'admin/config/system/fundraiser/recurring',
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/view'] = array(
    'title' => 'View Donation',
    'page callback' => 'fundraiser_sustainers_admin_view',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  $items['admin/config/system/fundraiser/recurring/%/edit'] = array(
    'title' => 'Edit Donation',
    'page callback' => 'fundraiser_sustainers_admin_edit',
    'page arguments' => array(5),
    'access callback' => 'fundraiser_sustainers_check_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'file' => 'fundraiser_sustainers.admin.inc',
  );
  // If Ubercart exists. Show these as a tab there as well.
  if (module_exists('uc_order')) {
    $items['admin/store/orders/%/recurring'] = array(
      'title' => 'Recurring',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/recurring'] = array(
      'title' => 'View Donation',
      'page callback' => 'fundraiser_sustainers_admin_view',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'file' => 'fundraiser_sustainers.admin.inc',
    );
    $items['admin/store/orders/%/recurring/edit'] = array(
      'title' => 'Edit Donation',
      'page callback' => 'fundraiser_sustainers_admin_edit',
      'page arguments' => array(3),
      'access callback' => 'fundraiser_sustainers_check_access',
      'access arguments' => array(3),
      'file' => 'fundraiser_sustainers.admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
  }
  return $items;
}

/**
 * Menu callback for the my recurring payments tab of the user profile.
 */
function fundraiser_sustainers_user_overview($user) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    drupal_goto('user/' . $user->uid);
  }
  else {
    drupal_goto('user/' . $user->uid . '/recurring_overview/' . $donations[0]->master_order_id);
  }
}

/**
 * Menu access callback, check if the order has recurring orders (as master id).
 */
function fundraiser_sustainers_check_access($did) {
  // First check if this even has a recurring donation.
  $donations = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  if (!$donations) {
    return FALSE;
  }
  // Then check if the user is allowed.
  return user_access('administrate recurring donations');
}

/**
 * Implementation of hook_order().
 * From http://www.ubercart.org/docs/api/hook_order
 * When an order is deleted, keep fundraiser tables in sync. if it's a donation too.
 */
function fundraiser_sustainers_order($op, &$arg1, $arg2) {
  switch ($op) {
    case 'delete':
      $donation = fundraiser_donation_get_donation($arg1->order_id);
      if ($donation) {
        fundraiser_donation_cancel($donation);
      }
      break;
  }
}

/**
 * Implements hook_fundraiser_donation_success().
 */
function fundraiser_sustainers_fundraiser_donation_success($donation) {
  // If this has been flagged as a recurring dontation, spawn all the future donations at this time.
  if ($donation->recurs == DONATION_RECURRING) {
    $donation->recurring->master_order_id = $donation->did;
    $months = _fundraiser_months_between_dates($donation->submission['card_expiration_month'], $donation->submission['card_expiration_year']);
    if ($months > 0 ) {
      $master_did = $donation->did;
      $gateway = $donation->node->gateway;
      $new_donation = (object) array();
      $new_donation->context = $donation->context;
      $new_donation->uid = $donation->uid;
      $new_donation->user = $donation->user;
      $new_donation->nid = $donation->nid;
      $new_donation->node = $donation->node;
      $new_donation->submission = $donation->submission;
      $recurring_donation = array(
        'master_order_id' => $donation->did,
        'order_id' => $donation->did, 
        'next_charge' => strtotime('now'),
        'gateway' => $gateway,
        'gateway_resp' => 'success',
        'attempts' => 1,
        'txn_id' => '-', // TODO temporary, need to pull this from donation structure. Some of this would be better stored in fundraiser, than here.
      );
      _fundraiser_sustainers_create_recurring($recurring_donation);
      for ($i = 1; $i <= $months; $i++) {
        // Create the new donation object, but do not process it. Processing doesn't occur till cron.
        fundraiser_donation_create($new_donation);
        // The new donation object, with new did, needs to be saved to recurring to be picked up.
        $recurring_donation = array(
          'master_order_id' => $master_did,
          'order_id' => $new_donation->did, 
          'next_charge' => strtotime('+ '. $i .' months'),
          'gateway' => $gateway,
        );
        _fundraiser_sustainers_create_recurring($recurring_donation);
        $recurring = _fundraiser_sustainers_get_recurring_by_did($new_donation->did);
        if ($recurring) {
          $new_donation->recurring = $recurring;
          $donation->recurring = $recurring;
        }
      }
    }
    if (_fundraiser_sustainers_count_donations_recurr_remaining($donation->recurring->master_order_id) == 1) {
      _fundraiser_sustainers_send_cc_notification($donation->recurring->master_order_id, $donation->uid);
    }
  }
}

/**
 * Implements hook_fundraiser_donation_decline().
 */
function fundraiser_sustainers_fundraiser_donation_decline($donation) {
  if ($donation->recurs == DONATION_RECURRING) {
    // Update data internal to fundraiser. TODO move this db stuff.
    db_query('UPDATE {fundraiser_recurring} SET '.
      'gateway_resp = \'failed\', attempts = attempts + 1, '.
      'next_charge = unix_timestamp(timestampadd(DAY, 1, from_unixtime(next_charge))) '.
      'WHERE order_id = :order_id', array(':order_id' => $order_id)
    );
    // get the number of times this order has been attempted
    $attempt_count = db_query('SELECT attempts FROM {fundraiser_recurring} WHERE order_id = :order_id',
      array(':order_id' => $order->order_id))->fetchColumn();
    if ($attempt_count == 3) {
      // Final attempt, add debug alert.
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed 3 times. The donation will not be submitted for payment again. Gateway message: @message',
        array('@id' => $order->order_id, '@message' => $result['message']), WATCHDOG_DEBUG);
    }
    else {
      // Log this failure
      watchdog('fundraiser_sustainers', 'Payment for recurring donation @id has failed @attempts times. It will be processed again in 1 day. Gateway message: @message',
        array('@id' => $order->order_id, '@attempts' => $attempt_count, '@message' => $result['message']), WATCHDOG_DEBUG);
    }
  }
}

/**
 * Implements hook_fundraiser_donation_get_donation().
 */
function fundraiser_sustainers_fundraiser_donation_get_donation($donation) {
  // Add recurring data to the fundraiser donation.
  $recurring = _fundraiser_sustainers_get_recurring_by_did($donation->did);
  if ($recurring) {
    $donation->recurring = $recurring;
    $donation->recurs = TRUE;
  }
  else {
    $donation->recurs = FALSE;
  }
}

/**
 * Implements hook_fundraiser_field_info().
 */
function fundraiser_sustainers_fundraiser_field_info($fields) {
  $fields['credit_card_information']['recurs_monthly'] = array(
    '#name' => 'Recurring Payment',
    '#type' => 'select',
    '#required' => 0,
    '#extra' => array(
      'description' => 'Selecting "Yes" will cause your credit card to be charged once per month until its expiration date.',
      'items' => 'recurs|Yes',
      'multiple' => 'Y',
    ),
  );
  return $fields;
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Adds the admin form for crons to the fundraiser settings form.
 */
function fundraiser_sustainers_form_fundraiser_admin_settings_alter(&$form, &$form_state) {
  // Turn on option to process sustainer donations on own cron.
  $form['fundraiser_cron'] = array(
    '#type' => 'fieldset',
    '#title' => t('Cron settings'),
    '#description' => t('Configure cron settings.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['fundraiser_cron']['fundraiser_standalone_cron_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable standalone cron.'),
    '#description' => t('If this option is enabled all fundraiser related cron tasks will be removed from the ' .
      'standard cron run. These tasks will need to be cronned separately via sitename/fundraiser_cron'),
    '#default_value' => variable_get('fundraiser_standalone_cron_enabled', 0),
  );
  // CC expiration message to send when sustainer donation is almost out.
  $form['fundraiser_cc_expiration_message'] = array(
    '#type' => 'fieldset',
    '#title' => t('Credit card expiration email'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['fundraiser_cc_expiration_message']['fundraiser_cc_exp_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Email subject'),
    '#default_value' => variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire'),
  );
  $form['fundraiser_cc_expiration_message']['fundraiser_cc_exp_body'] = array(
    '#type' => 'textarea',
    '#title' => t('Email body'),
    '#default_value' => variable_get('fundraiser_cc_exp_body', 'Your card ending in [cc_last_4] is about to expire on [exp_month]/[exp_year].'),
    '#description' => t('The body of the email. Available tokens: [exp_month], [exp_year], [order_total], [cc_last_4], [cc_type], [amount]'),
  );
  $form['fundraiser_cc_expiration_message']['tokens'] = array(
    '#type' => 'fieldset',
    '#title' => t('Donor replacement tokens'),
    '#description' => t('The following tokens are available for donor'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['#submit'] =  array('fundraiser_update_cron_settings');
}

/**
 * Submit handler updates cron menu handler.
 */
function fundraiser_update_cron_settings($form, $form_state) {
  $cron_enabled = variable_get('fundraiser_standalone_cron_enabled', 0);
  if ($cron_enabled != $form_state['values']['fundraiser_standalone_cron_enabled']) {
    variable_set('fundraiser_standalone_cron_enabled', $form_state['values']['fundraiser_standalone_cron_enabled']);
    // Refresh menu cache.
    menu_rebuild();
  }
}

/**
 * Menu callback, loads a specific order for the my recurring payments tab.
 */
function fundraiser_sustainers_edit($user, $did) {
  // This is wrapped so we can reuse the form in another location for admin purposes.
  $variables = fundraiser_sustainers_edit_form($user, $did);
  return theme('sustainer_management_page', $variables);
}

/**
 * Provide administrative form for editting a donation set.
 */
function fundraiser_sustainers_edit_form($user, $did) {
  // Grab the context so we have all the data we could need for display / format etc.
  $context = _fundraiser_donation_context();

  // Add js and css to the form.
  $base = drupal_get_path('module', 'fundraiser_sustainers');
  drupal_add_js($base . '/js/sustainer.js');
  drupal_add_css($base . '/css/sustainer.css');

  // Grab all associated donation information.
  $donation = fundraiser_donation_get_donation($did);
  // Grab the next to be charged for misc info.
  $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($donation->did);
  $next_donation = $donation;
  if ($remaining) {
    $next_donation = fundraiser_donation_get_donation($remaining[0]->order_id);
  }

  // Check if this order is already cancelled.
  $cancelled = $next_donation->recurring->cancellation_reason;
      
  // Get additional forms for display on this page.
  $donation_amount_form = t('This recurring donation has been cancelled.');
  $billing_update_form = t('This recurring donation has been cancelled.');
  $cancel_form = t('This recurring donation has been cancelled. Your reason given was: %reason', array('%reason' => $cancelled));
  if (empty($cancelled)) {
    $donation_amount_form = drupal_render( drupal_get_form('fundraiser_sustainers_donation_amount_form', $donation, $next_donation) );
    $billing_update_form = drupal_render( drupal_get_form('fundraiser_sustainers_billing_update_form', $donation, $context) );
    $cancel_form = drupal_render( drupal_get_form('fundraiser_sustainers_cancel_form', $donation) );
  }

  // Gather further donation data.
  $billing_info = array(
    'billing_first_name' => $donation->donation->billing_first_name,
    'billing_last_name' => $donation->donation->billing_last_name,
    'billing_street' => $donation->donation->billing_street1,
    'billing_street2' => $donation->donation->billing_street2,
    'billing_city' => $donation->donation->billing_city,
    'billing_state' => $context->zones[$donation->donation->billing_zone]->zone_name,
    'billing_postal_code' => $donation->donation->billing_postal_code,
  );

  // Gather additional recurring data.
  $payment_info = array(
    'orders_remaining' => _fundraiser_sustainers_count_donations_recurr_remaining($did),
    'orders_processed' => _fundraiser_sustainers_count_donations_recurr_processed($did),
    'donation_amount' => $next_donation->donation->order_total
  );

  // Format payment schedule into a data table
  $donation_set = _fundraiser_sustainers_get_donations_recurr_by_member($did);
  $donations_header = array('Amount', 'Charge Date', 'Processed Status');
  $donations_rows = array();
  if ($donation_set) {
    foreach ($donation_set as $this_donation) {
      $this_donation = fundraiser_donation_get_donation($this_donation->order_id);
      $donations_row['amount'] = '$' . money_format('%i', $this_donation->donation->donation_amount);
      $donations_row['charge_date'] = date('m/d/y', $this_donation->recurring->next_charge);
      //TODO here, make this a user friendly set of options.
      $donations_row['status'] = empty($this_donation->donation->order_status) ? 'pending' : $this_donation->donation->order_status;
      $donations_rows[] = $donations_row;
    }
  }
  $donation_set = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));

  // Get the whole set of user donations (in case there's more than just this one).
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  $donations_header = array('Amount', 'Start Date', 'Next Charge Date', 'Expire Date', 'Status');
  $donations_rows = array();
  if ($donations) {
    foreach ($donations as $master_donation) {
      $this_donation = fundraiser_donation_get_donation($master_donation->master_order_id);
      // Grab the next to be charged for misc info.
      $remaining = _fundraiser_sustainers_get_donations_recurr_remaining($master_donation->master_order_id);
      $this_next_donation = $this_donation;
      if ($remaining) {
        $this_next_donation = fundraiser_donation_get_donation($remaining[0]->order_id);
      }
      $edit_link = l('$' . money_format('%i', $this_next_donation->donation->donation_amount),
        'user/' . $user->uid . '/recurring_overview/' . $master_donation->master_order_id);
      $class = 'recurring-order';
      if ($master_donation->master_order_id == $did) {
        $class = 'recurring-order active';
      }
      $donations_rows[] = array(
        'data' => array(
          'amount' => $edit_link,
          'start_date' => date('m/d/y', $master_donation->start_date),
          'next_charge_date' => date('m/d/y', $master_donation->next_charge_date),
          'expire_date' => date('m/d/y', $master_donation->expire_date),
          'status' => $master_donation->status,
        ),
        'class' => array($class),
      );
    }
  }
  $donations = theme('table', array('header' => $donations_header, 'rows' => $donations_rows));

  return array(
      'order_id' => $did,
      'orders' => $donations,
      'payment_info' => $payment_info,
      'billing_info' => $billing_info, 
      'amount_form' => $donation_amount_form, 
      'billing_form' => $billing_update_form, 
      'cancel_form' => $cancel_form,
      'payment_schedule' => $donation_set,
      'cancelled' => !empty($cancelled),
    );
}

/**
 * Implementation of hook_theme().
 */
function fundraiser_sustainers_theme($existing, $type, $theme, $path) {
  return array(
    'sustainer_management_page' => array(
      'variables' => array(
        'order_id' => NULL,
        'orders' => NULL,
        'payment_info' => NULL, 
        'billing_info' => NULL,
        'amount_form' => NULL,
        'billing_form' => NULL, 
        'cancel_form' => NULL,
        'payment_schedule' => NULL,
        'cancelled' => FALSE
      ),
      'template' => 'templates/sustainer-management-page',
    ),
  );
}

/**
 * Implements hook_theme_registry_alter().
 */
function fundraiser_sustainers_theme_registry_alter(&$theme_registry) {
  // Tell the theme registry to look in this module's directory for theme files.
  $theme_registry['page']['theme path'] = drupal_get_path('module', 'fundraiser_sustainers') . '/templates';
}

/**
 * Creates a form for donation amount update.
 */
function fundraiser_sustainers_donation_amount_form($form, &$form_state, $donation, $next_donation) {
  $form['master_did'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_order_id,
  );
  $form['min_amount'] = array(
    '#type' => 'hidden',
    '#value' => $donation->node->minimum_donation_amount,
  );
  $form['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Donation Amount'),
    '#default_value' => $next_donation->donation->donation_amount,
    '#size' => 10,
    '#required' => TRUE,
    '#description' => t('Your current donation amount is :amount. Minimum donation :minimum.',
      array(
        ':amount' => money_format('%i', $next_donation->donation->donation_amount),
        ':minimum' => money_format('%i', $donation->node->minimum_donation_amount))
      ),
    '#field_prefix' => '$',
  );
  $form['submit'] = array(
    '#type' => 'submit',
     '#value' => t('Update donation amount'),
  );
  return $form;
}

/**
 * Form validation handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['fee_amount'])) {
    form_set_error('amount', t('Donation amount must be a valid number.'));
  }
  if ($form_state['values']['fee_amount'] < $form_state['values']['min_amount']) {
    form_set_error('amount', t('Donation amount must be greater than :minimum',
      array(':minimum' =>  money_format('%i', $form_state['values']['min_amount']))));
  }
}

/**
 * Form submit handler for donation amount update form.
 */
function fundraiser_sustainers_donation_amount_form_submit($form, &$form_state) {
  $amount = $form_state['values']['fee_amount'];
  $master_did = $form_state['values']['master_did'];
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($donations as $donation) {
    $donation = fundraiser_donation_get_donation($donation->order_id);
    $old_amount = $donation->donation->donation_amount;
    $donation->donation->donation_amount = $amount;
    fundraiser_donation_update($donation);
    watchdog('fundraiser_sustainers', 'Donation amount changed from @old to @new for #@did.',
      array('@did' => $donation->did, '@old' => $old_amount, '@new' => $donation->donation->donation_amount));
  }
  drupal_set_message(t('The amount of all future donations has been updated to @amount.', array('@amount' => $amount)));
}

/**
 * Creates form for billing address update.
 */
function fundraiser_sustainers_billing_update_form($form, &$form_state, $donation, $context) {
  $form['master_order_id'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_order_id, // TODO change this terminology later.
  );
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $donation->donation->uid,
  );
  $form['gateway'] = array(
    '#type' => 'hidden',
    '#value' => $donation->node->gateway,
  );
  $form['reference_id'] = array( //TODO checkthat this is actualyl needed.
    '#type' => 'hidden',
    '#value' => isset($donation->donation->reference_id) ? $donation->donation->reference_id : '',
  );
  $form['billing_address'] = array(
    '#type' => 'fieldset',
    '#title' => t('Billing Address'),
    '#attributes' => array('id' => 'billing-address'),
  );
  $form['billing_address']['first_name'] = array(
    '#type' => 'textfield',
    '#title' => t('First Name'),
    '#required' => TRUE,
    '#default_value' => $donation->donation->billing_first_name,
  );
  $form['billing_address']['last_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Last Name'),
    '#required' => TRUE,  
    '#default_value' => $donation->donation->billing_last_name,
  );
  $form['billing_address']['email'] = array(
    '#type' => 'textfield',
    '#title' => t('Email Address'),
    '#required' => TRUE,
    '#default_value' => $donation->donation->primary_email,
  );
  $form['billing_address']['address_1'] = array(
    '#type' => 'textfield',
    '#title' => t('Address Line 1'),
    '#size' => 30,
    '#required' => TRUE,
    '#default_value' => $donation->donation->billing_street1,
  );
  $form['billing_address']['address_2'] = array(
    '#type' => 'textfield',
    '#title' => t('Address Line 2'),
    '#size' => 30,
    '#default_value' => $donation->donation->billing_street2,
  );
  $form['billing_address']['city'] = array(
    '#type' => 'textfield',
    '#title' => t('City'),
    '#size' => 30,
    '#required' => TRUE,
    '#default_value' => $donation->donation->billing_city,
  );
  // TODO replicate the AJAXy behavior as per the original donation node.
  if (isset($context->countries)) {
    $options = array();
    foreach ($context->countries as $country_id => $country) {
      $options[$country_id] = $country->country_name;
    }
    $form['billing_address']['country'] = array(
      '#type' => 'select',
      '#title' => 'Country',
      '#options' => $options,
      '#required' => TRUE,  
      '#default_value' => $donation->donation->billing_country,
    );
  }
  if (isset($context->zones)) {
    $options = array();
    foreach ($context->zones as $zone_id => $zone) {
      $options[$zone_id] = $zone->zone_name;
    }
    $form['billing_address']['state'] = array(
      '#type' => 'select',
      '#title' => 'State',
      '#options' => $options,
      '#required' => TRUE,
      '#default_value' => $donation->donation->billing_zone,
    );
  }
  $form['billing_address']['zipcode'] = array(
    '#type' => 'textfield',
    '#title' => 'Postal Code',
    '#size' => 5,
    '#maxlength' => 11,
    '#required' => TRUE,  
    '#default_value' => $donation->donation->billing_postal_code,
  );
  // No defaults here, because we don't store this information.
  $form['cc_info'] = array(
    '#type' => 'fieldset',
    '#title' => 'Credit Card Information',
    '#attributes' => array('id' => 'credit-card-info'),
  );
  $form['cc_info']['card_num'] = array(
    '#type' => 'textfield',
    '#title' => 'Card Number',
    '#size' => 20,
    '#required' => TRUE,
    '#maxlength' => 20,
  );
  // Format this a bit.
  $form['cc_info']['card_exp_date'] = array(
    '#type' => 'date',
    '#required' => TRUE,
    '#title' => 'Expiration Date',
    '#default_value' => array('year' => date('Y'), 'month' => 1, 'day' => 1),
    '#process' => array('_fundraiser_sustainers_expand_date'),
  );
  $form['cc_info']['card_cvv'] = array(
    '#type' => 'textfield',
    '#title' => 'Security Code',
    '#required' => TRUE,
    '#size' => 5,
    '#maxlength' => 5,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save changes'),
  );
  return $form;
}

/**
 * Form validation handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_validate($form, &$form_state) {
  // Gather credit card information.
  $cc_number = $form_state['values']['card_num'];
  $cc_expiration_month =  $form_state['values']['card_exp_date']['month'];
  $cc_expiration_year = $form_state['values']['card_exp_date']['year'];
  $cc_cvv = $form_state['values']['card_cvv'];

// TODO - these all need to be changed and updated to match how ubercart is pulled into our system now.
// Perhaps with the validation running through fundraiser field stuff?
  //Validate cc number
  $valid_card = module_invoke_all('fundraiser_validate_card', $cc_number);
  if (!$valid_card[0] || !ctype_digit($cc_number)) {
    form_set_error('cc_info][card_num', "You have entered an invalid credit card number.");
  }
  // Validate the card expiration date.
  $valid_date = module_invoke_all('fundraiser_validate_card_expiration', $cc_expiration_month, $cc_expiration_year);
  if (!$valid_date[0]) {
    form_set_error('cc_info][card_exp_date', t('The credit card you entered has expired.'));
  }
  // Validate the CVV Number
  $valid_cvv = module_invoke_all('fundraiser_validate_card_cvv', $cc_cvv);
  if (!$valid_cvv[0]) {
    form_set_error('cc_info][card_cvv', t('You have entered an invalid CVV number.'));
  }
}

/**
 * Form submit handler for billing address update form.
 */
function fundraiser_sustainers_billing_update_form_submit($form, &$form_state) {
  $master_did = $form_state['values']['master_order_id'];
  $exp_month = $form_state['values']['card_exp_date']['month'];
  $exp_year = $form_state['values']['card_exp_date']['year'];
  $gateway = $form_state['values']['gateway'];
  $reference_id = $form_state['values']['reference_id'];

  // we can only continue if we have a gateway and reference_id // TODO - why? We're not charging here.
  if ($gateway && $reference_id) {
    // First update the stored billing information for the gateway.
    $result = _fundraiser_sustainers_update_gateway_billing($gateway, $reference_id, $form_state['values']);
    // If that worked, then update the saves billing information in fundraiser.
    if ($result) {
      $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
      foreach ($donations as $donation) {
        $donation = fundraiser_donation_get_donation($donation->order_id);
        // Update each one.
        // TODO in the future standardize these fields so we aren't reliant on ubercarts field formatting.
        $donation->donation->primary_email = $form_state['values']['email'];
        $donation->donation->billing_first_name =  $form_state['values']['first_name'];
        $donation->donation->billing_last_name = $form_state['values']['last_name'];
        $donation->donation->billing_city = $form_state['values']['city'];
        $donation->donation->billing_street1 = $form_state['values']['address_1'];
        $donation->donation->billing_street2 = $form_state['values']['address_2'];
        $donation->donation->billing_postal_code = $form_state['values']['zipcode'];
        $donation->donation->billing_zone = $form_state['values']['state'];
        $donation->donation->billing_country = $form_state['values']['country'];
        $donation->donation->payment_method = 'credit';
        $donation->donation->payment_details = array(
          'cc_type' => $donation->donation->payment_details['cc_type'],
          'cc_owner' => isset($donation->donation->payment_details['cc_type']) ? $donation->donation->payment_details['cc_type'] : '',
          'cc_number' => $form_state['values']['card_num'],
          'cc_start_month' => isset($donation->donation->payment_details['cc_start_month']) ? $donation->donation->payment_details['cc_start_month'] : '',
          'cc_start_year' => isset($donation->donation->payment_details['cc_start_year']) ? $donation->donation->payment_details['cc_start_year'] : '',
          'cc_exp_month' => $form_state['values']['card_exp_date']['month'],
          'cc_exp_year' => $form_state['values']['card_exp_date']['year'],
          'cc_issue' => isset($donation->donation->payment_details['cc_issue']) ? $donation->donation->payment_details['cc_issue'] : '',
          'cc_cvv' => $form_state['values']['card_cvv'],
          'cc_bank' => isset($donation->donation->payment_details['cc_bank']) ? $donation->donation->payment_details['cc_bank'] : '',
        );
        fundraiser_donation_update($donation);
        watchdog('fundraiser_sustainers', 'Billing information updated for #@did.',
          array('@did' => $donation->did));
      }
      // Create new orders based on expiration date as needed.
      //TODO update this with new stuffs.
      fundraiser_extend_future_orders($master_order_id, $exp_month, $exp_year);
      drupal_set_message(t('Billing information successfully updated'));
    }
    else {
      drupal_set_message(t('Unable to update billing information at this time'));
    }
  }
}

/**
 * Helper function, update the billing information stored for specific gateways.
 */
function _fundraiser_sustainers_update_gateway_billing($gateway_id, $reference_id, $billing_info) {
  // TODO isn't this effectively just a module invoke for 'update_billing_information' ?
  // this, authorize.net and sage should be converted to proper hooks later. - SeH
  // Perhaps driven off hook_fundraiser_donation_update().
  $function = $gateway_id . '_update_billing_information';
  return $function($reference_id, $billing_info);
}

/**
 * Creates form to cancel donations.
 */
function fundraiser_sustainers_cancel_form($form, &$form_state, $donation) {
  // Only allow certain users to cancel future donations.
  $form['#access'] = user_access('cancel future donations');
  // Otherwise, provide cancel button.
  $form['master_order_id'] = array(
    '#type' => 'hidden',
    '#value' => $donation->recurring->master_order_id,
  );
  $form['reason'] = array(
    '#type' => 'textarea',
    '#title' => t('Reason'),
    '#default_value' => t('Please enter a brief description of why you are cancelling. ' .
      'This will help us better serve you in the future.'),
    '#maxlength' => 500,
    '#cols' => 70,
    '#rows' => 3,
    '#resizable' => FALSE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel all future payments'),
  );
  return $form;  
}

/**
 * Form submit handler for cancel donations form.
 */
function fundraiser_sustainers_cancel_form_submit($form, &$form_state) {
  global $user;
  $master_did = $form_state['values']['master_order_id'];
  $reason = $form_state['values']['reason'];
  if (empty($reason)) {
    $reason = t('No reason given.');
  }
  // Cancel the donations.
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  foreach ($donations as $donation) {
    fundraiser_donation_cancel($donation);
    watchdog('fundraiser_sustainers', 'Donation cancelled for #@did. Reason: @reason',
      array('@did' => $donation->did, '@reason' => $reason));
  }
  //TODO, these are failing to be updated int he recurring table.
  _fundraiser_sustainers_cancel_recurring_by_master($master_did, $reason);
  drupal_set_message(t('All future payments cancelled.'));
}

/**
 * Helper function, override of Drupal core expand_date found in includes/form.inc
 */
function _fundraiser_sustainers_expand_date($element) {
  // Default to current date
  if (empty($element['#value'])) {
    $element['#value'] = array(
      'day' => format_date(time(), 'custom', 'j'),
      'month' => format_date(time(), 'custom', 'n'),
      'year' => format_date(time(), 'custom', 'Y')
    );
  }
  $element['#tree'] = TRUE;

  // Determine the order of day, month, year in the site's chosen date format.
  $format = variable_get('date_format_short', 'm/d/Y - H:i');
  $sort = array();
  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));
  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));
  $sort['year'] = strpos($format, 'Y');
  asort($sort);
  $order = array_keys($sort);
  $current_year = date('Y');

  // Output multi-selector for date.
  foreach ($order as $type) {
    switch ($type) {
      case 'day':
        $options = drupal_map_assoc(range(1, 31));
        break;
      case 'month':
        $options = drupal_map_assoc(range(1, 12), 'map_month');
        break;
      case 'year':
        $options = drupal_map_assoc(range($current_year, $current_year + 10));
        break;
    }
    $parents = $element['#parents'];
    $parents[] = $type;
    $element[$type] = array(
      '#type' => 'select',
      '#value' => $element['#value'][$type],
      '#attributes' => $element['#attributes'],
      '#options' => $options,
    );
    // Hide element day.
    $element['day'] = array(
      '#type' => 'hidden',
      '#value' => 1,
    );
  }
  return $element;
}

/**
 * Helper function, determines if a user has any recurring donations, used as a Menu callback.
 */
function _fundraiser_sustainers_user_has_recurring_donations($user) {
  $donations = _fundraiser_sustainers_get_donation_sets_recurr_by_uid($user->uid);
  if (!$donations) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Helper function, kick off recurring donations for payment. Called on cron usually.
 */
function fundraiser_sustainers_process_recurring_donations() {
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_recurring');
  $successes = 0;
  $fails = 0;
  $donations = _fundraiser_sustainers_cron_get_recurring();
  // Loop over the found orders
  foreach ($donations as $recurring) {
    // Recreate the donation to process from the given values.
    // order_id = did for storing recurring orders. 
    // TODO rename this column for consistant handling of terms.
    $donation = fundraiser_donation_get_donation($recurring->order_id);
    // The donation information should be at at $donation['donation'], ready to process.
    fundraiser_donation_process($donation);
    // The results should be at $donation['result'], ready to respond to the aftermath.
    $result = $donation['result'];
    if (isset($result['success']) && $result['success']) {
      fundraiser_donation_success($donation);
      // Record the success.
      $successes++;
    }
    else {
      fundraiser_donation_decline($donation);
      // Record the fail.
      $fails++;
    }
  }
  if ($successes > 0 || $fails > 0) {
    watchdog('fundraiser_sustainers', '!successes recurring donations processed successfully; !fails failed.',
      array('!successes' => $successes, '!fails' => $fails));
  }
  // And after all of that is done, provide a hook to allow for modules to respond.
  module_invoke_all('fundraiser_donation_post_recurring');
}

/**
 * Helper function, loads the recurring donation processor key.
 */
function fundraiser_sustainers_processor_key_match() {
  static $key;
  if (!empty($key)) {
    return ($key == $_SERVER['HTTP_HOST']);
  }
  $dir = module_invoke_all('fundraiser_get_credit_encryption_path');
  $dir = $dir[0];
  if ($dir && $dir !== t('Not configured, see below.')) {
    $filename = rtrim($dir, '/\\') . '/sustainer.key';
    if (file_exists($filename)) {
      if (!$file = fopen($filename, 'r')) {
        return FALSE;
      }
      $key = fread($file, filesize($filename));
      if (trim($key) != trim($_SERVER['HTTP_HOST'])) {
        return FALSE;
      }
      fclose($file);
    }
    else {
      return FALSE;
    }
  }
  else {
    return FALSE;
  }
  return TRUE;
}

/**
 * Helper function, kicks off an email to a sustainer to remind them their credit card is about to expire.
 */
function _fundraiser_sustainers_send_cc_notification($master_order_id, $uid) {
  $user = user_load($uid);
  // load the last remaining order so we can get some info for the email
  $order_id = db_query('SELECT order_id FROM {fundraiser_recurring} WHERE master_order_id = :master_order_id AND gateway_resp IS NULL',
    array(':master_order_id' => $master_order_id))->fetchColumn();
  // Get the order data from our order handler (Ubercart).
  $order = module_invoke_all('fundraiser_get_order', $order_id);
  $order = $order[0];

  // Set up some params that can be used in the email.
  $params['exp_month'] = $order->payment_details['cc_exp_month'];
  $params['exp_year'] = $order->payment_details['cc_exp_year'];
  $params['cc_last_4'] = substr($order->payment_details['cc_number'], -4);
  $params['cc_type'] = $order->payment_details['cc_type'];
  $params['amount'] = $order->order_total;
  $params['order_id'] = $order_id;
  $params['user'] = $user;
  $params['master_order_id'] = $master_order_id;

  watchdog('fundraiser_sustainers', 'Credit card expiration email sent to @mail', array('@mail' => $user->mail), WATCHDOG_INFO);
  drupal_mail('fundraiser', 'fundraiser_cc_notification', $user->mail, user_preferred_language($user), $params);
}

/**
 * CRUD style DB function for fundraiser_recurring.
 */
function _fundraiser_sustainers_create_recurring($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = $donation;
    drupal_write_record('fundraiser_recurring', $record);
  }
  else {
    _fundraiser_sustainers_update_recurring($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_recurring.
 */
function _fundraiser_sustainers_get_recurring_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_recurring} ' .
    'WHERE order_id = :order_id',
    array(':order_id' => $did))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_recurring.
 */
function _fundraiser_sustainers_update_recurring($donation) {
  // Cast donation just in case.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_sustainers_get_recurring_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_sustainers_create_recurring($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_recurring', $record, 'order_id');
  }
}

/**
 * CRUD style DB function for fundraiser_recurring.
 */
function _fundraiser_sustainers_delete_recurring($did) {
  db_delete('fundraiser_recurring')->condition('order_id', $did)->execute();
}

/**
 * DB function, delete recurring given a master did.
 */
function _fundraiser_sustainers_delete_recurring_by_master($master_did) {
  db_delete('fundraiser_recurring')->condition('master_order_id', $master_did)->execute();
}

/**
 * DB function, cancel recurring given a master did. (Do not delete!)
 */
function _fundraiser_sustainers_cancel_recurring_by_master($master_did, $reason) {
  db_query('UPDATE {fundraiser_recurring} '.
    'SET gateway_resp = \'canceled\', cancellation_reason = :reason '.
    'WHERE master_order_id = :master_order_id AND (gateway_resp IS NULL OR gateway_resp = \'failed\')',
    array(':reason' => $reason, ':master_order_id' => $master_did));
}
    
/**
 * DB funct, get user donations that are recurring.
 */
function _fundraiser_sustainers_get_donations_recurr_by_uid($uid) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE d.uid = :uid ' .
   'ORDER BY r.next_charge ASC', array(':uid' => $uid))->fetchAll();
  return $donations;
}

/**
 * DB funct, get user donation set information that are recurring.
 */
function _fundraiser_sustainers_get_donation_sets_recurr_by_uid($uid) {
  $donation_sets = db_query('SELECT r.master_order_id, MIN(r.next_charge) AS start_date, ' .
   'MAX(r.next_charge) AS expire_date FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE d.uid = :uid ' .
   'GROUP BY r.master_order_id ' .
   'ORDER BY r.master_order_id DESC', array(':uid' => $uid))->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_order_id);
    $donation_sets[$index]->next_charge_date = $next_charge->next_charge;
    $donation_sets[$index]->status = isset($next_charge->cancellation_reason) ? 'cancelled' : 'active';
  }
  return $donation_sets;
}

/**
 * DB funct, get user donation set information that are recurring.
 */
function _fundraiser_sustainers_get_donation_sets() {
  $donation_sets = db_query('SELECT r.master_order_id, MIN(r.next_charge) AS start_date, ' .
   'MAX(r.next_charge) AS expire_date FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE r.master_order_id = r.order_id ' .
   'GROUP BY r.master_order_id ' .
   'ORDER BY r.master_order_id DESC')->fetchAll();
  foreach ($donation_sets as $index => $donation_set) {
    $next_charge = _fundraiser_sustainers_get_donations_next_charge($donation_set->master_order_id);
    $donation_sets[$index]->next_charge_date = $next_charge->next_charge;
    $donation_sets[$index]->status = isset($next_charge->cancellation_reason) ? 'cancelled' : 'active';
  }
  return $donation_sets;
}


/**
 * DB funct, get order donations that are recurring.
 */
function _fundraiser_sustainers_get_donations_recurr_by_member($did) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE d.did = :did OR r.master_order_id = :master_did ' .
   'ORDER BY r.next_charge ASC', array(':did' => $did, ':master_did' => $did))->fetchAll();
  return $donations;
}

/**
 * DB func, get the next charge date for a donation set.
 */
function _fundraiser_sustainers_get_donations_next_charge($master_did) {
  $now = strtotime('now');
  return db_query('SELECT * FROM {fundraiser_recurring} ' .
    'WHERE master_order_id = :master_did ' .
    'AND next_charge > :now ' .
    'ORDER BY next_charge ASC ' .
    'LIMIT 0, 1',
    array(':master_did' => $master_did, ':now' => $now))->fetchObject();
}

/**
 * DB funct, get order donations that are recurring.
 */
function _fundraiser_sustainers_get_donations_recurr_by_did($did) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE d.did = :did ' .
   'ORDER BY r.next_charge ASC', array(':did' => $did))->fetchAll();
  return $donations;
}

/**
 * DB funct, get order donations that are recurring.
 */
function _fundraiser_sustainers_get_donations_recurr_by_masterdid($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE r.master_order_id = :master_order_id ' .
   'ORDER BY r.next_charge ASC', array(':master_order_id' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are remaining.
 */
function _fundraiser_sustainers_count_donations_recurr_remaining($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_remaining($master_did);
  if ($donations) {
    return count($donations);
  }
  return 0;
}

/**
 * DB funct, get order donation sets that are remaining.
 */
function _fundraiser_sustainers_get_donations_recurr_remaining($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE r.master_order_id = :master_did ' .
   'AND (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\' OR r.gateway_resp = \'canceled\') ' .
   'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB funct, count order donation sets that are processed.
 */
function _fundraiser_sustainers_count_donations_recurr_processed($master_did) {
  $donations = _fundraiser_sustainers_get_donations_recurr_processed($master_did);
  if ($donations) {
    return count($donations);
  }
  return 0;
}

/**
 * DB funct, get order donation sets that are processed.
 */
function _fundraiser_sustainers_get_donations_recurr_processed($master_did) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE r.master_order_id = :master_did ' .
   'AND r.gateway_resp = \'success\' ' .
   'ORDER BY r.next_charge ASC', array(':master_did' => $master_did))->fetchAll();
  return $donations;
}

/**
 * DB function, get donations ready to be processed.
 */
function _fundraiser_sustainers_cron_get_recurring($limit = 1000) {
  $donations = db_query('SELECT * FROM {fundraiser_recurring} r ' .
   'LEFT JOIN {fundraiser_donation} d on r.order_id = d.did ' .
   'WHERE r.master_order_id = :master_did ' .
   'AND (r.gateway_resp IS NULL OR r.gateway_resp = \'failed\') ' .
   'ORDER BY r.next_charge ASC ' .
   'LIMIT 0, :limit',
   array(':master_did' => $master_did, ':limit' => $limit))->fetchAll();
  return $donations;
}