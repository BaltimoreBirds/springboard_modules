<?php

/**
 * @file
 * Primary module file for Fundraiser Date Mode. Contains required hook implementations and associated helper functions. 
 */

/**
 * Implements hook_permission().
 */
function fundraiser_date_mode_permission() {
  return array(
    'administer fundraiser date mode' => array(
      'title' => t('Administer Fundraiser date mode'),
      'description' => t('Configure sustainer series charge dates.'),
    ),
  );
}


/**
 * Implements hook_menu().
 */
function fundraiser_date_mode_menu() {
  $items['admin/config/system/fundraiser/date-mode'] = array(
    'title' => 'Date Mode settings',
    'description' => 'Configure sustainer series charge date mode.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_date_mode_admin'),
    'access arguments' => array('administer fundraiser date mode'),
    'file' => 'fundraiser_date_mode.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_system_info_alter().
 */
function fundraiser_date_mode_system_info_alter(&$info, $file, $type) {
  if ($type == 'module' && $file->name == 'fundraiser_date_mode') {
    // Attempting to revert sustainer series next_charge dates during
    // hook_uninstall() is a recipe for disaster. For sites with a large
    // number of sustainers odds are excellent this process would time out.
    //
    // Prevent site administrators from uninstalling this module while date
    // mode is enabled.
    $date_mode = variable_get('fundraiser_date_mode_set_date_mode', FALSE);
    if ($date_mode) {
      $info['required'] = TRUE;
      $info['explanation'] = t('Date mode is enabled. To disable or uninstall this module date mode must be turned off.');
    }
  }
}

/**
 * Implements hook_fundraiser_sustainers_series_created().
 *
 * If date mode is enabled we want to save the original anniversary next_charge
 * dates whenever a new sustainer series is generated.
 */
function fundraiser_date_mode_fundraiser_sustainers_series_created($master_did) {
  if (variable_get('fundraiser_date_mode_set_date_mode', FALSE)) {
    fundraiser_date_mode_save_series_charge_dates($master_did);
  }
}

/**
 * Implements hook_fundraiser_sustainers_recurring_next_charge_alter().
 */
function fundraiser_date_mode_fundraiser_sustainers_recurring_next_charge_alter(&$next_charge, $context) {
  if (variable_get('fundraiser_date_mode_set_date_mode', FALSE)) {
    $new_date = variable_get('fundraiser_date_mode_set_dates',15);
    // Save the original anniversary charge date calculated by
    // fundraiser_sustainers.

    $record = array(
      'master_did' => $context['master_did'],
      'did' => $context['did'],
      'original_next_charge' => $next_charge,
    );
    drupal_write_record('fundraiser_date_mode_dates', $record);

    // Override anniversary date with date mode charge date.
    // If the next charge is in this month, leave it alone.
    // This should prevent sliding charges into the past.
    $order_time = _fundraiser_date_mode_explode_date($next_charge);
    $current_time = _fundraiser_date_mode_explode_date(time());
    if ($order_time['year'] == $current_time['year'] && $order_time['month'] == $current_time['month']) {
      return;
    }

    // No change, skip it.
    if ($new_date && $order_time['day'] == $new_date) {
      return;
    }
    $delta = _fundraiser_date_mode_calculate_delta($next_charge, $new_date);
    $next_charge = $next_charge + $delta;
  }
}

/**
 * Return a count of total pending future sustainer orders.
 */
function fundraiser_date_mode_max_records() {
  $result = db_query('
    SELECT COUNT(master_did)
    FROM {fundraiser_sustainers}
    WHERE
      next_charge > UNIX_TIMESTAMP(NOW())
    AND
      gateway_resp IS NULL'
  );
  return $result->fetchField();
}

/**
 * Identifies which sustainer series records need to be updated based on
 * current time and what day of the month sustainer orders will be processed.
 *
 * @param array $orders
 *   An array of sustainer series order records.
 *
 * @param int $new_date
 *   Day of the month sustainers should be processed.
 *
 * @return array
 *   Returns an array of sustainer series records that have next_charge
 *   values that will need to be updated based on the day selection.
 */
function _fundraiser_date_mode_orders_to_change($orders, $new_date = NULL) {
  $selected_orders = array();
  $current_time = _fundraiser_date_mode_explode_date(time());

  foreach ($orders as $order) {
    $order_time = _fundraiser_date_mode_explode_date($order['next_charge']);
    // Ignore orders that are ready to process.
    if ($order['next_charge'] < time()) {
      drupal_set_message('bailed on charge in the past:' . $order['did']);
      continue;
    }
    // If the next charge is in this month, leave it alone.
    // This should prevent sliding charges into the past.
    if ($order_time['year'] == $current_time['year'] && $order_time['month'] == $current_time['month']) {
      drupal_set_message('bailed on charge is in this month:' . $order['did']);
      continue;
    }

    // Skip future failed and canceled orders.
    // This also shouldn't happen, $data should only contain orders with
    // NULL gateway_resp.
    if (in_array($order['gateway_resp'], array('failed', 'canceled'))) {
      drupal_set_message('bailed on gateway_resp:' . $order['did']);
      continue;
    }
    // No change, skip it.
    if ($new_date && $order_time['day'] == $new_date) {
      drupal_set_message('bailed on order == new date:' . $order['did']);
      continue;
    }

    $selected_orders[] = $order['did'];
  }
  dsm($selected_orders);
  return $selected_orders;
}

/**
 * Calculates the time difference (in seconds) between a given date and an
 * arbitrary day of the month.
 *
 * @param int $charge_time
 *   Next charge timestamp
 *
 * @param $date
 *   New day of the month
 *
 * @return int
 *   Number of seconds (positive or negative).
 */
function _fundraiser_date_mode_calculate_delta($charge_time, $date) {
  $original_charge_date = _fundraiser_date_mode_explode_date($charge_time);
  // 86400 seconds in 24 hours.
  $delta = ($original_charge_date['day'] - $date) * 86400;
  $delta = $delta * -1;
  return $delta;
}

/**
 * Verify all series orders fall on the same day of the month.
 *
 * @param array $series_orders
 *  Array of sustainer series order records.
 *
 * @return bool
 *   Returns TRUE if all orders fall on the same day of the month.
 */
function _fundraiser_date_mode_validate_order_dates($series_orders, $master_order_day = NULL) {
  $dates = array();
  foreach ($series_orders as $order) {
    $date = _fundraiser_date_mode_explode_date($order['next_charge']);
    // If supplied, validate order days against the master order day.
    if ($master_order_day && $master_order_day != $date['day']) {
      return FALSE;
    }
    if (!in_array($date['day'], $dates)) {
      $dates[] = $date['day'];
    }
  }
  return count($dates) === 1 ? TRUE : FALSE;
}

/**
 * Convert a timestamp to a keyed array of date values.
 *
 * @param int $timestamp
 *   Unix timestamp to convert.
 *
 * @return array
 *   Returns an associative array with the following keys:
 *   - year
 *   - month
 *   - day
 *   - hour
 *   - minute
 *   - second
 */
function _fundraiser_date_mode_explode_date($timestamp) {
  $date_string = date('Y/n/j/G/i/s', $timestamp);
  $date = explode('/', $date_string);
  $time = array(
    'year' => $date[0],
    'month' => $date[1],
    'day' => $date[2],
    'hour' => $date[3],
    'minute' => $date[4],
    'second' => $date[5],
  );
  return $time;
}

/**
 *
 */
function fundraiser_date_mode_save_series_charge_dates($master_did) {
  // As a precaution, purge any existing records for this series.
  db_delete('fundraiser_date_mode_dates')
    ->condition('master_did', $master_did. '=')
    ->execute();

  db_query('
    INSERT INTO {fundraiser_date_mode_dates}
      (did, master_did, original_next_charge)
    (
      SELECT did, master_did, next_charge
      FROM {fundraiser_sustainers}
      WHERE
        master_did = :master_did
      AND
        from_unixtime(next_charge) > now()
      AND
        gateway_resp IS NULL
  )', array(':master_did' => $master_did));
}

/**
 *
 */
function fundraiser_date_mode_load_original_dates($master_did) {
  $data = array();
  $results = db_query('
    SELECT
      did,
      original_next_charge
    FROM {fundraiser_date_mode_dates}
    WHERE
      master_did = :master_did
  ', array(':master_did' => $master_did));

  while ($record = $results->fetchAssoc()) {
    $data[$record['did']]['original_next_charge'] = $record['original_next_charge'];
  }
  return $data;
}

function _fundraiser_date_mode_revert_sustainer_dates($master_order, $series_orders) {
  $original_dates = fundraiser_date_mode_load_original_dates($master_order['master_did']);
  $orders_to_revert = _fundraiser_date_mode_orders_to_change($series_orders);
  dsm($original_dates, 'original dates');
  dsm($orders_to_revert, 'orders to revert');
  foreach ($orders_to_revert as $did ) {
    db_update('fundraiser_sustainers')
      ->fields(array(
        'next_charge' => $original_dates[$did]['original_next_charge'],
      ))
      ->condition('master_did', $master_order['master_did'], '=')
      ->condition('did', $did, '=')
      ->execute();
  }
}

function fundraiser_date_mode_get_sustainer_series_data() {
  $query = db_query("
    SELECT
      DISTINCT master_did
    FROM {fundraiser_sustainers}
    WHERE
      next_charge > UNIX_TIMESTAMP(NOW())
    ORDER BY
      master_did ASC,
      next_charge ASC"
  );

  while ($master_did = $query->fetchField()) {

    $results = db_query('
      SELECT *
      FROM {fundraiser_sustainers}
      WHERE
        master_did = :master_did
    ', array(':master_did' => $master_did));

    while ($row = $results->fetchAssoc()) {
      if ($row['master_did'] == $row['did']) {
        $data[$row['master_did']]['master_order'] = $row;
      }
      else {
        if ($row['next_charge'] > time() && empty($row['gateway_resp'])) {
          $data[$row['master_did']]['series'][] = $row;
        }
      }
    }
  }
  return $data;
}

/**
 * Update next_charge for an entire sustainer series.
 */
function fundraiser_date_mode_update_sustainer_date($time_delta, $master_did, $dids) {
  if ($time_delta < 0) {
    $operator = '-';
    $time_delta = $time_delta * -1;
  }
  else {
    $operator = '+';
  }

  drupal_set_message("operator:$operator time delta:$time_delta");
  $query = db_update('fundraiser_sustainers') // Table name no longer needs {}
    ->expression('next_charge', '( next_charge ' . $operator . ' :delta )', array(':delta' => $time_delta))
    ->condition('master_did', $master_did, '=');
  if (is_array($dids)) {
    $query->condition('did', $dids, 'IN');
  }
  else {
    $query->condition('did', $dids, '=');
  }
  $query->execute();
}

/**
 * @param $master_did
 */
function fudnraiser_date_mode_save_original_dates($master_did) {

}
