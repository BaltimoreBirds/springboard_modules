<?php

/**
 * @file
 * Commerce based hook implementations for the fundraiser module donations.
 */

// Commerce mail rules can / should be turned off on installation, so no need to implement hook_mail_alter().

/**
 * Implements hook_menu
 */
function fundraiser_commerce_menu() {
  $items = array();
  $items['fundraiser-commerce/redirect/%'] = array(
    'page callback' => 'fundraiser_commerce_payment_redirect',
    'page arguments' => array(2),
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Implements hook_entity_view().
 */
function fundraiser_commerce_entity_view($entity, $type, $view_mode, $langcode) {
  switch ($type) {
    case 'commerce_order':
      if ($view_mode == 'administrator' || $view_mode == 'full') {
        $entity->content['fundraiser_donation'] = array(
          '#prefix' => '<div class="field field-name-fundraiser-donation field-type-fundraiser-donation field-label-above">' .
            '<div class="field-label">' . t('Fundraiser information') . ': </div>' .
            '<div class="field-items"><div class="field-item even">',
          '#markup' => fundraiser_donation_information_table($entity->order_id), // Table format.
          '#suffix' => '</div></div></div>',
        );
      }
    break;
    default:
  }
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function fundraiser_commerce_commerce_line_item_type_info() {
  $line_item_types = array();
  $line_item_types['donation'] = array(
    'type' => 'donation', 
    'name' => t('Donation'), 
    'description' => t('A donation charge, no product referenced here just the amount.'), 
    'product' => FALSE, 
    'add_form_submit_value' => t('Add donation'), 
    'base' => 'commerce_donation_line_item',
  );
  return $line_item_types;
}

/**
 * Implements hook_LINE_ITEM_BASE_configuration().
 * This function is called by the line item module when it is enabled or this module is enabled.
 */
// function commerce_donation_line_item_configuration($line_item_type) {}

/**
 * Implements hook_LINE_ITEM_BASE_title().
 * Returns an appropriate title for this line item.
 */
function commerce_donation_line_item_title($line_item) {
  $donation = fundraiser_donation_get_donation($line_item->order_id);
  return t('Donation for Fundraiser #%nid %title', array('%nid' => $donation->nid, '%title' => $donation->node->title));
}

/**
 * Implements hook_LINE_ITEM_BASE_add_form().
 * Returns the elements necessary to add a product line item through a line item manager widget.
 */
function commerce_donation_line_item_add_form($element, &$form_state) {
  $form = array();
  $form['amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Amount'),
    '#description' => t('Enter the amount of the donation to add to the order.'),
    '#size' => 60,
    '#maxlength' => 255,
  );
  if (function_exists('fundraiser_multi_currency_get_currencies')) {
    $multi_currancy = fundraiser_multi_currency_get_currencies();
    $available_currancy = array();
    foreach ($multi_currancy as $currancy) {
      $available_currancy[$currancy->code] = $currancy->name;
    }
    $form['currency'] = array(
      '#type' => 'select',
      '#title' => t('Currency'),
      '#description' => t('Enter the currency of the donation to add to the order.'),
      '#options' => $available_currancy,
    );
  }
  // TODO - select a fundraiser to associate this with.
  // AND add support when a donation is submitted via this order form, to update a donation obj and submission with the given amount.
  // All this for later.
  // For now, display a 'not from here' message.
  $form['fundraiser_donation'] = array(
    '#markup' => '<div class="commerce-donation-line-item-warning">' .
      t('Warning: Donation line items added through this interface do not generate an additional donation object in the Fundraiser system,' .
        'or update a donation associated with this order to the new amount. Please do not use this to update donations on orders.') . '</div>',
  );
  return $form;
}

/**
 * Submit handler for commerce_donation_line_item_add_form().
 */
function commerce_donation_line_item_add_form_submit(&$line_item, $element, &$form_state, $form) {
  $values = $element['actions'];
  if (!empty($values['amount']['#value']) && is_numeric($values['amount']['#value'])) {
    $values['currency']['#value'] = isset($values['currency']['#value']) ? $values['currency']['#value'] : 'USD';
    // Create a line item for this order. Contains order amount info.
    $line_item->line_item_label = t('Donation');
    $line_item->quantity = 1;
    $line_item->commerce_unit_price[LANGUAGE_NONE][0] = array(
      'amount' => commerce_currency_decimal_to_amount($values['amount']['#value'], $values['currency']['#value']), 
      'currency_code' => $values['currency']['#value'],
    );
    // Make sure the line item will be included in the update for order total.
    $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data'] = commerce_price_component_add(
      $line_item->commerce_unit_price[LANGUAGE_NONE][0],
      'base_price',
      array(
        'amount' => commerce_currency_decimal_to_amount($values['amount']['#value'], $values['currency']['#value']),
        'currency_code' => $values['currency']['#value'],
        'data' => array(),
      ),
      TRUE
    );
  }
  else {
    return t('You have entered an invalid amount.');
  }
}

/**
 * Implements hook_commerce_order_status_info().
 */
function fundraiser_commerce_commerce_order_status_info() {
  $fundraiser_statuses = array(
    'pending_future_payment' => array(
      'name' => 'pending_future_payment',
      'title' => 'Pending Future Payment',
      'state' => 'pending',
    ),
    'failed' => array(
      'name' => 'failed',
      'title' => 'Failed',
      'state' => 'canceled',
    ),
    'refunded' => array(
      'name' => 'refunded',
      'title' => 'Refunded',
      'state' => 'completed',
    ),
    'payment_received' => array(
      'name' => 'payment_received',
      'title' => 'Payment Received',
      'state' => 'completed',
    ),
    'partially_refunded' => array(
      'name' => 'partially_refunded',
      'title' => 'Partially Refunded',
      'state' => 'completed',
    ),
  );
  return $fundraiser_statuses;
}

/**
 * Implements hook_fundraiser_gateway_info().
 */
function fundraiser_commerce_fundraiser_gateway_info() {
  /// Load all the methods available.
  $methods = new stdClass();
  $methods->payment_methods = array();
  rules_invoke_all('commerce_payment_methods', $methods);
  $fundraiser_gateways = array();
  foreach ($methods->payment_methods as $id => $info) {
    $this_gateway = array();
    $method_instance = commerce_payment_method_instance_load($id); // From commerce_payment.module.
    list($method_id, $rule_name) = explode('|', $method_instance['instance_id']);
    // Load the rule configuration
    if (!empty($method_id) && !empty($rule_name)) {
      $rule_config = rules_config_load($rule_name);
      $this_gateway['id'] = $method_instance['instance_id'];
      $this_gateway['module'] = 'fundraiser_commerce';
      $this_gateway['module_name'] = t('Commerce');
      $this_gateway['title'] = $rule_config->label;
      $this_gateway['description'] = $method_instance['description'];
      $this_gateway['charge_function'] = $method_instance['callbacks']['submit_form_submit'];
      $this_gateway['refund_function'] = $method_instance['callbacks']['submit_form_submit'];
      // Gather additional details per our specific implementation.
      // Re: type of fieldset, and available recurring features.
      module_load_include('inc', 'fundraiser_commerce', '/gateways/' . $method_instance['module']);
      $this_gateway += module_invoke($method_instance['module'], 'fundraiser_commerce_fundraiser_gateway_info');
      $this_gateway['gateway_details'] = $method_instance;
      $fundraiser_gateways[] = $this_gateway; 
    }
  }
  return $fundraiser_gateways;
}

/**
 * Implements hook_fundraiser_field_info_alter().
 */
function fundraiser_commerce_fundraiser_field_info_alter(&$fields) {
  // TODO review this code, perhaps we can push it further up into fundraiser proper.
  // That would also avoid the wierd ajaxy stuff we have to do to get reference back working.
  $countries = fundraiser_commerce_get_countries();
  $include_all_countries = variable_get('fundraiser_all_countries', 0);
  $default_available = array('US', 'CA');
  $options = '';
  if ($include_all_countries) {
    foreach ($countries->countries as $country_id => $country) {
      $options .= $country->iso . '|' . $country->country_name . "\n";
    }
  }
  else {
    foreach ($countries->countries as $country_id => $country) {
      if (in_array($country->iso, $default_available)) {
        $options .= $country->iso . '|' . $country->country_name . "\n";
      }
    }
  }
  $fields['billing_information']['country'] = array(
    '#title' => t('Country'),
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $options,
      'multiple' => 0,
      'aslist' => 1,
    ),
    '#display_callback' => '_fundraiser_commerce_country_field_display',
  );
  $options = '';
  foreach ($countries->zones as $zone_id => $zone) {
    $options .= $zone->iso . '|' . $zone->zone_name . "\n";
  }
  $fields['billing_information']['state'] = array(
    '#title' => t('State/Province'),
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $options,
      'multiple' => 0,
      'aslist' => 1,
    ),
    '#display_callback' => '_fundraiser_commerce_zone_field_display',
  );
  // Add our own validation routines to the billing fields for credit cards.
  $fields['payment_information']['payment_fields']['#validate_callback'] = '_fundraiser_commerce_payment_fields_validate';
  return $fields;
}

/**
 * Validation callback for field payment_fields.
 */
function _fundraiser_commerce_payment_fields_validate($form, $form_state, $submission_fields, $value) {
  // TODO this should probably be driven down to the gateway level.
  $payment_method = $submission_fields['payment_method'];
  if ($payment_method == 'credit') {
    module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card'); // Include the file with the validation info.
    $number = $value['credit']['card_number'];
    $valid = commerce_payment_validate_credit_card_number($number);
    if (!$valid || !ctype_digit($number) || drupal_strlen($number) < 10) {
      return t('You have entered an invalid credit card number.');
    }
    $cvv = $value['credit']['card_cvv'];
    $valid = commerce_payment_validate_credit_card_security_code($number, $cvv);
    if (!$valid && !empty($cvv)) {
      return t('You have entered an invalid CVV number.');
    }
    $cc_expiration_month = $value['credit']['card_expiration_month'];
    $cc_expiration_year = $value['credit']['card_expiration_year'];
    $valid = commerce_payment_validate_credit_card_exp_date($cc_expiration_month, $cc_expiration_year);
    if (!$valid && !empty($cc_expiration_month) && !empty($cc_expiration_year)) {
      return t('The credit card you entered has expired.');
    }
  }
}
/**
 * Display callback for field country. Set the defaults if the country has it.
 */
function _fundraiser_commerce_country_field_display($form, $form_state, $field) {
  // Flatten form state array so we can get the user selection easier.
  $fields = _fundraiser_commerce_submission_flatten($form_state);
  // Set the default country if form_state has it.
  if (array_key_exists('country', $fields)) {
    $field['#default_value'] = $fields['country'];
  }
  $field['#ajax'] = array(
    'callback' => '_fundraiser_commerce_client_state_ajax_submit',
    'wrapper' => 'zone-select-wrapper',
    'method' => 'replace',
    'effect' => 'fade',
  );
  return $field;
}

/**
 * Helper function, flatten webforms submitted tree into an array mapping fields to values.
 */
function _fundraiser_commerce_submission_flatten($submit_tree) {
  $flat_array = array();
  foreach ($submit_tree as $key => $value) {
    if (!is_array($submit_tree[$key])) {
      $flat_array[$key] = $value;
    }
    else {
      $flat_array = array_merge($flat_array, _fundraiser_commerce_submission_flatten($value));
    }
  }
  return $flat_array;
}

/**
 * AJAX callback for dealing with changes to the donation form.
 */
function _fundraiser_commerce_client_state_ajax_submit($form, $form_state, &$mess = '') {
  // Get the form item we want to render.
  return fundraiser_get_form_field($form['#calling_module'], $form, 'state');
}

/**
 * Display callback for field zone, to set the default based on the country given.
 */
function _fundraiser_commerce_zone_field_display($form, $form_state, $field) {
  // Get countries.
  $countries = fundraiser_commerce_get_countries();
  // Flatten form state array so we can get the user selection easier.
  $fields = _fundraiser_commerce_submission_flatten($form_state);
  // Country/state dependant drop down code
  $available_zones = isset($countries->zones) ? $countries->zones : array();
  // Filter the available zones by the set country.
  if (array_key_exists('country', $fields)) {
    $country_id = $fields['country'];
    // Filter options down to just the zones available for this country.
    if (isset($countries->countries[ $country_id ])) {
      $available_zones = $countries->countries[ $country_id ]->zones;
    }
  }
  else {
    // Provide a default based on the form values.
    $country_field = fundraiser_get_form_field($form['#calling_module'], $form, 'country');
    // Filter options down to just the zones available for this country.
    if (isset($country_field['#default_value'])) {
      $default = $country_field['#default_value'];
      $default = $default;
      if (isset($countries->countries[ $default ])) {
        $available_zones = $countries->countries[ $default ]->zones;
      }
    }
  }
  // Given available zones, filter the dropdown to match.
  if (!empty($available_zones)) {
    $new_zone_options = array();
    foreach ($available_zones as $zone_id => $zone) {
      $new_zone_options[ $zone->iso ] = $zone->zone_name;
    }
    $field['#options'] = $new_zone_options;
  }
  else {
    // If there are no zones to match, then fall back on a non-select solution.
    $field['#type'] = 'textfield';
  }
  $field['#prefix'] = '<div id="zone-select-wrapper">';
  $field['#suffix'] = '</div>';
  return $field;
}

/**
 * Implements hook_fundraiser_donation_get_donation().
 */
function fundraiser_commerce_fundraiser_donation_get_donation($donation) {
  // Load the order object, line items and profile.
  $order = commerce_order_load($donation->did);
  // Data from order.
  $donation->donation['mail'] = isset($order->mail) ? $order->mail : '';
  // Reverse the work done by commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency'])
  // So we have the correct decimaled value.
  $donation->donation['amount'] = commerce_currency_amount_to_decimal($order->commerce_order_total[LANGUAGE_NONE][0]['amount'],
    $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code']);
  // Data from profile.
  if (isset($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id'])) {
    $profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
    $map = array(
      'first_name' => 'first_name',
      'last_name' => 'last_name',
      'address' => 'thoroughfare',
      'address_line_2' => 'premise',
      'city' => 'locality',
      'country' => 'country',
      'state' => 'administrative_area',
      'zip' => 'postal_code',
    );
    $field_info = _fundraiser_get_field_keys();
    foreach ($field_info as $field_name) {
      if (isset($map[$field_name])) {
        $order_name = $map[$field_name];
        $donation->donation[$field_name] = isset($profile->commerce_customer_address[LANGUAGE_NONE][0][$order_name]) ?
          $profile->commerce_customer_address[LANGUAGE_NONE][0][$order_name] : '';
      }
    }
  }
  // Time of last update / charge.
  $donation->last_changed = $order->changed;
  // Add the order status data.
  $donation->status = $donation->status_label = isset($order->status) ? $order->status : 'unknown';
  if (!empty($order->status)) {
    $donation->status_label = _fundraiser_commerce_get_label_by_status($order->status);
    $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->status) ? 1 : 0;
  }
  // This order data was stored during processing, and scrubbed by the gateway.
  $donation->donation['payment_method'] = isset($order->data['payment_method']) ? $order->data['payment_method'] : '';
  $donation->donation['payment_fields']['credit'] = isset($order->data['payment_fields']) ? $order->data['payment_fields'] : '';
  $donation->data = isset($order->data['gateway_data']) ? $order->data['gateway_data'] : '';
}

/**
 * Implements hook_fundraiser_donation_create().
 */
function fundraiser_commerce_fundraiser_donation_create($donation) {
  // Get basic information from the donation node.
  $user = $donation->user;
  $node = $donation->node;
  // Pick out the values we need to generate an order.
  if ($donation->donation['amount'] == 'other') {
    $donation->donation['amount'] = preg_replace('/[^\d\.]/i', '', $donation->donation['other_amount']);
  }
  $donation->donation['currency'] = isset($donation->donation['currency']) ? $donation->donation['currency'] : 'USD';
  // Determine quantity and data from donation values.
  $quantity = isset($donation->donation['quantity']) && !empty($donation->donation['quantity']) ? $donation->donation['quantity'] : 1;

  // Create new order.
  $order = commerce_order_new($user->uid, 'pending', 'commerce_order');
  commerce_order_save($order);
  $order->email = $donation->donation['mail'];

  // Create a line item for this order. Contains order amount info.
  $line_item = commerce_line_item_new('donation', $order->order_id);
  $line_item->line_item_label = t('Donation');
  $line_item->quantity = $quantity;
  $line_item->commerce_unit_price[LANGUAGE_NONE][0] = array(
    'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']), 
    'currency_code' => $donation->donation['currency'],
  );
  // Make sure the line item will be included in the update for order total.
  $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data'] = commerce_price_component_add(
    $line_item->commerce_unit_price[LANGUAGE_NONE][0],
    'base_price',
    array(
      'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']),
      'currency_code' => $donation->donation['currency'],
      'data' => array(),
    ),
    TRUE
  );
  commerce_line_item_save($line_item);
  // Add the line item to the order.
  $order->commerce_line_items[LANGUAGE_NONE][0]['line_item_id'] = $line_item->line_item_id;

  // Save the customer information. Contains billing info.
  // Look up the profile by user id or email, then if not found make a new profile.
  $found = commerce_customer_profile_load_multiple(array(), array('uid' => $user->uid));
  $profile_id = -1;
  foreach($found as $id => $found) {
    $profile_id = $id;
  }
  if ($profile_id != -1) {
    $profile = commerce_customer_profile_load($profile_id);
  }
  else {
    $profile = commerce_customer_profile_new('billing', $user->uid); // Billing type comes with Commerce by default.
  }
  // Update profile with the billing information.
  $profile->commerce_customer_address[LANGUAGE_NONE][0] = addressfield_default_values();
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['country'] = $donation->donation['country'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] = $donation->donation['first_name'] . ' ' . $donation->donation['last_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['first_name'] = $donation->donation['first_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['last_name'] = $donation->donation['last_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['administrative_area'] = $donation->donation['state'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['thoroughfare'] = $donation->donation['address'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['premise'] = $donation->donation['address_line_2'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['locality'] = $donation->donation['city'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['postal_code'] = $donation->donation['zip'];
  commerce_customer_profile_save($profile);
  $order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id'] = $profile->profile_id;

  // Save the order again to update its line item reference field.
  commerce_order_save($order);
  // Set the order id to the donation to carry forward.
  $donation->did = $order->order_id;
  // Set the order status to fundraiser_commerce's status.
  _fundraiser_commerce_update_order_status('pending_future_payment', $donation->did);
  $donation->status_label = _fundraiser_commerce_get_label_by_status('pending_future_payment');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('pending_future_payment');
}

/**
 * Implements hook_fundraiser_donation_process().
 * Could be called immediately after creation, or recurring months later.
 * So could use auth_capture, or could use a reference_txn.
 */
function fundraiser_commerce_fundraiser_donation_process($donation) {
  // Grab the gateway configuration from fundraisers data.
  $info = _fundraiser_get_donation_gateway($donation->did);
  // Check for the charge function to be defined.
  $charge_function = isset($info['charge_function']) ? $info['charge_function'] : '';
  if (empty($charge_function)) {
    // We can't find the gateway and we should tell someone about it.
    watchdog('fundraiser', 'Cannot determine the payment gateway for donation @id. Node id of donation form is @nid',
      array('@id' => $donation->did, '@nid' => $donation->nid), WATCHDOG_CRITICAL);
    watchdog('fundraiser_commerce', 'Charge function :function is empty.', array(':function' => $charge_function));
    $donation->result = array('success' => FALSE, 'message' => 'Cannot determine the payment gateway for this donation.');
    return; // Return the failure.
  }
  /**
    Drupal Commerce doesn’t maintain Ubercart’s separation of payment methods from payment gateways but rather
    defines payment methods as any single way of collecting payment from a customer per payment provider. This
    means there will not be a single Credit Card payment method with plugin modules for CyberSource, Authorize.Net,
    etc. but a separate CC payment method for each payment provider with a common base set of code for building
    credit card forms and handling the data securely.
    See: http://dcorgdev.devcloud.acquia-sites.com/developer-guide/core-architecture/info-hooks/payment-info-hooks
    The Rules configuration for a specific gateway instance contains all of the additional configuration needed.
    Essentially Commerce replicates the behavior of Gateway Manager.
    The problem is when you do this programatically - you don't have a predictable map of values in the form to use.
    Each gateway has a custom form, and so we need to add a plugin to Fundraiser Commerce to wrap donation submissions
    per gateway supported. To avoid module proloferation, we'll use plugins here based on the type of gateway.
    The gateway module itself should handle transaction creation and order updates as if the form were actually submitted.
   */
  // Now execute the custom charge, keeping in mind for Commerce, the charge function is a submit handler.
  $method_instance = commerce_payment_method_instance_load($info['id']); // From commerce_payment.module.
  // This gets us: The payment method instance object with the addition of the settings array. Settings are per Rule.
  // Since the plugin is only relevant in one situation, and then it's Not optional, no need to make it a module.
  // Here we make sure we include the hook implementation.
  module_load_include('inc', 'fundraiser_commerce', '/gateways/' . $method_instance['module']);
  // Call the function with donation, this will handle internal translation for the specific gateway.
  // A specific gateway may implement more than one form of charging (credit and PP for example) so leave that choice
  // to the execution function. All the information needed is on the donation object.
  $result = module_invoke($method_instance['module'], 'fundraiser_commerce_execute_gateway', $method_instance, $donation);
  // Load the order object so we can save additional data post submit.
  $order = commerce_order_load($donation->did);
  // NOTE: The gateway is responsible for scrubbing sensitive data from the payment fields.
  // Also, let's save some critical information to the order object so we can make use of it later.
  $order->data = $donation->data = array(
    'payment_method' => $donation->donation['payment_method'],
    'payment_fields' => $donation->donation['payment_fields'],
    'gateway_data' => isset($result->data) ? $result->data : '',
  );
  // Save the order again to update its line item reference field.
  commerce_order_save($order);
  // If no result then presume a failure or no hook installed for this gateway type.
  if (empty($result)) {
    $donation->result = array('success' => FALSE, 'message' => 'This payment gateway is not supported by Fundraiser Commerce.');
    return; // Return the failure.
  }
  // Pass the result up the chain.
  $donation->result = $result;
  fundraiser_commerce_fundraiser_donation_after_process($donation);
}

/**
 * Helper function, after process for redirected processes to update status etc in one line.
 * Pulled out to make it easier for redirect processes to update the donation on return.
 */
function fundraiser_commerce_fundraiser_donation_after_process($donation) {
  if (isset($donation->result['success']) && $donation->result['success']) {
    // Set the values donation needs for the rest of the system.
    $order = commerce_order_load($donation->did);
    // If a user was created in the midst of that it should be on the order object. If so, add here.
    $donation->uid = $order->uid;
    $donation->user = user_load($order->uid);
    // Add the status data.
    $donation->status = $donation->status_label = isset($order->order_status) ? $order->order_status : 'unknown';
    if (!empty($order->order_status)) {
      $donation->status_label = _fundraiser_commerce_get_label_by_status($order->order_status);
      $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->order_status);
    }
  }
}

/**
 * Implements hook_fundraiser_donation_update().
 */
function fundraiser_commerce_fundraiser_donation_update($donation) {
  // Get basic information from the donation node.
  $user = $donation->user;
  $node = $donation->node;
  // Pick out the values we need to generate an order.
  if ($donation->donation['amount'] == 'other') {
    $donation->donation['amount'] = preg_replace('/[^\d\.]/i', '', $donation->donation['other_amount']);
  }
  $donation->donation['currency'] = isset($donation->donation['currency']) ? $donation->donation['currency'] : 'USD';
  // Determine quantity and data from donation values.
  $quantity = isset($donation->donation['quantity']) && !empty($donation->donation['quantity']) ? $donation->donation['quantity'] : 1;

  // Get the original order.
  $order = commerce_order_load($donation->did);

  // Update the existing line item(s) with the new value.
  $found = commerce_line_item_load_multiple(array(), array('order_id' => $order->order_id));
  $line_item_id = -1;
  foreach($found as $id => $found) {
    $line_item_id = $id;
  }
  if ($line_item_id != -1) {
    $line_item = commerce_line_item_load($line_item_id);
  }
  else {
    $line_item = commerce_line_item_new('donation', $order->order_id);
  }
  // Update line item with the new amount information as needed.
  $line_item->line_item_label = t('Donation');
  $line_item->quantity = $quantity;
  $line_item->commerce_unit_price[LANGUAGE_NONE][0] = array(
    'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']), 
    'currency_code' => $donation->donation['currency'],
  );
  // Make sure the line item will be included in the update for order total.
  $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data'] = commerce_price_component_add(
    $line_item->commerce_unit_price[LANGUAGE_NONE][0],
    'base_price',
    array(
      'amount' => commerce_currency_decimal_to_amount($donation->donation['amount'], $donation->donation['currency']),
      'currency_code' => $donation->donation['currency'],
      'data' => array(),
    ),
    TRUE
  );
  commerce_line_item_save($line_item);
  // Add the line item to the order.
  $order->commerce_line_items[LANGUAGE_NONE][0]['line_item_id'] = $line_item->line_item_id;

  // Update the customer profile with new info.
  $found = commerce_customer_profile_load_multiple(array(), array('uid' => $user->uid));
  $profile_id = -1;
  foreach($found as $id => $found) {
    $profile_id = $id;
  }
  if ($profile_id != -1) {
    $profile = commerce_customer_profile_load($profile_id);
  }
  else {
    $profile = commerce_customer_profile_new('billing', $user->uid); // Billing type comes with Commerce by default.
  }
  // Update profile with the billing information.
  $profile->commerce_customer_address[LANGUAGE_NONE][0] = addressfield_default_values();
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['country'] = $donation->donation['country'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] = $donation->donation['first_name'] . ' ' . $donation->donation['last_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['first_name'] = $donation->donation['first_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['last_name'] = $donation->donation['last_name'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['administrative_area'] = $donation->donation['state'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['thoroughfare'] = $donation->donation['address'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['premise'] = $donation->donation['address_line_2'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['locality'] = $donation->donation['city'];
  $profile->commerce_customer_address[LANGUAGE_NONE][0]['postal_code'] = $donation->donation['zip'];
  commerce_customer_profile_save($profile);
  $order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id'] = $profile->profile_id;

  // Save the order again to update its line item reference field.
  commerce_order_save($order);

  // Add the status data.
  $donation->status = $donation->status_label = isset($order->order_status) ? $order->order_status : 'unknown';
  if (!empty($order->order_status)) {
    $donation->status_label = _fundraiser_commerce_get_label_by_status($order->order_status);
    $donation->status_charged = _fundraiser_commerce_get_charged_by_status($order->order_status);
  }

  // Update the gateway's stored profile.
  // Only relevant for gateways that allow recurring donations.
  if (!empty($donation->update_billing) && $donation->update_billing) {
    // Grab the gateway configuration from fundraisers data.
    $info = _fundraiser_get_donation_gateway($donation->did);
    $method_instance = commerce_payment_method_instance_load($info['id']);
    module_load_include('inc', 'fundraiser_commerce', '/gateways/' . $method_instance['module']);
    $result = module_invoke($method_instance['module'], 'fundraiser_commerce_update_gateway', $method_instance, $donation);
  }

}

/**
 * Implements hook_fundraiser_donation_success().
 */
function fundraiser_commerce_fundraiser_donation_success($donation) {
  // Mark as complete.
  _fundraiser_commerce_update_order_status('payment_received', $donation->did);
  $donation->status_label = _fundraiser_commerce_get_label_by_status('payment_received');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('payment_received');
}

/**
 * Implements hook_fundraiser_donation_decline().
 */
function fundraiser_commerce_fundraiser_donation_decline($donation) {
  // Mark the sale in commerce as failed.
  _fundraiser_commerce_update_order_status('failed', $donation->did);
  $donation->status_label = _fundraiser_commerce_get_label_by_status('failed');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('failed');
}

/**
 * Implements hook_fundraiser_donation_exception().
 */
function fundraiser_commerce_fundraiser_donation_exception($donation) {
  return fundraiser_commerce_fundraiser_donation_decline($donation);
}

/**
 * Implements hook_fundraiser_donation_cancel().
 */
function fundraiser_commerce_fundraiser_donation_cancel($donation) {
  // Mark the sale in commerce as canceled.
  _fundraiser_commerce_update_order_status('canceled', $donation->did);
  $donation->status_label = _fundraiser_commerce_get_label_by_status('canceled');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('canceled');
}

/**
 * Implements hook_fundraiser_donation_delete().
 */
function fundraiser_commerce_fundraiser_donation_delete($donation) {
  // Mark the sale in commerce as canceled.
  _fundraiser_commerce_update_order_status('canceled', $donation->did);
  $donation->status_label = _fundraiser_commerce_get_label_by_status('canceled');
  $donation->status_charged = _fundraiser_commerce_get_charged_by_status('canceled');
}

/**
 * Implements hook_fundraiser_donation_refund().
 */
function fundraiser_commerce_fundraiser_donation_refund($donation) {
  fundraiser_commerce_fundraiser_donation_process($donation);
}

/**
 * Helper function, given a card number return likely type.
 */
function _fundraiser_commerce_get_cc_type($cardnumber) {
  $cardtype = 'UNKNOWN';
  $len = drupal_strlen($cardnumber);
  if ( $len == 15 && drupal_substr($cardnumber, 0, 1) == '3' ) {
    $cardtype = 'amex';
  }
  elseif ( $len == 16 && drupal_substr($cardnumber, 0, 4) == '6011' ) {
    $cardtype = 'discover';
  }
  elseif ( $len == 16 && drupal_substr($cardnumber, 0, 1) == '5' ) {
    $cardtype = 'mc';
  }
  elseif ( ($len == 16 || $len == 13) && drupal_substr($cardnumber, 0, 1) == '4' ) {
    $cardtype = 'visa';
  }
  return ( $cardtype );
}

/**
 * Helper function, gather commerces country information into a central location.
 */
function fundraiser_commerce_get_countries() {
  $countries = array();
  $zones = array();
  // Gather an array of countries.
  $found_countries = _fundraiser_commerce_get_countries();
  foreach ($found_countries as $found_country) {
    // First load up id, name, iso code 2, iso code 3, and version from commerce.
    $countries[$found_country->country_id] = $found_country;
    $countries[$found_country->country_id]->zones = array();
    $found_zones = _fundraiser_commerce_get_zone_by_country($found_country->country_id);
    foreach ($found_zones as $found_zone) {
      // For each zone load up, zone_id, zone country_id, zone, code, zone_name.
      // Store in the country and zone arrays.
      $countries[$found_country->country_id]->zones[$found_zone->zone_id] = $found_zone;
      $zones[$found_zone->zone_id] = $found_zone;
    }
  }
  $return_data->countries = $countries;
  $return_data->zones = $zones;
  return $return_data;
}

/**
 * Helper function, update order status on a order.
 */
function _fundraiser_commerce_update_order_status($status, $order_id) {
  // Commerce order provides four statuses: canceled, pending, processing, completed.
  // We provide (or alter the names of) more: pending_future_payment, failed, refunded, partially_refunded
  $order = commerce_order_load($order_id);
  commerce_order_status_update($order, $status, FALSE); // Do not skip saving the order here.
}

/**
 * Helper function, look in country table for country info.
 */
function _fundraiser_commerce_get_countries() {
  // Commerce does not store countries in a database, it relies instead on locale.inc
  $countries = array();
  // Necessary for country_get_list().
  require_once DRUPAL_ROOT . '/includes/locale.inc';
  $drupal_countries = country_get_list();
  foreach ($drupal_countries as $iso => $human_name) {
    $country['country_id'] = $iso;
    $country['country_name'] = $human_name;
    $country['iso'] = $iso;
    $countries[] = (object) $country;
  }
  return $countries;
}

/**
 * Helper function, look in zone table for zone info.
 */
function _fundraiser_commerce_get_zone_by_country($country_id) {
  // Commerce does not store countries in a database, it relies instead on locale.inc
  // And a hard coded addressfield form widget for zone level information.
  // In order to retrieve this information from Commerce, we need to call the addressfield widget
  // And pull it from the form. The results will be different for each zone, and we can't grab them
  // all at once. So thankfully we don't need to the way the rest of the system is designed.
  // Some countries will have states, and do NOT have them listed here. UC has a more complete list.
  // So we will need to leave those available for users to fill in as blanks.
  module_load_include('inc', 'addressfield', 'plugins/format/address');
  $address['country'] = $country_id;
  addressfield_format_address_generate($form, $address, array('mode' => '')); // Data is loaded into $form
  $zones = array();
  if (isset($form['locality_block']['administrative_area']['#options'])) {
    foreach ($form['locality_block']['administrative_area']['#options'] as $iso => $human_name) {
      $zone['zone_id'] = $iso;
      $zone['country_id'] = $country_id;
      $zone['zone_name'] = $human_name;
      $zone['iso'] = $iso;
      $zones[] = (object) $zone;
    }
  }
  return $zones;
}

/**
 * Helper function. Translate status to status label.
 */
function _fundraiser_commerce_get_label_by_status($status) {
  // Grab the human readable label for the status.
  commerce_order_status_get_title($status); // The machine name of the declares state, we need the human readable label.
}

/**
 * Helper function, determine if given this status the donation has been charged already.
 */
function _fundraiser_commerce_get_charged_by_status($status) {
  $chargable_states = array('pending'); // Commerce order provides three states: canceled, pending, completed.
  $status = commerce_order_status_load($status);
  if (in_array($status['state'], $chargable_states)) {
    return FALSE; // If the donation is still able to be charged, say it hasn't been.
  }
  return TRUE;
}

/**
 * Callback for processing an offsite payment processor
 */
function fundraiser_commerce_payment_redirect($did) {
  // Load up additional data as needed for this donation, from Fundraiser and Commerce.
  $donation = fundraiser_donation_get_donation($did);
  $order = commerce_order_load($donation->did);
  $payment_method = FALSE;
  if (!empty($donation->gateway)) {
    $payment_method = commerce_payment_method_instance_load($donation->gateway['id']);
  }

  // Error check, if the payment method doesn't exist or does not require a redirect.
  if (!$payment_method || !$payment_method['offsite']) {
    if (!$payment_method) {
      $log = t('Customer skipped the redirected Payment page because no payment was required.');
      $donation->result = array(
        'success' => TRUE,
        'comment' => $log,
        'message' => $log,
        'uid' => $order->uid,
        'data' => array(),
        'error type' => '',
      );
    }
    else {
      $log = t('Customer skipped the Payment page because payment was already submitted.');
      // No addtional result needed in this case. The donation has already been kicked off.
    }
    fundraiser_commerce_fundraiser_donation_after_process($donation);
    _fundraiser_donation_submit_after_process($donation);
  }

  // If not a returning value, then we're directing outwards. Provide a form in case the natural redirect stalls out.
  // We get to this point after a redirect from the gateway's own implementation during processing.
  // If the function to build the redirect form exists. 
  $arg3 = arg(3);
  if (empty($arg3)) {
    if ($callback = fundraiser_commerce_payment_method_callback($payment_method, 'redirect_form')) {
      // Generate a key to use in the return URL from the redirected service.
      $order->data['payment_redirect_key'] = drupal_hash_base64(time());
      commerce_order_save($order);
  
      // If the payment method has the 'offsite_autoredirect' option enabled, add
      // the redirection behavior.
      //if (!empty($payment_method['offsite_autoredirect'])) {
      //  $form['#attached']['js'][] = drupal_get_path('module', 'commerce_payment') . '/commerce_payment.js';
      //  $form['help']['#markup'] = '<div class="checkout-help">' . t('Please wait while you are redirected to the payment server. ' .
      //    'If nothing happens within 10 seconds, please click on the button below.') . '</div>';
      //}
  
      // Merge the new form into the current form array, preserving the help text
      // if it exists. We also add a wrapper so the form can be easily submitted.
      $form = drupal_get_form($callback, $order, $payment_method);
      $form['#prefix'] = '<div class="payment-redirect-form">';
      $form['#suffix'] = '</div>';
      return $form;
    }
    else {
      // Alert the administrator that the module does not provide a required form.
      drupal_set_message(t('The %title payment method indicates it is offsite but does not define the necessary ' .
        'form to process the redirect.',
        array('%title' => $payment_method['title'])), 'error');
      return array();
    }
  }

  $log = t('Customer arrived after redirect.');
  // On return, the the user came to the cancel page - they canceled at the gateway.
  if (arg(3) == 'back' && arg(4) == $order->data['payment_redirect_key']) {
    $log = t('Customer canceled the redirected payment at the gateway.');
    $donation->result = array(
      'success' => FALSE,
      'comment' => $log,
      'message' => $log,
      'uid' => $order->uid,
      'data' => array(),
      'error type' => 'billing',
    );
    fundraiser_commerce_fundraiser_donation_after_process($donation);
    _fundraiser_donation_submit_after_process($donation);
  }

  // On return, the user came back to the payment page - they paid at the gateway.
  if (arg(3) == 'return' && arg(4) == $order->data['payment_redirect_key']) {
    // Check for a validate handler on return.
    $validate_callback = fundraiser_commerce_payment_method_callback($payment_method, 'redirect_form_validate');
    if (!$validate_callback || $validate_callback($order, $payment_method) !== FALSE) {
      // Perform any submit functions if necessary.
      if ($callback = fundraiser_commerce_payment_method_callback($payment_method, 'redirect_form_submit')) {
        $callback($order, $payment_method);
      }
      $log = t('Customer successfully paid the redirected payment at the gateway.');
      $donation->result = array(
        'success' => TRUE,
        'comment' => $log,
        'message' => $log,
        'uid' => $order->uid,
        'data' => array(),
        'error type' => '',
      );
      fundraiser_commerce_fundraiser_donation_after_process($donation);
      _fundraiser_donation_submit_after_process($donation);
    }
    else {
      // Otherwise display the failure message and send the customer back.
      drupal_set_message(t('Payment failed at the payment server. Please review your information and try again.'), 'error');
      $log = t('Customer failed to pay the redirected payment at the gateway.');
      $donation->result = array(
        'success' => FALSE,
        'comment' => $log,
        'message' => $log,
        'uid' => $order->uid,
        'data' => array(),
        'error type' => 'billing',
      );
      fundraiser_commerce_fundraiser_donation_after_process($donation);
      _fundraiser_donation_submit_after_process($donation);
    }
  }

  // If we're down to this point, we've returned from a submit redirect. In that case, we redirect the form based on success or failure.
  $form_build_id = cache_get('fundraiser-form-id-' . $did, 'cache');
  if (!empty($form_build_id)) {
    $form_build_id = $form_build_id->data;
    // Given the form build id, get the rest from the form cache.
    $form = cache_get('fundraiser-form-' . $did , 'cache_form');
    $form_state = cache_get('fundraiser-form-state-' . $did  , 'cache_form');
    if (!empty($form) && !empty($form_state)) {
      $form = $form->data;
      $form_state = $form_state->data;
      // Now that we have the form and form_state as they were when we started this redirection, we can hop back in to the flow.
      // Restarting form submission on return is the only good way to make sure all form submits (including webform ones)
      // get kicked off. B/c of the redirects involved we can't pass $form, $form_state along - we need to have it in caches.
      if (!empty($form['#submit'])) {
        // On a failure we pick back up with the form submits.
        $start = FALSE;
        foreach ($form['#submit'] as $index => $submit_handler) {
          // Skip handlers until we get to post submit.
          if ($submit_handler == 'fundraiser_donation_post_submit') {
            unset($form['#submit'][$index]);
          }
        }
        // With the correct set of submit handlers in place, we need to pick up processing again.
        $form_id = $form['#build_id'];
        $form_state['process_input'] = TRUE; // For process form, // Only process the input if we have a correct form submission.
        $form_state['method'] = 'post';
        $form_state['rebuild'] = FALSE;
        $form_state['executed'] = TRUE;
        $form_state['submitted'] = TRUE;
        $form_state['webform_completed'] = TRUE;
        drupal_process_form($form_id, $form, $form_state);
        return array(
          '#markup' => '<div class="fundraiser-commerce-failed-to-redirect">' . $log . ' FORM PROCESS ATTEMPTED TO REDIRECT</div>',
        );
      }
    }
  }
  return array(
    '#markup' => '<div class="fundraiser-commerce-failed-to-redirect">' . $log . '</div>',
  );
}

/**
 * Returns the callback function for a payment method
 *
 * First checks our include files for the callback and then pass it off to commerce if none is found
 */
function fundraiser_commerce_payment_method_callback($payment_method, $callback) {
  // Include our payment method file
  module_load_include('inc', 'fundraiser_commerce', '/gateways/' . $payment_method['module']);
  // If the specified callback function exists, return it.
  if (function_exists($payment_method['module'] . '_fundraiser_commerce_' . $callback)) {
    return $payment_method['module'] . '_fundraiser_commerce_' . $callback;
  }
  // Otherwise pass it to commerce's callback getter   
  return commerce_payment_method_callback($payment_method, $callback);
}
