<?php

/**
 * @file
 * Provides behaviors to handle donation form creation and donation submission.
 */

/**
 * IMPLEMENTATION NOTES:
 *
 * The exact implementation of a donor form as displayed to a user to place a donation has been moved
 * to an exterior module. By default webform. So long as we are using an exterior module to display the 
 * form we want, the exact details will be handled by a glue module to link fundraiser to whatever display
 * implementation we use. This allows us future flexibility and separation of concerns in code.
 *
 * As a result this module does not form_alter webform forms. That's the glue's job. It also means
 * that picking the workflow back up of processing a donation is by executing a process call in fundraiser
 * from the submit in the glue module. So if you don't see a straight path from one to the other in this module
 * it's because the control of flow goes into the glue module before coming back here.
 *
 * Donations themselves are also tracked in an exterior module. By default ubercart. A glue module is
 * provided for this as well. Donations are stored as orders in Ubercart, and the glue module translates. So
 * the exterior module handling the purchasing stage of things is the one that needs to be aware of things like
 * states, user info, and the like. To allow multiple gateways to be used depending on the fundraiser, fundraiser 
 * does interact with a list of available gateways for use during processing.
 *
 * In practice this means, exterior modules are blind to each other, and fundraiser is blind to them. The
 * glue moduled between them are the only systems aware of more than one module at a time.
 */

// TODO: Fundraiser Confirmations are going to be DROPPED IN FAVOR OF EMAIL CONFIRMATIONS.
// WE ARE NO LONGER GOING TO DIFFERNTIATE ON THAT.

define('FUNDRAISER_RECURRING_DONATION_TYPE', 'recurring_donation'); // Used in sf_queru_insert, so move over there.
define('FUNDRAISER_SINGLE_DONATION_TYPE', 'donation'); // Used in sf_queru_insert, so move over there.
define('FUNDRAISER_DONATION_REFUND_TYPE', 'refund');  // Used in sf_queru_insert, so move over there.

// Include theme related functions.
require_once('fundraiser.theme.inc');
// Include confirmation stuff.
require_once('fundraiser.confirmations.inc'); 

/**
 * Implements hook_permission().
 */
function fundraiser_permission() {
  return array(
    'administer fundraiser' => array(
      'title' => t('Administer fundraiser'), 
      'description' => t('Perform administration tasks for fundraiser.'),
    ),
    'create donation form' => array(
      'title' => t('Create donation form'), 
      'description' => t('Create donation forms.'),
    ),
    'edit own donation form' => array(
      'title' => t('Edit own donation form'), 
      'description' => t('Edit own donation forms.'), 
    ),
    'edit any donation form' => array(
      'title' => t('Edit any donation form'), 
      'description' => t('Edit any donation forms.'), 
    ),
    'delete own donation form' => array(
      'title' => t('Delete own donation form'), 
      'description' => t('Delete own donation forms.'), 
    ),
    'delete any donation form' => array(
      'title' => t('Delete any donation form'), 
      'description' => t('Delete any donation forms.'), 
    ),
    'clone donation form' => array(
      'title' => t('Clone donation form'), 
      'description' => t('Clone donation forms.'), 
    ),
  );
}

/**
 * Implements hook_menu().
 */
function fundraiser_menu() {
  // Paths for fundraiser per node stuff.
  $items['node/%node/fundraiser'] = array(
    'title' => 'Fundraiser',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_confirmation_settings_form', 1),
    'access callback' => 'fundraiser_confirmations_perm',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );
  // MOVE TO CONFIRMATIONS
  $items['node/%node/fundraiser/confirmations'] = array(
    'title' => 'Confirmations',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_confirmation_settings_form', 1),
    'access callback' => 'fundraiser_confirmations_perm',
    'access arguments' => array('update', 1),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  // MOVE TO CONFIRMATIONS
  $items['node/%node/confirmation/%'] = array(
    'title' => 'Webform submission',
    'load arguments' => array(1),
    'page callback' => 'fundraiser_donation_confirmation_page',
    'page arguments' => array(1, 3),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  // Admin paths.
  $items['admin/config/system/fundraiser'] = array(
    'title' => 'Fundraiser settings',
    'description' => t('Configurations for the Fundraiser system.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_admin_settings'),
    'access arguments' => array("administer fundraiser"),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'fundraiser.admin.inc',
  );
  $items['admin/config/system/fundraiser/settings'] = array(
    'title' => 'Fundraiser settings',
    'description' => t('Configurations for the Fundraiser system.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('fundraiser_admin_settings'),
    'access arguments' => array("administer fundraiser"),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'fundraiser.admin.inc',
  );
  // TODO add a donations listing page.
  // To be deactivated if ubercart orders is detected.
  // Off of this page will also be linked donation display, and  refund display.
  // Allowing us to have these features without Ubercart dependancy.
  return $items;
}

/**
 * Implements hook_boost_is_cacheable().
 *
 * If Boost is enabled, make sure donation form nodes aren't cached.
 */
function fundraiser_boost_is_cacheable($parts) {
  $args = $parts['args'];
  if ($args[0] == 'node' && isset($args[1]) && is_numeric($args[1]) && !isset($args[2])) {
    // It's a node, but is it a donation node?
    $node = node_load($args[1]);
    if (fundraiser_is_donation_type($node)) {
      // Don't cache donation forms
      $parts['is_cacheable'] = FALSE;
    }
  }
  return $parts;
}

// TODO come back to fix these. This is no longer how tokens work. vvv
/**      
 * Implementation of hook_token_list().
 */
function fundraiser_token_list($type = 'all') {
  if ($type == 'fundraiser' || $type == 'all') {
    $tokens['fundraiser']['fundraiser-cc-last-four']  = t('The last four digits of the credit card used for the order.');
    $tokens['fundraiser']['fundraiser-cc-card-exp-month'] = t('The credit card expiration month.');
    $tokens['fundraiser']['fundraiser-cc-card-exp-year'] = t('The credit card expiration year.');
    $tokens['fundraiser']['fundraiser-cc-card-type'] = t('The credit card type used for the order.');
  }
  return $tokens;
}

/**
 * Implementation of hook_token_values().
 */
function fundraiser_token_values($type, $object = NULL) {
  $values = array();
  switch ($type) {
    case 'fundraiser':
      $values['fundraiser-cc-last-four'] = substr($object->payment_details['cc_number'], -4);
      $values['fundraiser-cc-card-exp-month'] = $object->payment_details['cc_exp_month'];
      $values['fundraiser-cc-card-exp-year'] = $object->payment_details['cc_exp_year'];
      $values['fundraiser-cc-card-type'] = ucfirst($object->payment_details['cc_type']);
      break;
  }
  return $values;
}
// TODO ^^^

/**
 * Provides an additional mechanism to combine running regular token replacement
 * and token replacement from other sources (webform).
 */
function _fundraiser_replace_tokens($message, $donation) {
  // First replace the normal token set.
  $message = token_replace($message, array('order' => $donation->donation));
  // Then replace based on the glue modules. Specifically for webform, which uses non-standard tokens.
  $message = module_invoke_all('fundraiser_replace_tokens', $message, $donation);
  return $message[0];  // Return the first member of the result array, aka the message.
}

/**
 * Implemenation of hook_mail().
 */
function fundraiser_mail($key, &$message, &$params) {
  switch ($key) {
    case 'fundraiser_cc_notification':
      $body = variable_get('fundraiser_cc_exp_body', 'Your card ending in [cc_last_4] is about to expire on [exp_month]/[exp_year].');
      // Do some token replacements.
      $tokens = array('[exp_month]', '[exp_year]', '[cc_type]', '[cc_last_4]', '[amount]');
      $replaces = array($params['exp_month'], $params['exp_year'], $params['cc_type'], $params['cc_last_4'], $params['amount']);
      $body = str_replace($tokens, $replaces, $body);
      // Replace any user tokens via the token module.
      $body = token_replace($body, 'user', $params['user']);
      $message['subject'] = variable_get('fundraiser_cc_exp_subject', 'Your credit card is about to expire');
      $message['body'] = $body;
      break;
  }
}

/**
 * Implements hook_clone_access_alter() from Node clone module.
 */
function fundraiser_clone_access_alter(&$access, $node) {
  // Remove the access if the user isn't allowed to clone the donation form.
  if (!user_access('clone donation form')) {
    $access = 0;
  }
}

/**
 * Implements hook_clone_node_alter() from Node clone module.
 *
 * From: http://drupal.org/node/1256478
 */
function fundraiser_clone_node_alter(&$node, $context) {
  // Set the internal name.
  $node->internal_name = t('Clone of ') . $context['original_node']->internal_name;
  // The additional load in hook_node_load already will have brought in additional node data.
  // The additional saves in hook_node_insert / hook_node_update will save the additional node data.
}

/**
 * Implements hook_views_api(). From Views module.
 */
function fundraiser_views_api() {
  return array(
    'api' => 2,
  );
}

/**
 * Implementation of hook_access().
 */
function fundraiser_access($op, $node, $account) {
  if (fundraiser_is_donation_type($node->type)) {
    $is_author = $account->uid == $node->uid;
    switch ($op) {
      case 'create':
        return user_access('create donation form', $account) ? TRUE : NULL;
      case 'update':
        return ((user_access('edit own donation form', $account) && $is_author) ||
          user_access('edit any donation form', $account)) ? TRUE : NULL;
      case 'delete':
        return ((user_access('delete own donation form', $account) && $is_author) ||
          user_access('delete any donation form', $account)) ? TRUE : NULL;
    }
  }
}

/**
 * Implements hook_form_alter().
 *
 * Alter content type settings to add "Enable fundraiser?" checkbox.
 */
function fundraiser_form_node_type_form_alter(&$form, &$form_state) {
  if (isset($form['type'])) {
    $form['fundraiser_type'] = array(
      '#type' => 'fieldset',
      '#title' => t('Fundraiser settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    $form['fundraiser_type']['fundraiser'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable fundraiser?'),
      '#default_value' => variable_get('fundraiser_' . $form['#node_type']->type, FALSE),
      '#description' => t('Enable this checkbox if this content type should provide a donation field.'),
    );
  }
}

/**
 * Node API Functions. Handle for each case of node operation.
 */

/**
 * Implements hook_node_delete().
 */
function fundraiser_node_delete($node) {
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_delete_fundraiser($node);
  }
}

/**
 * Implements hook_node_insert().
 */
function fundraiser_node_insert($node) {
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_create_fundraiser($node);
  }
}

/**
 * Implements hook_node_load().
 */
function fundraiser_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    if (fundraiser_is_donation_type($node->type)) {
      // Get the fundraiser information.
      // This also loads additional data presented from other modules to FR.
      // AKA fundraiser_webform and fundraiser_profile data.
      $fundraiser = _fundraiser_get_fundraiser_by_nid($node->nid);
      // Merge data from fundraiser with node.
      $fundraiser = (array) $fundraiser;
      foreach ($fundraiser as $key => $value) {
        $nodes[$node->nid]->$key = $value;
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function fundraiser_node_presave($node) {
  if (fundraiser_is_donation_type($node->type)) {
    // Check the submission to remove the donation amounts marked.
    foreach ($node->amount_wrapper['donation_amounts'] as $index => $donation_amount) {
      // If the remove marker is set.
      if (isset($donation_amount['remove']) && $donation_amount['remove'] == 1) {
         unset($node->amount_wrapper['donation_amounts'][$index]);
      }
      unset($node->amount_wrapper['donation_amounts'][$index]['remove']);
      // Or if the values aren't set.
      if (empty($donation_amount['label']) && empty($donation_amount['amount'])) {
         unset($node->amount_wrapper['donation_amounts'][$index]);
      }
      unset($node->amount_wrapper['donation_amounts'][$index]['remove']);
    }
    // Set the donation amounts where we expect them to be for processing.
    // These are buried under amount_wrapper because we set 'TREE' on that in the form.
    $node->donation_amounts = $node->amount_wrapper['donation_amounts'];
    $node->show_other_amount = $node->amount_wrapper['show_other_amount'];
    $node->minimum_donation_amount = $node->amount_wrapper['minimum_donation_amount'];
    unset($node->amount_wrapper);
  }
}

/**
 * Implements hook_node_update().
 */
function fundraiser_node_update($node) {
  if (fundraiser_is_donation_type($node->type)) {
    _fundraiser_update_fundraiser($node);
  }
}

/**
 * Implements hook_node_validate().
 */
function fundraiser_node_validate($node, $form, &$form_state) {
  if (fundraiser_is_donation_type($node->type)) {
    // If each given amount if numeric, we're ok.
    // Since the form is set to TREE at this point, we need to account for that in our addressing path.
    foreach ($node->amount_wrapper['donation_amounts'] as $index => $donation_amount) {
      if (isset($donation_amount['amount']) && !empty($donation_amount['amount'])) {
        if (!is_numeric($donation_amount['amount'])) {
          form_set_error('donation_amounts', t('Ask amounts must be numeric, you entered "@s".', array("@s" => $donation_amount['amount'])));
          break;
        }
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function fundraiser_node_view($node, $view_mode, $langcode) {
  if (fundraiser_is_donation_type($node->type)) {
    // Track the pageview.
    if ($view_mode == 'full') {
      _fundraiser_update_tracking_value($node->nid, 'pageviews');
    }
    // Check to see if the form is being accessed over HTTPS.
    if ($view_mode == 'full' && (!_fundraiser_is_secure() && !variable_get('fundraiser_development_mode', 0))) {
      // Return a 404 if the page isn't secure and should be.
      watchdog('fundraiser', 'The donation form <em>!title</em> is not protected with SSL.',
        array('!title' => $node->title), WATCHDOG_CRITICAL, l('View the donation form', 'node/' . $node->nid));
      drupal_not_found();
      exit();
    }
    // Set a reminder to turn off development mode on the page view.
    if (variable_get('fundraiser_development_mode', 0) && $view_mode == 'full') {
      drupal_set_message(t('Fundraiser is currently running in development mode. Remember to ' .
        '!link this feature on production websites.',
        array('!link' => l('turn off', 'admin/config/system/fundraiser'))));
    }
  }
  // NOTE: Glue display modules are responsible for using hook_node_view to display themselves with the node.
  // Some, like webform based glue modules, already do the work of displaying on a form themselves.
}

/**
 * Form modification functions.
 */

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node forms.
 */
function fundraiser_form_node_form_alter(&$form, &$form_state, $form_id) {
  if (fundraiser_is_donation_type($form['#node']->type)) {
    _fundraiser_donation_settings_form($form, $form_state);
    // Other modules that need to add to the settings form should also implement
    // hook_form_BASE_FORM_ID_alter, or any of the other form alter hooks.
  }
}

/**
 * Form function. This form collects the information to create donation forms per donation node types.
 *
 * This is added to the node display via form_alter when editting nodes of the correct type.
 *
 * It ultimately populates the fundraiser table from which donation forms are created :
 * nid, gateway, receipt_email_from, receipt_email_address, receipt_email_subject, receipt_email_message,
 * donation_amounts, show_other_amount, minimum_donation_amount, internal_name, confirmation_page_title,
 * confirmation_page_body, confirmation_page_format, redirect_url.
 */
function _fundraiser_donation_settings_form(&$form, &$form_state) {
  // Load the node up from form data so we have everything.
  if (empty($node) && isset($form['#node'])) {
    $node = $form['#node'];
  }
  // Check if this is being called on an enabled node type.
  if (!fundraiser_is_donation_type($node->type)) {
    return;
  }
  // Add additional js and css for this form.
  drupal_add_css(drupal_get_path('module', 'fundraiser') . '/css/fundraiser.css');
  drupal_add_js(drupal_get_path('module', 'fundraiser') . '/js/fundraiser_form.js');
  // Fundraiser values are loaded by hook_node_load() on the node type.
  // So we can safely assume any associated fundraiser information is already available.
  // Now create form elements for everything we need to set.
  $form['internal_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Internal name'),
    '#required' => TRUE,
    '#default_value' => isset($node->internal_name) ? $node->internal_name : '',
    '#weight' => -4.99,
    '#maxlength' => 255,
  );
  $form['fundraiser_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fundraiser settings'),
    '#weight' => -4.96,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $gateway_options = array();
  $gateways = _fundraiser_gateway_info();
  foreach ($gateways as $gateway) {
    $gateway_options[$gateway['id']] = $gateway['title'];
  }
  if (empty($gateway_options)) {
    $gateway_options[-1] = t('No gateways are available. Please configure one.');
  }
  $form['fundraiser_settings']['gateway'] = array(
    '#type' => 'select',
    '#title' => t('Payment Gateway'),
    '#options' => $gateway_options,
    '#weight' => -5,
    '#description' => t('The payment gateway that will be used to process payments for this donation form.'),
    '#default_value' =>  isset($node->gateway) ? $node->gateway : '',
    '#required' => TRUE,
  );
  $form['fundraiser_settings']['amount_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('Ask amounts'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#prefix' => '<div class="clear-block" id="ask-wrapper">',
    '#suffix' => '</div>',
    '#tree' => TRUE, // This is important, this allows the deltas below to function as part of the array.
  );
  $form['fundraiser_settings']['amount_wrapper']['donation_amounts'] = array(
    '#prefix' => '<div id="ask-amounts">',
    '#suffix' => '</div>',
    '#theme' => 'fundraiser_ask_amounts',
  );

  // AJAXy bits.
  $donation_amounts = array();
  // The last submission takes precedence.
  if (isset($form_state['values']['amount_wrapper']['donation_amounts'])) {
    foreach ($form_state['values']['amount_wrapper']['donation_amounts'] as $index => $values) {
      $donation_amounts[] = array($values['amount'], $values['label']);
    }
  }
  else {
    // If the form hasn't been submitted, then grab the defaults from the node or empty.
    // Donation amounts were loaded on node_load, and exploded at that time. If they exist, they're on the node.
    $donation_amounts = isset($node->donation_amounts) ? $node->donation_amounts : array();
    // If not there, then grab some defaults.
    if (count($donation_amounts) == 0) {
      $donation_amounts = array(
        array(10, '$10'), 
        array(20, '$20'),
        array(50, '$50'),
        array(100, '$100'),
      );
    }
  }
  // Default provide one spare blank for users to fill in.
  // If the button clicked was to add another, this line will add an extra field as expected on reload.
  $donation_amounts[] = array('', '');
  // Generate a form set for each existing amount. (To be themed into table format.)
  foreach ($donation_amounts as $donation_amount) {
    // Filter out other|Other combinations. We don't want to display those in this form.
    // And if we did, the value would fail validation (not a number).
    // There is probably a better way to track this, but for now this'll do.
    if ($donation_amount[0] != 'other') {
      $form['fundraiser_settings']['amount_wrapper']['donation_amounts'][] = _fundraiser_ask_form($donation_amount);
    }
  }
  $form['fundraiser_settings']['amount_wrapper']['help'] = array(
    '#value' => '<p>' . t('If you want the user to choose from a predetermined list donation amounts, enter them here. '.
      'If no amounts are entered, a textbox will be displayed for the user to enter a custom amount.') . '</p>',
  );
/*
// Removed for the moment, cause AJAX is NOT cooperating $form_state['values'] is not getting set.
// I have no idea why, the examples given at d.o indicate this is the right way to do this.
  $form['fundraiser_settings']['amount_wrapper']['amount_more'] = array(
    '#type' => 'submit',
    '#value' => t('Add another'),
    '#description' => t('Click here to add more choices.'),
    '#ajax' => array(
      'callback' => '_fundraiser_donation_settings_form_amounts',
      'wrapper' => 'ask-amounts',
      'method' => 'replace',
      'effect' => 'fade',
    ),
  );
*/
  // Additional fundraiser settings.
  $form['fundraiser_settings']['amount_wrapper']['show_other_amount'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show other amount option'),
    '#description' => t('Use this option if you want to provide an "Other Amount" field in conjunction with the list ' .
      'of Donation Amounts.'),
    '#default_value' => isset($node->show_other_amount) ? $node->show_other_amount : '',
  );
  $form['fundraiser_settings']['amount_wrapper']['minimum_donation_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum donation amount'),
    '#description' => t('The minimum acceptable donation amount.'),
    '#default_value' => isset($node->minimum_donation_amount) ? number_format($node->minimum_donation_amount, 2) : variable_get('fundraiser_default_minimum', 10.00),
  );

  // TODO when confirmation are removed, this goes elswhere.
  /* Hidden fields. These are set later on other forms, included here to prevent overwrite during saves. */
  $form['confirmation_page_title'] = array(
    '#type' => 'value',
    '#value' =>  isset($node->confirmation_page_title) ? $node->confirmation_page_title : '',
  );
  $form['confirmation_page_body'] = array(
    '#type' => 'value',
    '#value' => isset($node->confirmation_page_body) ? $node->confirmation_page_body : '',
  );
  $form['receipt_email_from'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_from) ? $node->receipt_email_from : '',
  );
  $form['receipt_email_address'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_address) ? $node->receipt_email_address : '',
  );
  $form['receipt_email_subject'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_subject) ? $node->receipt_email_subject : '',
  );
  $form['receipt_email_message'] = array(
    '#type' => 'value',
    '#value' => isset($node->receipt_email_message) ? $node->receipt_email_message : '',
  );
  $form['redirect_url'] = array(
    '#type' => 'value',
    '#value' => isset($node->redirect_url) ? $node->redirect_url : '',
  );
  //$form['#after_build'][] = '_fundraiser_validation_includes';
}

/**
 * Generate donation ask amount fields, used by donation form
 */
function _fundraiser_ask_form($amount_values = array()) {
  $form['amount'] = array(
    '#type' => 'textfield',
    '#default_value' => isset($amount_values[0]) ? $amount_values[0] : '',
    '#size' => 10,
  );
  $form['label'] = array(
    '#type' => 'textfield',
    '#default_value' => isset($amount_values[1]) ? $amount_values[1] : '',
    '#size' => 30,
  );
  $form['remove'] = array(
    '#type' => 'checkbox',
    '#return_value' => 1,
    '#default_value' => 0,
  );
  return $form;
}

/**
 * Callback handler for the donation ask amount form #ajax.
 */
function _fundraiser_donation_settings_form_amounts($form, $form_state) {
  return $form['fundraiser_settings']['amount_wrapper']['donation_amounts'];
}

/**
 * Donation field definitions.
 */

/**
 * Provides a list of fields to be defined by the display module.
 * And requests additional field information from other modules that need to define them.
 */
function fundraiser_field_info() {
  static $fields;
  // Cache fundraiser content types during page execution.
  if (empty($fields)) {
    // Request additional fields from other modules.
    $fields = module_invoke_all('fundraiser_field_info');
    // Allow for others to modify as needed.
    drupal_alter('fundraiser_field_info', $fields);
  }
  // And return.
  return $fields;
}

/**
 * Asks the display glue module(s) for field information.
 * Allowing other modules to find a field as needed in a form - for example - for AJAX return values.
 */
function fundraiser_find_form_field($form, $field_key) {
  // Expected to return a form render array for the requested form element.
  return module_invoke_all('fundraiser_get_form_field', $form, $field_key);
}

/**
 * Process through given submission fields to validate them. Recursive.
 */
function fundraiser_validate_form_fields($form, $form_state, $submission_fields, $field_info = NULL, $errors = FALSE) {
  // Grab field info, we'll use this all the way down.
  if ($field_info == NULL) {
    $field_info = fundraiser_field_info();
  }
  // Check for errors by field info array.
  $children = element_children($field_info);
  foreach ($children as $child) {
    $keys[$child] = '';
    // Check only if the submission field is set. 
    // And the additional validate callback exists.
    if (isset($submission_fields[$child]) && isset($field_info[$child]['#validate_callback']) && function_exists($field_info[$child]['#validate_callback'])) {
      $error_message = call_user_func($field_info[$child]['#validate_callback'], $form, $form_state, $submission_fields, $submission_fields[$child]);
      if (isset($error_message) && !empty($error_message)) {
        // Set the error.
        form_set_error($child, $error_message);
        $errors = TRUE;
      }
    }
    // Recurse down.
    $errors = fundraiser_validate_form_fields($form, $form_state, $submission_fields, $field_info[$child], $errors);
  }
  return $errors;
}

/**
 * Implements hook_fundraiser_field_info().
 */
function fundraiser_fundraiser_field_info() {
  // Donation amounts are handled in a special case.
  $fields['donation'] = array(
    '#title' => 'Donation',
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['donation']['amount'] = array(
    '#title' => 'Amount',
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 10,
      'field_prefix' => '$',
    ),
    '#create_callback' => '_fundraiser_amount_field_create',
  );
  $fields['donation']['other_amount'] = array(
    '#title' => 'Other',
    '#type' => 'textfield',
    '#required' => 0,
    '#extra' => array(
      'description' => 'Minimum payment $' . variable_get('fundraiser_default_minimum', 10.00) . '.',
      'width' => 10,
      'field_prefix' => '$',
    ),
    '#create_callback' => '_fundraiser_other_amount_field_create', // To be called during field creation.
    '#validate_callback' => '_fundraiser_other_amount_field_validate', // Called during submission of the form to map values.
    // #submit_callback => '', // Called during submission of the form to map values.
  );
  $fields['donor_information'] = array(
    '#title' => 'Your Information',
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['donor_information']['first_name'] = array(
    '#title' => 'First Name',
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['donor_information']['last_name'] = array(
    '#title' => 'Last Name',
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['donor_information']['email'] = array(
    '#title' => 'Email',
    '#type' => 'textfield',
    '#required' => 1,
    '#validate_callback' => '_fundraiser_email_field_validate',
  );
  $fields['billing_information'] = array(
    '#title' => 'Credit Card Billing Information',
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['billing_information']['address'] = array(
    '#title' => 'Address',
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['address_line_2'] = array(
    '#title' => 'Address Line 2',
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['city'] = array(
    '#title' => 'City',
    '#type' => 'textfield',
    '#required' => 1,
  );
   $fields['billing_information']['country'] = array(
    '#title' => 'Country',
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['state'] = array(
    '#title' => 'State/Province',
    '#type' => 'textfield',
    '#required' => 1,
  );
  $fields['billing_information']['zip'] = array(
    '#title' => 'ZIP/Postal Code',
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 10,
      'maxlength' => 5,
    ),
  );
  $fields['credit_card_information'] = array(
    '#title' => 'Credit Card Information',
    '#type' => 'fieldset',
    '#required' => 0,
  );
  $fields['credit_card_information']['card_number'] = array(
    '#title' => 'Card Number',
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'width' => 20,
    ),
  );
  $months = "1|January\n";
  $months .= "2|February\n";
  $months .= "3|March\n";
  $months .= "4|April\n";
  $months .= "5|May\n";
  $months .= "6|June\n";
  $months .= "7|July\n";
  $months .= "8|August\n";
  $months .= "9|September\n";
  $months .= "10|October\n";
  $months .= "11|November\n";
  $months .= "12|December\n";
  $fields['credit_card_information']['card_expiration_month'] = array(
    '#title' => 'Expiration Month',
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $months,
      'multiple' => 0,
      'aslist' => 'Y',
    ),
  );
  $this_year = date('Y');
  $years = $this_year . "\n";
  for ($i = 1; $i <= 5; $i++) {
    $years .= ($this_year + $i) . "\n";
  }
  $fields['credit_card_information']['card_expiration_year'] = array(
    '#title' => 'Expiration Year',
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $years,
      'multiple' => 0,
      'aslist' => 'Y',
    ),
  );
  $fields['credit_card_information']['card_cvv'] = array(
    '#title' => 'Card Security Code',
    '#type' => 'textfield',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'maxlength' => 4,
      'width' => 5,
    ),
  );
  return $fields;
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_amount_field_create($fundraiser, $field) {
  // If donation amounts don't exist, use amount as is.
  if (empty($fundraiser->donation_amounts)) {
    return $field;
  }
  // Since we have an array of donation_amounts, set the field data to match.
  $keys = array_keys($fundraiser->donation_amounts);
  // Construct a set of options based on the configured amounts.
  $formatted_amounts = '';
  foreach ($fundraiser->donation_amounts as $amount => $label) {
    if (!$label) {
      $formatted_amounts .= $amount . '|$' . $amount;
    }
    else {
      $formatted_amounts .= $amount . '|' . $label;
    }
    $formatted_amounts .= "\n";
  }
  if ($fundraiser->show_other_amount && count($fundraiser->donation_amounts)) {
    $formatted_amounts .= 'other|Other';
  }
  // Update the field.
  $field = array(
    '#title' => 'Please select your tax-deductible gift amount below',
    '#type' => 'select',
    '#required' => 1,
    '#extra' => array(
      'description' => '',
      'items' => $formatted_amounts,
      'multiple' => 0,
    ),
    '#value' => $keys[0],
  );
  // Return the field to be created.
  return $field;
}

/**
 * Field callback, called at runtime to update the field with fundraiser specific settings during creation.
 */
function _fundraiser_other_amount_field_create($fundraiser, $field) {
  // If donation amounts don't exist, drop the amount_other field, and use amount as is.
  if (empty($fundraiser->donation_amounts)) {
    return '';
  }
  // If the show other options is disallowed, unset it.
  if (!$fundraiser->show_other_amount) {
    return '';
  }
  // Update the min with fundraiser's min.
  $fields['donation']['other_amount']['#extra']['description'] = 'Minimum payment $' . $fundraiser->minimum_donation_amount . '.';
  // Return the field to be created.
  return $field;
}

/**
 * Validation callback for field other_amount. Called during form validation.
 */
function _fundraiser_other_amount_field_validate($form, $form_state, $submission_fields, $value) {
  $value = $submission_fields['amount'];
  // Look for other amount.
  if ($submission_fields['amount'] == "other") {
    $value = preg_replace("/[^\d\.]/i", "", $submission_fields['other_amount']);
    // Make sure other amount is numeric.
    if (!is_numeric($value)) {
      return t('You must enter a valid donation amount');
    }
  }
  // Check for minimum amount.
  $fundraiser = _fundraiser_get_fundraiser_by_nid($form['#node']->nid);
  $minimum_donation_amount = isset($fundraiser->minimum_donation_amount) ? $fundraiser->minimum_donation_amount : 10;
  $minimum_donation_amount = number_format($minimum_donation_amount, 2);
  if ($value < $minimum_donation_amount) {
    return t('Your donation amount must be greater than or equal to @min_amount.', array('@min_amount' => $minimum_donation_amount));
  }
}

/**
 * Validation callback for field email. Called during form validation.
 */
function _fundraiser_email_field_validate($form, $form_state, $submission_fields,  $value) {
  if (!_fundraiser_validate_email($value)) {
    return t('You must enter a valid email address.');
  }
}

/**
 * Donation form functions.
 */

/**
 * Donation form, display routine on data returned from glue display module.
 * Must be called from glue display module when displaying the donation form.
 */
function fundraiser_donation_form(&$form, &$form_state) {
  // Add validation and submit routines for fundraiser to get called during submission.
  // Otherwise, do nothing, rely on the glue modules to provide the form we need to the user.
  // We add these first to make sure they're available for the hook call.
  $form['#validate'][] = 'fundraiser_donation_validate';
  $form['#submit'][] = 'fundraiser_donation_submit';

  // When confirmations are moved, this goes elsewhere.
  $form['#submit'][] = 'fundraiser_donation_post_submit';
  $form['#submit'][] = 'fundraiser_donation_confirmation';
  // Call hook to allow sub modules to add / manipulate the form.
  $form = module_invoke_all('fundraiser_donation_form', $form, $form_state);
  return $form;
}

/**
 * Donation form, validation routine on data returned from glue display module.
 * Called from glue display module to validate additional data.
 */
function fundraiser_donation_validate(&$form, &$form_state) {
  // Call hook to validate donation values against fundraiser needs and sub module needs.
  // Each is meant to return a not ok response or nothing.
  // No response = we're all good, otherwise we return an array of values for handling.
  $errors = module_invoke_all('fundraiser_donation_validate', $form, $form_state);
  // Then handle our own business.
  if (!empty($errors)) {
    // Call the related donation process function.
    fundraiser_donation_failed_validation($errors);
  }
}

/**
 * Donation form, submission routine on data returned from glue display module.
 * Called from glue display module to submit additional data.
 * NOTE: This is the right function to call repeatedly (with different data as needed)
 * if you need to submit n+ donations on any single submission.
 * Assumption in all of the fundraiser system is that one submission of a form = one donation.
 * So keep that in mind as you work, if you need to make more than one donation at a time
 * then it is better to falsify multiple submissions to the form than to try and shove more than
 * one donation processed per submission.
 */
function fundraiser_donation_submit(&$form, &$form_state) {
  // Create the donation object and load it with the submitted information for the donation.
  $donation = (object) array();
  // Using user load to avoid user object being carried by ref around.
  global $user;
  $donation->uid = $user->uid;
  $donation->user = user_load($user->uid);
  // Load the node from the form.
  $donation->nid = $form['#node']->nid;
  $donation->node = $form['#node'];

  // Call hook to gather submission donation values for the donation.
  module_invoke_all('fundraiser_donation_submit', $form, $form_state, $donation);
  // $donation->submission now contains the submitted values from the form.
  // Once we have a submission we can get to the real meat of things and attempt to create it.
  // This calls our set of functions to process the donation from there.
  if (!empty($donation->submission)) {
    // Create the donation to process, allows other modules to modify results by hooks.
    fundraiser_donation_create($donation);
    // The created donation information should be at at $donation->donation, ready to process.
    fundraiser_donation_process($donation);
    if (!isset($donation->result['message'])) {
      $donation->result['message'] = '';
    }
    // The results should be at $donation->result, ready to respond to the aftermath.
    if (isset($donation->result['success']) && $donation->result['success']) {
      fundraiser_donation_success($donation);
    }
    else {
      $donation->result['success'] = FALSE;
      fundraiser_donation_decline($donation);
    }
  }
  else {
    // No submission was able to be found. So we really have nothing to go on.
    // Mark this as a failure and move on.
    $donation->result['success'] = FALSE;
  }
  // Add the donation and result info to the form_state so we can reference it later.
  $form_state['#donation'] = $donation;
}

/**
 * Submit callback after donation submitted, but before confirmation.
 */
function fundraiser_donation_post_submit(&$form, &$form_state) {
  // And after all of that is done, provide a hook to allow for sub modules to change behavior after submission.
  // Such as in cases of failures or the like. Return the donation object and result.
  // We return form_state here, because we cannot pass arrays by reference in module calls.
  // See: http://drupal.org/node/353494 for a detailed discussion of this one.
  $form_state = module_invoke_all('fundraiser_donation_post_submit', $form, $form_state, $form_state['#donation']);
}

/**
  A donation object takes the form:
stdClass Object
(
    [uid] => Donator User UID
    [user] => User Object
    [nid] => Fundraiser Node NID
    [node] => Node Object
    [sid] =>  Glue Module Provided Submission ID, used by the glue module to track its info.
    [submission] => Array of values by field key as found in fundraiser_field_info() (flattened array).
    [did] => Glue Module Provided Donation ID, used by the glue module to track its info.
    [donation_amount] => Amount to Charge
    [data] => Additional Data for Charge // TODO this may be available on load in Glue, so not need to be passed up.
    [result] => 
        (
            [success] => 1
            [comment] => Card charged, resolution code: 0022548315
            [message] => Credit card payment processed successfully.
            [uid] => 1
        )
)
*/

/**
 * Donation processing functions.
 */

/**
 * Donation processing, a given donation failed to validate.
 */
function fundraiser_donation_failed_validation($errors) {
  // Handle our own tracking.
  _fundraiser_update_tracking_value($errors['nid'], 'local_failures');
  // Call hook to allow sub modules to respond to the failure as well.
  module_invoke_all('fundraiser_donation_failed_validation', $errors);
}

/**
 * Donation processing, a donation needs to be created prior to processing.
 */
function fundraiser_donation_create($donation) {
  // Allow other modules to add additional fields to the order before processing the payment
  module_invoke_all('fundraiser_donation_create_add_data', $donation);
  // Populates $donation->data, $donation->donation with results;
  // Call hooks to create the donation. The glue module handles everything else once handed fundraisers info.
  module_invoke_all('fundraiser_donation_create', $donation);
  // For now, our creation system is responsible for creating a did.
  // TODO - in the future change this, perhaps adding a table to track did to non-fundraiser id.
  // Track the did, nid, uid internally so we can keep things in order.
  $fundraiser_node = node_load($donation->nid);
  $donation_record = array(
    'did' => $donation->did, // Donation id.
    'nid' => $donation->nid, // Fundraiser node id.
    'uid' => $donation->uid,  // Submission user id.
    'gateway' => $fundraiser_node->gateway,
  );
  _fundraiser_create_donation($donation_record);
}

/**
 * Donation processing, a donation needs to be updated with new information prior to processing.
 * For example, in the course of updating a sustainers information.
 */
function fundraiser_donation_update($donation) {
  // Allow other modules to add additional fields to the donation before processing the payment
  module_invoke_all('fundraiser_donation_update_additional', $donation);
  // The additional fields $donation->additional, ready to process.
  // Call hooks to create the donation. The glue module handles everything else once handed fundraisers info.
  module_invoke_all('fundraiser_donation_update', $donation);
  // For now, our creation system is responsible for creating a did.
  // TODO - in the future change this, perhaps adding a table to track did to non-fundraiser id.
  // Track the did, nid, uid internally so we can keep things in order.
  $fundraiser_node = node_load($donation->nid);
  $donation_record = array(
    'did' => $donation->did,
    'nid' => $donation->nid,
    'uid' => $donation->uid,
    'gateway' => $fundraiser_node->gateway,
  );
  _fundraiser_update_donation($donation_record);
  // Refresh the cache. No need to change the donation object passed in, but stored values should be zapped.
  fundraiser_donation_get_donation($donation->did, TRUE);
}

/**
 * Donation processing, a given donation needs to be processed.
 */
function fundraiser_donation_process($donation) {
  // Grab the gateway from the fundraiser configured gateway.
  // Later this will be stored with the donation (since the gateway for the fundraiser may change).
  $info = _fundraiser_gateway_info($donation->node->gateway);
  // Check for the charge function to be defined, either in 'charge_function', or 'credit'.
  $charge_function = isset($info['charge_function']) ? $info['charge_function'] : '';
  if (empty($charge_function)) {
    $charge_function = isset($info['credit']) ? $info['credit'] : '';
  }
  if (empty($charge_function)) {
    // We can't find the gateway and we should tell someone about it.
    watchdog('fundraiser', 'Cannot determine the payment gateway for donation @id. Node id of donation form is @nid',
      array('@id' => $donation->did, '@nid' => $donation->nid), WATCHDOG_CRITICAL);
    $donation->result = array('success' => FALSE, 'message' => 'Cannot determine the payment gateway for this donation.');
  }
  else {
    // Execute the charge, generally implemented under the payment glue module.
    // Allows for multiple responses during this process.
    module_invoke_all('fundraiser_donation_process', $donation, $charge_function);
  }
}

/**
 * Donation processing, a given donation was successful.
 */
function fundraiser_donation_success($donation) {
  // Track the success.
  _fundraiser_update_tracking_value($donation->nid, 'conversions');
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message($donation->result['message']);
  }
  // Allow other modules to respond to the success.
  module_invoke_all('fundraiser_donation_success', $donation);
}

/**
 * Donation processing, a given donation was declined.
 */
function fundraiser_donation_decline($donation) {
  // Track this failure.
  _fundraiser_update_tracking_value($donation->nid, 'gateway_failures');
  // Make a log entry.
  watchdog('fundraiser', 'Donation @id was declined by the payment gateway. Reason: @message',
    array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_DEBUG, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message($donation->result['message']);
  }
  // Allow other modules to respond to the decline.
  module_invoke_all('fundraiser_donation_decline', $donation);
}

// TODO how does this get called?
/**
 * Donation processing, a given donation experienced an exception.
 */
// Is this functionally different from fundraiser_order_decline ? TODO - come back to this - SeH
function fundraiser_donation_exception($donation) {
  // Make a log entry.
  watchdog('fundraiser', 'An error occurred while processing donation @id. Error: @message',
    array('@id' => $donation->did, '@message' => $donation->result['message']), WATCHDOG_ERROR, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message($donation->result['message']);
  }
  // Allow other modules to respond to the exception.
  module_invoke_all('fundraiser_donation_exception', $donation);
}

/**
 * Donation processing, a given donation needs to be cancelled.
 * Generally, only available for Authorize.net gteway donations. For example, during sustainer call.
 */
function fundraiser_donation_cancel($donation) {
  // Make a log entry
  watchdog('fundraiser', 'Donation @id was canceled by the user.',
    array('@id' => $donation->did), WATCHDOG_DEBUG, NULL);
  // Show gateay message if appropriate.
  $display_message = variable_get('fundraiser_gateway_messages', 1);
  if ($display_message) {
    drupal_set_message(t('Your payment has been canceled'));
  }
  // Allow other modules to respond to the cancel. Including Ubercart, etc.
  module_invoke_all('fundraiser_donation_cancel', $donation);
}

/**
 * Donation processing, a given donation needs to be refunded.
 */
function fundraiser_donation_refund($donation) {
  // Grab the gateway from the fundraiser configured gateway.
  // Later this will be stored with the donation (since the gateway for the fundraiser may change).
  $info = _fundraiser_gateway_info($donation->node->gateway);
  // Check for the charge function to be defined, either in 'charge_function', or 'credit'.
  $charge_function = isset($info['charge_function']) ? $info['charge_function'] : '';
  if (empty($charge_function)) {
    $charge_function = isset($info['credit']) ? $info['credit'] : '';
  }
  if (empty($charge_function)) {
    // We can't find the gateway and we should tell someone about it.
    watchdog('fundraiser', 'Cannot determine the payment gateway for donation @id. Node id of donation form is @nid',
      array('@id' => $donation->did, '@nid' => $donation->nid), WATCHDOG_CRITICAL);
    $result = array('success' => FALSE);
  }
  else {
    // Execute the charge, generally implemented under the payment glue module.
    // Allows for multiple responses during this process.
    module_invoke_all('fundraiser_donation_process', $donation, $charge_function);
  }
}

/**
 * Refund form for donations processed with gateways that allow for it.
 */

/**
 * Menu callback for refund tab on donations.
 */
function fundraiser_show_refund_form($did) {
  $base = drupal_get_path('module', 'fundraiser');
  drupal_add_css($base . '/css/refund.css');
  drupal_add_js($base . '/js/refund.js');
  return drupal_get_form('_fundraiser_refund', $did);
}

/**
 * Refund form
 */
function _fundraiser_refund(&$form_state, $did) {
  $form = array();
  // Given a donation ID, grab all relevant information to create the form.
  $donation = fundraiser_donation_get_donation($did);
  $form['#donation'] = $donation;
  $form['payment_summary'] = array(
    '#type' => 'fieldset',
    '#title' => t('Payment Summary'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  // TODO get payment info here. These are purely informational markup.
  if (!$payment_info) {
    $form['payment_summary']['no_payments'] = array(
      '#value' => 'No payments have been made on this order yet',
      '#prefix' => '<div>',
      '#suffix' => '</div>',
    );
  }
  else {
    $form['payment_summary']['payment_number'] = array(
      '#type' => 'item',
      '#title' => t('Payment #'),
      '#value' => $payment_info['receipt_id'],
    );
    $form['payment_summary']['payment_date'] = array(
      '#type' => 'item',
      '#title' => t('Payment Date'),
      '#value' => $payment_info['received'],
    ); 
    $form['payment_summary']['payment_total'] = array(
      '#type' => 'item',
      '#title' => t('Payment Total'),
      '#value' => $payment_info['amount'],
    );
    // TODO get previous refunds here.
    if ($previous_refunds < 0) {
      $form['payment_summary']['total_refunded'] = array(
        '#type' => 'item',
        '#title' => t('Total Previously Refunded'),
        '#value' => $previous_refunds,
      );
    }
  }

  // Form for submitting a refund.
  $form['refund_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Refund Options'),
    '#description' => t('Note that refunds can only be applied to payments that have been settled in the payment processor. This typically ' .
     'happens every night; if the payment was made today, you will probably need to wait until tomorrow to issue a refund.'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  // Only show the refund form if the payment was made through a payment gateway that can handle refunds
  $gateway = $donation->node->gateway; // Set during fundraiser_donation_get_donation(). First from donation info, then fundraiser if not on doantion.
  $can_refund = isset($gateway['credit_refund']) ? $gateway['credit_refund'] : NULL;
  if (!$can_refund || !$payment_info) {
    // They've made a payment, but it cannot be refunded
    if ($payment_info) {
      $no_refund_text = 'Refunds cannot be made on this order. The payment was made on a payment gateway that does not support refunds.';
    }
    // They have NOT made any payment yet, so there's nothing to refund
    else {
      $no_refund_text = 'No payments have been processed on this order, so no refunds can be made yet.';
      // Even once the payment is made, they won't be able to refund it
      if (!$can_refund) {
        $no_refund_text .= ' However, because this order was made on a payment gateway that does not support refunds, you will not be able to ' .
          'make refunds after payments are processed on this order.';
      }
    }
    $form['refund_options']['no_refund_explanation'] = array(
      '#value' => $no_refund_text,
      '#prefix' => '<strong>',
      '#suffix' => '</strong>',
    );
  }
  // Provide refund options
  else {
    $form['refund_options']['full_refund'] = array(
      '#type' => 'radio',
      '#title' => t('Full Refund (%amount)', array('%amount' => $total_paid)),
      '#return_value' => 'full',
      '#parents' => array('refund_type'),
    );
    $form['refund_options']['partial_refund'] = array(
      '#type' => 'radio',
      '#title' => t('Partial Refund'),
      '#return_value' => 'partial',
      '#parents' => array('refund_type'),
    );
    $form['refund_options']['amount'] = array(
      '#type' => 'textfield',
      '#title' => t('Amount to Refund'),
      '#size' => 40,
      '#maxlength' => 255,
    );
    $form['refund_options']['refund_notes'] = array(
      '#type' => 'textarea',
      '#title' => t('Refund Notes'),
      '#description' => t('Please provide reference information about this refund (Requestor, reason, etc.)'),
      '#cols' => 60,
      '#rows' => 5,
      '#required' => TRUE,
    );
    $form['refund_options']['issue_refund'] = array(
      '#type' => 'submit',
      '#value' => t('Issue Refund'),
      '#required' => TRUE,
    );
    $form['total_paid'] = array(
      '#type' => 'hidden',
      '#value' => number_format($total_paid, 2),
    );
  }
  return $form;
}

/**
 * Validate the form
 */
function _fundraiser_refund_validate($form, &$form_state) {
  // Make sure they chose a refund type
  if (empty($form_state['values']['refund_type'])) {
    form_set_error('refund_type', t('Choose a refund type.'));
  }
  // If it isn't a full refund, make sure they entered a valid value
  elseif ($form_state['values']['refund_type'] != 'full') {
    $amount = (float) $form_state['values']['amount'];
    if (!($amount > 0)) {
      form_set_error('amount', t('Enter a refund amount.'));
    }
    else {
      // Make sure they don't try to refund more than was paid
      $did = $form['#donation']->did;
      // Determine how much has been paid, less previous refunds
      // TODO find out how much paid
      $total_paid = '';
      if ($amount > $total_paid) {
        $context = array(
          'revision' => 'formatted-original',
          'type' => 'amount',
        );
        form_set_error('amount', t('The refund amount entered is too high. Only @paid in payments have been made, and no ' .
          'more than that can be refunded.', array('@paid' => $total_paid)));
      }
    }
  }
}

/**
 * Submit the refund form
 */
function _fundraiser_refund_submit($form, &$form_state) {
  // Get the donation.
  $did = $form['#donation']->did;

  // Determine how much has been paid, less previous refunds
  // TODO find out how much paid
  $total_paid = '';

  // Partial refund
  if ($form_state['values']['refund_type'] != 'full') {
    $new_order_status = 'partially_refunded';
    $amount = (float) $form_state['values']['amount'];
    // Can't refund more than they've paid
    // Use >= so that the status is set properly if they choose Partial Refund
    // but refund the entire amount
    if ($amount >= $total_paid) {
      $amount = $total_paid;
      $new_order_status = 'refunded';
    }
  }
  // Full refund
  else {
    $new_order_status = 'refunded';
    $amount = $total_paid;
  }

  // Make the charge amount negative
  $amount = abs($amount) * -1;

  // Get details on the original payment so we can load the payment gateway details
  // TODO move this to a helper function.
  $payment_details = db_query('SELECT gateway, txn_id FROM {fundraiser_webform_order} ' .
    'WHERE order_id = :order_id ' .
    'UNION '.
    'SELECT gateway, txn_id FROM {fundraiser_recurring} '. 
    'WHERE order_id = :order_id', array(':order_id' => $order_id))->fetchObject();

// TODO HOOKS HERE.

  if (module_exists('gateway_manager')) {
    $info = gateway_manager_gateway_info($payment_details->gateway);
    $refund_function = $info['refund_function'];
    $data['config'] = $info['config'];
  }
  else {
    $refund_function = fundraiser_refund_function($node->gateway);
  }
  // call the refund function and store the result
  $result = $refund_function($order_id, $amount, $data);
  if ($result['success']) {
    $receipt_id = module_invoke_all('fundraiser_order_refund', $order_id, $amount, $new_order_status, $result['data']['txn_id'], $form_state['values']['refund_notes']);
    $receipt_id = $receipt_id[0];

    // Save refund data for Fundraiser.
    $refund = new stdClass();
    $refund->order_id = $order_id;
    $refund->receipt_id = $receipt_id;
    $refund->amount = $amount;
    $refund->txn_id = $result['data']['txn_id'];
    $refund->reason = $reason;
    drupal_write_record('fundraiser_refund', $refund);

    // If using the Salesforce queue, queue up the updates
    // This could be on hook couldn't it? - SeH
    if (module_exists('queue_api')) {
      // Update the original order
      sf_queue_insert($order_id, FUNDRAISER_SINGLE_DONATION_TYPE, 'update');
      // Create the refund
      sf_queue_insert($refund->refund_id, FUNDRAISER_DONATION_REFUND_TYPE, 'create');
    }

    drupal_set_message(t('Refund has been issued.'), 'status');
//    drupal_goto('admin/store/orders/' . $order_id);
  }
  else {
    // failed to process credit cart
    $log_error = 'Refund on order ' . $order_id . ' failed gateway validation. Reason: ' . $result['message'];
    watchdog('fundraiser', $log_error, NULL, WATCHDOG_DEBUG, NULL);
    drupal_set_message($result['message']);
    $form_state['rebuild'] = TRUE;
    $form_state['values']['abort'] = TRUE;
  }
}

/**
 * Helper functions.
 */

/**
 * Helper function, given a donation id - get everything that goes with it.
 */
function fundraiser_donation_get_donation($did, $refresh = FALSE) {
  // Pull from cached donation unless we are refreshing the cache.
  static $donations;
  if (!$refresh && isset($donations['did'])) {
    return $donations['did'];
  }
  // If refreshing, or first load, pull all data from database.
  $donation = (object) array();
  $donation->did = $did;
  // Grab basic data from our own systems.
  $donation_record = _fundraiser_get_donation_by_did($did);
  $donation->nid = $donation_record->nid;
  $donation->node = node_load($donation_record->nid);
  $donation->uid = $donation_record->uid;
  $donation->user = user_load($donation_record->uid);
  // Grab gateway information.
  $gateway = _fundraiser_get_donation_gateway($did);
  if (isset($gateway['id'] )) {
    $donation->gateway = $gateway;
    $donation->node->gateway = $gateway;
  }

  // TODO figure out how much has been paind and or refundded and add that here. // START

  // Call hooks to re-create the donation info.
  // The glue modules handle everything else once handed fundraisers info.
  module_invoke_all('fundraiser_donation_get_donation', $donation);
  // Store the donation information into the cache.
  $donations[$did] = $donation;
  return $donation;
}

/**
 * Helper function, given the array from field_info - get the listed keys.
 * WARNING: Recursion is here to walk the field info array to gather form keys.
 */
function _fundraiser_get_field_keys($field_info = NULL, $keys = array()) {
  if ($field_info == NULL) {
    $field_info = fundraiser_field_info();
  }
  $children = element_children($field_info);
  $keys = array_merge($keys, $children);
  foreach ($children as $child) {
    $keys = _fundraiser_get_field_keys($field_info[$child], $keys);
  }
  return $keys;
}

/**
 * Helper function, collects gateway information by calling hook_fundraiser_gateway_info.
 */
function _fundraiser_gateway_info($id = NULL) {
  static $gateways;
  // Cache the gateway during page execution.
  if (empty($gateways)) {
    if (module_exists('gateway_manager')) {
      // If we have the gateway manager turned on, we ask it.
      $gateways = gateway_manager_gateway_info($payment_details->gateway);
    }
    else {
      // If not, we go asking anyone else - usually the payment glue module.
      $gateways = module_invoke_all('fundraiser_gateway_info');
      drupal_alter('fundraiser_gateway_info', $gateways);
    }
  }

  // Look up the gateway needed.
  if ($id != NULL) {
    foreach ($gateways as $key => $gateway) {
      if ($gateway['id'] == $id || $key == $id) {
        return $gateway;
      }
    }
  }
  return (array) $gateways;
}

/** 
 * Helper function, determine if this node type supports donation forms.
 */
function fundraiser_is_donation_type($type) {
  static $fundraiser_types;
  // Cache fundraiser content types during page execution.
  if (!isset($fundraiser_types[$type])) {
    $fundraiser_types[$type] = variable_get('fundraiser_' . $type, FALSE);
  }
  return $fundraiser_types[$type];
}

/**
 * Helper function. Check if the current page is SSL protected.
 */
function _fundraiser_is_secure() {
  return (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') ? TRUE : FALSE;
}

/**
 * Generic helper functions. These may need to go into a diff. module.
 */

/**
 * Helper function, smarter version of array_merge_recursive: overwrites scalar values.
 * @see PHP Manual on: array-merge-recursive comment #82976.
 * Future plans: this may need to be moved to a toolkit module for use by all our modules.
 */
function _fundraiser_array_smart_merge($array, $override) {
  if (is_array($array) && is_array($override)) {
    foreach ($override as $k => $v) {
      if (isset($array[$k]) && is_array($v) && is_array($array[$k])) {
        $array[$k] = _fundraiser_array_smart_merge($array[$k], $v);
      }
      else {
        $array[$k] = $v;
      }
    }
  }
  return $array;
}

/**
 * Helper function, check if given string is an email format. Generically useful function.
 * Future plans: this may need to be moved to a toolkit module for use by all our modules.
 */
function _fundraiser_validate_email($mail) {
  // eregi is depr in PHP 5.3. Replaced with preg_match, adding lower case options.
  return preg_match("/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/", $mail);
}

/**
 * DB functions.
 */

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_create_fundraiser($fundraiser) {
  $fundraiser = (array) $fundraiser;
  $fundraiser_data = FALSE;
  if (isset($fundraiser['nid'])) {
    $fundraiser_data = _fundraiser_get_fundraiser_by_nid($fundraiser['nid']); 
  }
  if (!$fundraiser_data) {
    // Implode donation amounds for saving.
    $imploded_amounts = array();
    foreach ($fundraiser['donation_amounts'] as $donation_amount) {
       $imploded_amounts[] = implode('|', $donation_amount);
    }
    $imploded_amounts = array_unique($imploded_amounts);
    $fundraiser['donation_amounts'] = implode(',', $imploded_amounts);
    // On getting fundraiser this will be exploded into the correct values.
    // After the node is created, add additional data to fundraiser.
    $record = array(
      'receipt_email_from' => variable_get('site_name', ''),
      'receipt_email_address' => variable_get('site_mail', ''),
      'receipt_email_subject' => t('Thank you for your donation'),
      'redirect_url' => '<confirmation>',
    );
    $record = array_merge($record, $fundraiser);
    drupal_write_record('fundraiser', $record);
    // And invoke the hooks for all the other modules to respond.
    module_invoke_all('fundraiser_create_fundraiser_alter', (object) $fundraiser);
  }
  else {
    _fundraiser_update_fundraiser($fundraiser);
  }
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_get_fundraiser_by_nid($nid) {
  // Get fundraiser table information.
  $fundraiser = db_query('SELECT * FROM {fundraiser} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
  if ($fundraiser) {
    // Explode the donation amounts that were imploded during save.
    $donation_amounts = explode(',', $fundraiser->donation_amounts);
    $donation_amounts = array_unique($donation_amounts);
    $exploded_amounts = array();
    foreach ($donation_amounts as $donation_amount) {
      $exploded_amounts[] = explode('|', $donation_amount);
    }
    $fundraiser->donation_amounts = $exploded_amounts;
    // Get values from other modules for additional information.
    module_invoke_all('fundraiser_get_fundraiser_alter', $fundraiser);
  }
  return $fundraiser;
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_update_fundraiser($fundraiser) {
  $fundraiser = (array) $fundraiser;
  $fundraiser_data = FALSE;
  if (isset($fundraiser['nid'])) {
    $fundraiser_data = _fundraiser_get_fundraiser_by_nid($fundraiser['nid']); 
  }
  if (!$fundraiser_data) {
    _fundraiser_create_fundraiser($fundraiser);
  }
  else {
    $fundraiser = array_merge((array) $fundraiser_data, $fundraiser);
    // Implode donation amounds for saving.
    $imploded_amounts = array();
    foreach ($fundraiser['donation_amounts'] as $donation_amount) {
       $imploded_amounts[] = implode('|', $donation_amount);
    }
    $imploded_amounts = array_unique($imploded_amounts);
    $fundraiser['donation_amounts'] = implode(',', $imploded_amounts);
    // On getting fundraiser this will be exploded into the correct values.
    $record = $fundraiser;
    drupal_write_record('fundraiser', $record, 'nid');
    // And invoke the hooks for all the other modules to respond.
    module_invoke_all('fundraiser_update_fundraiser_alter', (object) $fundraiser);
    // Fire a hook that other modules can use to add additional processing when a donation form is created.
    // Called in: fundraiser_multi_currency.module, sf_donation.module
    // This can, and should, be replaced with hook_node_insert() implementations.
    // THIS HOOK IS TO BE DEPR.
    // module_invoke_all('fundraiser_form_insert', $node, $components);
  }
}

/**
 * CRUD style DB function for fundraiser.
 */
function _fundraiser_delete_fundraiser($fundraiser) {
  db_delete('fundraiser')->condition('nid', $fundraiser->nid)->execute();
  // And invoke the hooks for all the other modules to respond.
  module_invoke_all('fundraiser_delete_fundraiser_alter', $fundraiser);
}

/**
 * DB function for fundraiser.
 */
function _fundraiser_get_fundraiser_by_nids($nids) {
  // Get fundraiser table information.
  $fundraisers = array();
  foreach ($nids as $nid) {
    $fundraisers[$nid] = _fundraiser_get_fundraiser_by_nid($nid);
  }
  return $fundraisers;
}

/**
 * DB function for fundraiser.
 */
function _fundraiser_delete_fundraisers($nodes) {
  foreach ($nodes as $node) {
    _fundraiser_delete_fundraiser($node);
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_create_donation($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_get_donation_by_did($donation['did']);
  }
  if (!$donation_data) {
    $record = array_merge((array) $donation_data, $donation);
    drupal_write_record('fundraiser_donation', $record);
  }
  else {
    _fundraiser_update_donation($donation);
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_get_donation_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_donation} ' .
    'WHERE did = :did',
    array(':did' => $did))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_update_donation($donation) {
  // Cast donation just in case.
  $donation = (array) $donation;
  // Check for old data.
  $donation_data = FALSE;
  if (isset($donation['did'])) {
    $donation_data = _fundraiser_get_donation_by_did($donation['did']);
  }
  if (!$donation_data) {
    _fundraiser_create_donation($donation);
  }
  else {
    $record = array_merge((array) $donation_data, $donation);
    drupal_write_record('fundraiser_donation', $record, 'did');
  }
}

/**
 * CRUD style DB function for fundraiser_donation.
 */
function _fundraiser_delete_donation($did) {
  db_delete('fundraiser_donation')->condition('did', $did)->execute();
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_create_refund($refund) {
  // Cast donation just in case.
  $refund = (array) $refund;
  // Check for old data.
  $refund_data = FALSE;
  if (isset($refund['refund_id'])) {
    $refund_data = _fundraiser_get_refund_by_rid($refund['refund_id']);
  }
  if (!$refund_data) {
    $record = $refund;
    drupal_write_record('fundraiser_refund', $record);
  }
  else {
    _fundraiser_update_refund($refund);
  }
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_get_refund_by_rid($rid) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE refund_id = :rid',
    array(':rid' => $rid))->fetchObject();
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_update_refund($refund) {
  // Cast donation just in case.
  $refund = (array) $refund;
  // Check for old data.
  $refund_data = FALSE;
  if (isset($refund['refund_id'])) {
    $refund_data = _fundraiser_get_refund_by_rid($refund['refund_id']);
  }
  if (!$refund_data) {
    _fundraiser_create_refund($refund);
  }
  else {
    $record = array_merge((array) $refund_data, $refund); // Merge data together so we get everything in the record.
    drupal_write_record('fundraiser_refund', $refund, 'refund_id');
  }
}

/**
 * CRUD style DB function for fundraiser_refund.
 */
function _fundraiser_delete_refund($rid) {
  db_delete('fundraiser_recurring')->condition('refund_id', $rid)->execute();
}

/**
 * DB function for fundraiser_refund.
 */
function _fundraiser_get_refund_by_did($did) {
  return db_query('SELECT * FROM {fundraiser_refund} ' .
    'WHERE order_id = :did',
    array(':did' => $did))->fetchAll();
}

/**
 * DB Function, Check if the given order was made on a payment gateway that supports refunds
 */
function _fundraiser_get_donation_gateway($did) {
  $gateway = (object) array();
  // First check the donation table.
  $gateway->gateway = db_query('SELECT d.gateway FROM {fundraiser_donation} d ' .
    'WHERE d.did = :did', array(':did' => $did))->fetchField();
  // Then fall back to the gateway on the original fundraiser.
  if (!isset($gateway) || empty($gateway)) {
    $gateway->gateway = db_query('SELECT f.gateway FROM {fundraiser} f ' .
      'LEFT JOIN {fundraiser_donation} d ON f.nid = d.nid ' .
      'WHERE d.did = :did', array(':did' => $did))->fetchField();
  }
  // Now ask if any other module wants to override this result.
  module_invoke('get_donation_gateway', $did, $gateway);
  // Now translate that into something we can use by getting the rest of the dateway info.
  if (isset($gateway->gateway)) {
    return _fundraiser_gateway_info($gateway->gateway);
  }
  // If nothing has been found, return nothing.
  return array();
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_create_tracking($tracking) {
  $tracking = (array) $tracking;
  $tracking_data = FALSE;
  if (isset($tracking['nid'])) {
    $tracking_data = _fundraiser_get_tracking_by_nid($tracking['nid']);
  }
  if (!$tracking_data) {
    $record = array(
      'pageviews' => 1,
      'conversions' => 0,
      'local_failures' => 0,
      'gateway_failures' => 0,
      'latest_load_time' => 0,
    );
    $record = array_merge($record, $tracking);
    drupal_write_record('fundraiser_tracking', $record);
  }
  else {
    _fundraiser_update_tracking($tracking);
  }
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_get_tracking_by_nid($nid) {
  return db_query('SELECT * FROM {fundraiser_tracking} WHERE nid = :nid', array(':nid' => $nid))->fetchObject();
}
 
/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_update_tracking($tracking) {
  $tracking = (array) $tracking;
  $tracking_data = FALSE;
  if (isset($tracking['nid'])) {
    $tracking_data = _fundraiser_get_tracking_by_nid($tracking['nid']);
  }
  if (!$tracking_data) {
    _fundraiser_create_tracking($tracking);
  }
  else {
    $tracking = array_merge((array) $tracking_data, $tracking);
    drupal_write_record('fundraiser_tracking', $tracking, 'nid');
  }
}

/**
 * CRUD style DB function for fundraiser_tracking.
 */
function _fundraiser_delete_tracking($nid) {
  db_delete('fundraiser_tracking')->condition('nid', $nid)->execute();
}

/**
 * DB function for updating the stats in fundraiser_tracking.
 */
function _fundraiser_update_tracking_value($nid, $field) {
  $tracking = _fundraiser_get_tracking_by_nid($nid);
  // Check to make sure we weren't handed a bad field name.
  if (!$tracking) {
    $tracking->nid = $nid;
    $tracking->$field++;
    _fundraiser_update_tracking($tracking);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//REMOVE ALL BELOW THIS POINT.

/**
 * Adds an order to the Salesforce queue.
 *
 * @param $order
 *   The order to add to the queue.
 */
// TODO: This should really be moved to the SF Donation module where it can listen for new orders being created.
// NAME THIS AS PER: 
function fundraiser_add_to_queue($donation) {
  if (module_exists('queue_api')) {
    if ($donation->donation->recurs == DONATION_RECURRING) {
      sf_queue_insert($order->order_id, FUNDRAISER_RECURRING_DONATION_TYPE, 'create');
    }
    else {
      sf_queue_insert($order->order_id, FUNDRAISER_SINGLE_DONATION_TYPE, 'create');
    }
  }
}
// Called inc ron on donation success charge.
//      // Check for Salesforce Fundraiser module and update order status
//      if (module_exists('sf_donation')) {
//        sf_queue_insert($order->order_id, FUNDRAISER_SINGLE_DONATION_TYPE, 'update');
//      }

/**
 * Implemenation of queue_report_item_name().  TODO where does this come from??
 */
function fundraiser_queue_report_item_title_alter(&$row) {
  if ($row['type'] == 'donation' || $row['type'] == 'recurring_donation') {
    $title = 'Donation ' . $row['oid'];
    $row['title'] = $title;
  }
  elseif ($row['type'] == 'refund') {
    $did = db_query("SELECT order_id FROM {fundraiser_refund} WHERE refund_id = :refund_id",
      array(':refund_id' => $row['oid']))->fetchColumn();
    $title = 'Donation ' . $did;
    $row['title'] = $title;
  }
}

/**
 * Implementation of hook_webform_submission_update()
 * From webform, see http://drupalcontrib.org/api/drupal/contributions--webform--webform_hooks.php/function/hook_webform_submission_update/7
 */
 // TODO this looks like it should be in another module based on what it does, perhaps sf_queue? - SeH 1/12/12
 // Update - move to sf_donation.
function fundraiser_webform_submission_update($node, $submission) {
  if ($node->type == 'donation_form') {
    if (module_exists('queue_api')) {
      $order_id = db_query('SELECT f.order_id FROM {fundraiser_webform_order} f ' .
        'INNER JOIN {uc_orders} u ON u.order_id = f.order_id ' .
        'WHERE f.webform_nid = :webform_nid AND f.sid = :sid AND u.order_status = \'payment_received\'',
        array(':webform_nid' => $node->nid, ':sid' => $submission->sid))->fetchColumn();
      if ($order_id) {
        // Determine if we need an INSERT or an UPDATE
        $action = 'create';
        $sfid = db_query('SELECT sfid FROM {salesforce_management_object_map} WHERE oid = :oid AND drupal_type = \'donation\'', 
          array(':oid' => $order_id))->fetchColumn();
        if ($sfid) {
          $action = 'update';
        }
        sf_queue_insert($order_id, FUNDRAISER_SINGLE_DONATION_TYPE, $action);
      }
    }
  }
}

//TODO move you to another module for profile handling in post submission.
/**
 * Updates the profile of user that submitted the donation.
 */
// NAME THIS AS PER: hook_fundraiser_donation_success();
function fundraiser_update_sf_user_profile($donation) {

  // If the SF Queue API is enabled, insert this user into the queue
  // TODO - hook, move this out to be hookable on update.
  if (module_exists('queue_api')) {
    // Insert user back into queue
    $action = 'update';
    if (empty($update_user->salesforce_contact_id)) {
      $action = 'upsert';
    }
    sf_queue_insert($update_user->uid, 'user', $action);
  }
}

/**
 * Implements hook_fundraiser_donation_update().
 */
function sf_donation_hook_fundraiser_donation_update($donation) {
  // put order back in queue so that amount gets updated in Salesforce
  if (module_exists('sf_donation') && module_exists('queue_api')) {
    sf_queue_insert($donation->did, FUNDRAISER_SINGLE_DONATION_TYPE, 'update');
  }
}

/**
 * Implements hook_fundraiser_donation_cancel().
 */
function sf_donation_fundraiser_donation_cancel($donation) {
  if (module_exists('sf_donation') && module_exists('queue_api')) {
    sf_queue_insert($donation->did, FUNDRAISER_SINGLE_DONATION_TYPE, 'update');
  }
  // call out to saleforce module if installed
  //if (module_exists('sf_donation')) {
  //  sf_donation_canel_recurring_donations($master_order_id);
  //}
}


/**
 * Includes code for updating billing information for recurring donations.
 * Each gateway will require it's own function named GATEWAY_ID_update_billing_information
 * that accepts a payment reference id and billing information.
 * The individual billing update function should return a boolean indicating success or failure
 */
// TODO move this out to Authorizenet module.
/**
 * Authorize.net billing information update function.
 */
function authorizenet_fundraiser_donation_update($donation) {
  $reference_id = $donation->donation->reference_id; // Make sure this is set by the related field.
  $billing_info = ''; // TODO construct this out of the donation info.
  if (module_exists('authorizenet_cim')) {
    return authorizenet_cim_update($reference_id, $billing_info);
  }
  else {
    drupal_set_message(t('Unable to update billing information at this time'));
    watchdog('fundraiser', 'Billing information for recurring donations cannot be updated because the authorize_cim module is missing.', NULL, WATCHDOG_CRITICAL);
    return NULL;
  }
}

/**
 * Sage billing information update function.
 */
// TODO shouldn't this move elsewhere?
function sage_fundraiser_donation_update($donation) {
  $reference_id = $donation->donation->reference_id;
  $billing_info = ''; // TODO construct this out of the donation info.
  $vault_id = db_query("SELECT vault_id from {uc_sage_vault} WHERE guid = :guid", array(':guid' => $reference_id))->fetchColumn();
  $data = array(
    'billing_name' => $billing_info['first_name'] . ' ' . $billing_info['last_name'],
    'billing_street1' => $billing_info['address_1'],
    'billing_street2' => $billing_info['address_2'],
    'billing_city' => $billing_info['city'],
    'billing_zone' => $billing_info['state'],
    'billing_postal_code' => $billing_info['zipcode'],
    'billing_country' => $billing_info['country'],
    'cc_number' => $billing_info['card_num'],
    'cc_exp_month' => sprintf("%02d", $billing_info['card_exp_date']['month']),
    'cc_exp_year' => $billing_info['card_exp_date']['year'],
  );
  $response = uc_sage_vault_update($vault_id, $data);
  // TODO: Need to add some better returns to the uc_sage module
  return TRUE;
}
