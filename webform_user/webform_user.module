<?php
// $Id$

/**
 * @file
 * Allows administrators to create petition webforms.
 */

/**
 * Implementation of hook_menu().
 */
function webform_user_menu() {
  $items['node/%node/webform/user_mapping'] = array(
    'title' => 'User map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_user_mapping_form', 1),
    'access callback' => 'webform_user_mapping_access',
    'access arguments' => array(1),
    'weight' => 30,
    'type' => MENU_LOCAL_TASK,
    'file' => 'webform_user.admin.inc',
  );
  
  $items['admin/config/content/webform-user'] = array(
    'title' => 'Webform user settings',
    'description' => 'Select webform content types that will register or update user accounts when submitted',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webform_user_settings_form'),
    'access arguments' => array('Map webform submissions to Salesforce objects'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'webform_user.admin.inc',
  );
  
  return $items;
}

/**
 * Clone component map settings.
 */
function webform_user_clone_component_map($node, $original_nid) {

  $select = db_select('webform_user_component_map', 'm')
    ->condition('nid', $original_nid, '=')
    ->fields('m', array('cid', 'map_id'));
  $select->addExpression($node->nid, 'nid');

  db_insert('webform_user_component_map')
    ->from($select)
    ->execute();
}

/**
 * Clone webform user node settings.
 */
function webform_user_clone_node($node, $original_nid) {
  $select = db_select('webform_user', 'w')
    ->condition('nid', $original_nid, '=')
    ->fields('w', array(
      'is_webform_user',
      'related_object',
      'foreign_key_field',
      'send_new_user_email',
      'confirmation_page_title',
      'email_field',
  ));
  $select->addExpression($node->nid, 'nid');

  db_insert('webform_user')
    ->from($select)
    ->execute();
  
}


/**
 * Implementation of hook_preprocess_webform_confirmation().
 *
 * Replace any webform component tokens before displaying confirmation page.
 */
function webform_user_preprocess_webform_confirmation(&$vars) {
  if ($vars['node']->is_webform_user) {
    $webform_user = _webform_user_load_webform_user($vars['node']->nid);
    // set title if available
    if (!empty($webform_user['confirmation_page_title'])) {
      drupal_set_title($webform_user['confirmation_page_title']);
    }
    module_load_include('inc', 'webform', 'includes/webform.submissions');
    $submission = webform_get_submission($vars['node']->nid, $vars['sid']);
    $vars['confirmation_message'] = _webform_filter_values($vars['confirmation_message'], $vars['node'], $submission, NULL, FALSE);
  }
}


/**
 * Only show the related object field tab if the form is webform_user and it has been mapped to a salesforce object
 */
function _webform_user_check_settings($op) {
  if ($op == 'Map webform submissions to Salesforce objects') {
    $node = node_load(arg(1));
    if (webform_user_is_webform_user($node) && !empty($node->sf_webform_object)) {
      return TRUE;
    }
  }
  return FALSE;
}


/**
 * Check to see if the current node is webform user.
 *
 * @param $node
 * Node object to test.
 *
 * @return
 * TRUE if node is webform user, otherwise FALSE.
 */
function webform_user_is_webform_user($node) {
  
  if (isset($node->is_webform_user)) {
    return $node->is_webform_user ? TRUE : FALSE;
  }
  
  return FALSE;

}

/**
 * Implements hook_node_validate().
 */
function webform_user_node_validate($node, &$form, &$form_state) {

  if (_webform_user_is_webform_user_node_type($node->type)) {  
    if (isset($form['webform_user']['is_webform_user']['#value']) && !_webform_user_validate_checkbox($form['webform_user']['is_webform_user']['#value'])) {
      form_set_error('is_webform_user', t('Invalid choice for enabling webform user.'));
    }
  }
}


/**
 * Implements hook_node_insert().
 */
function webform_user_node_insert($node) {

  if (isset($node->clone_from_original_nid)) {
    webform_user_clone_component_map($node, $node->clone_from_original_nid);
    webform_user_clone_node($node, $node->clone_from_original_nid);
  }

  if (_webform_user_is_webform_user_node_type($node->type)) {

    if (webform_user_is_webform_user($node)) {
      _webform_user_set_values($node);
      _webform_user_create_webform_components($node);
    }
  }
}

/**
 * Implements hook_node_update().
 */
function webform_user_node_update($node) {

  if (_webform_user_is_webform_user_node_type($node->type)) {

    // If the node hasn't been a webform_user form and it's set to be a webform_user form, make it one.
    $current_node = node_load($node->nid);

    if (!_webform_user_is_webform_user($current_node->nid) && webform_user_is_webform_user($node) && $current_node->webform['components'][1]['form_key'] != 'mail') {
      _webform_user_create_webform_components($node);
    }
        
    // save the values
    _webform_user_set_values($node);
  }
}


/**
 * Implements hook_node_delete().
 */
function webform_user_node_delete($node) {
  if (_webform_user_is_webform_user_node_type($node->type)) {
    _webform_user_delete_node_values($node);
  }
}

/**
 * Implements hook_node_load().
 */
function webform_user_node_load($nodes, $types) {

  $results = db_query('SELECT * FROM {webform_user} WHERE nid IN(:nids)', array(':nids' => array_keys($nodes)), array('fetch' => PDO::FETCH_ASSOC));
  $maps = db_query('SELECT nid, cid, map_id FROM {webform_user_component_map} WHERE nid IN(:nids)', array(':nids' => array_keys($nodes)), array('fetch' => PDO::FETCH_ASSOC));
 
  foreach ($results as $webform_user) {
    
    $nodes[$webform_user['nid']]->is_webform_user = $webform_user['is_webform_user'];
    $nodes[$webform_user['nid']]->send_new_user_email = $webform_user['send_new_user_email'];
    $nodes[$webform_user['nid']]->confirmation_page_title = $webform_user['confirmation_page_title'];

    $map = array();
    foreach ($maps as $row) {
      if ($row['nid'] == $webform_user['nid']) {
        $map[$row['cid']] = $row['map_id'];
      }
    }
    
    $nodes[$webform_user['nid']]->map = $map;
  }
}

function webform_user_save_page_title($form, &$form_state) {
  $title = check_plain($form_state['values']['page_title']);
  $nid = $form_state['values']['nid'];
  
  db_query("UPDATE {webform_user} SET confirmation_page_title = '%s' WHERE nid = %d", $title, $nid);
}

/**
 * Implementation of hook_form_alter().
 */
function webform_user_form_alter(&$form, $form_state, $form_id) {

  if ($form_id == 'webform_configure_form' && isset($form['nid']['#value'])) {
    $node = node_load($form['nid']['#value']);
    if (webform_user_is_webform_user($node)) {
      $webform_user = _webform_user_load_webform_user($form['nid']['#value']);
      $form['submission']['confirmation_wrapper']['page_title'] = array(
        '#type' => 'textfield',
        '#title' => t('Page title'),
        '#weight' => 0,
        '#default_value' => $webform_user['confirmation_page_title'],
      );

      $form['#submit'][] = 'webform_user_save_page_title';
    }
  }
  
  // see if we're on a node type that allows webform user
  // Not sure we need this and can't drop the enable webform user / type to the node type creation level,
  // Instead of having it in a separate admin config page. If we put it here instead,
  // users can mark content types as they make them without having to go to other pages.
  $webform_user_node_types = array_filter(variable_get('webform_user_node_types', array('webform')));
  if ($form_id == 'node_type_form' && in_array($form['#node_type']->type, $webform_user_node_types)) {
    $form['webform_user'] = array(
      '#title' => t('Webform user settings'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    $fields = _webform_user_get_profile_fields();
    $options = array('webform_user_all_profile_fields' => t('All profile fields.'));
    foreach ($fields as $field) {
      $options[$field['name']] = check_plain($field['title']);
    }
    $form['webform_user']['webform_user_default_fields'] = array(
      '#type' => 'checkboxes',
      '#options' => $options,
      '#default_value' => variable_get('webform_user_default_fields_' . $form['#node_type']->type, array('webform_user_all_profile_fields')),
      '#title' => t('Default fields'),
      '#description' => t('Select profile fields to automatically create components for.'),
    ); 
  }

  $webform_user_node_types = array_filter(variable_get('webform_user_node_types', array('webform')));
  // Modify the options on a specific instance of this node type.
  if (in_array(str_ireplace('_node_form', '', $form_id), $webform_user_node_types)) {
    $node = $form['#node'];
    $form['webform_user'] = array(
      '#title' => t('Webform user settings'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    
    $form['webform_user']['is_webform_user'] = array(
      '#title' => t('Create or update users when this webform is submitted.'),
      '#type' => 'checkbox',
      '#default_value' => isset($node->is_webform_user) ? $node->is_webform_user : NULL,
      '#description' => t('When checked, user profile fields will automatically be added to the webform. When the form is submitted, new users will be created using those form values.'),
    );
    
    $form['webform_user']['send_new_user_email'] = array(
      '#title' => t('Send new users a e-mail with their account details.'),
      '#description' => t('If a new user is created during the submission, an email containing their account details will be sent to them.'),
      '#type' => 'checkbox',
      '#default_value' => isset($node->send_new_user_email) ? $node->send_new_user_email : NULL,
    ); 
  }

  if (strpos($form_id, "webform_client") !== FALSE) {
 
    $node = node_load($form['#node']->nid);
    $components = $node->webform['components'];

    global $user;
    $user_data = user_load($user->uid);

    if (user_is_logged_in() && webform_user_is_webform_user($node)) {

     $component_hierarchy = webform_user_parse_components($node->nid, $components);
     $fields = _webform_user_get_profile_fields();

     $map = webform_user_user_map($node->nid);

      foreach ($map as $webform_field => $profile_field) {
        if (array_key_exists($webform_field, $component_hierarchy)) {
 
          $form_field =& webform_user_find_field($form, $component_hierarchy[$webform_field]);
          if (empty($form_field['#default_value']) && isset($user_data->$profile_field)) {
            $profile_value = is_array($user_data->$profile_field) ? '1' : 0;
            if (is_array($user_data->$profile_field)) {
              $current_field = $user_data->$profile_field;
              $profile_value = isset($current_field['und'][0]['value']) ? $current_field['und'][0]['value'] : NULL;
            }
            else {
              $profile_value = $user_data->$profile_field;
            }
          switch ($form_field['#type']) {
              case 'date':
                $form_field['#default_value'] = $profile_value;
                break;
              case 'checkboxes':
                if ($profile_value) { // will be a 0 if unchecked
                  $form_field['#default_value'] = array($profile_value);
                }
                break;
              default:
                $form_field['#default_value'] = check_plain($profile_value);
                break;
            }
          }
        }
      }
    }
  
    // Add a new validation handler.
    $form['#validate'][] = 'webform_user_webform_validate';
    // Add new submit handler.
    $form['#submit'][] = 'webform_user_webform_submit';
  }
}

/**
 * Creates an array to map webform component fields to user profile fields.
 */
function webform_user_user_map($nid) {
  $map = array();
  $result = db_query(
    "
      SELECT w.form_key, c.cid, c.map_id, w.type, f.field_name
      FROM {webform_component} w
      INNER JOIN {webform_user_component_map} c
        ON c.cid = w.cid
        AND c.nid = w.nid
      LEFT JOIN {field_config_instance} f
        ON f.id = c.map_id
      WHERE c.nid = :nid
      ORDER BY c.cid
    ",
    array(':nid' => $nid)
  );
  
  while ($row = $result->fetchObject()) {
    $map[$row->form_key] = $row->field_name ? $row->field_name : $row->map_id;
  }
  
  return $map;
}

/**
 * Return a map of webform components to user profile fields.
 */
function _webform_user_get_map($nid, $fields) {
  $map = webform_user_user_map($nid);
 
  if ($map) {
    foreach ($map as $key => $value) {
      if (isset($fields[$key])) {
        $map2[$value] = $fields[$key];
      }
    }
    
    return $map2;
  }
  return array();
}

/**
 * Automatically maps predefined webform components to user profile fields.
 */
function webform_user_user_map_create($nid, $components) {
  foreach ($components as $cid => $component) {
    if (array_key_exists('maps_to', $component)) {
      db_query("INSERT INTO {webform_user_component_map} (nid, cid, map_id) VALUES (:nid, :cid, :map)", array(
        ':nid' => $nid,
        ':cid' => $cid,
        ':map' => $component['maps_to'])
      );
    }
  }
  drupal_set_message(t('User profile fields have been mapped. Use the User Map tab to edit the map.'));
}

/**
 * Provides access to the mapping tabs if node has webform_user enabled form.
 *
 */
function webform_user_mapping_access($node) {

  $access = webform_user_is_webform_user($node);

  drupal_alter('webform_user_mapping_access', $access);
  return $access;
}



/**
 * Version of profile_save_profile that includes hidden profile fields.
 *
 *  @param $updates
 *  Array of profile fields that have been mapped to webform components.
 *  Key: {profile_fields}.name
 *  Value: value contained in the webform submission.
 *
 *  @param $uid
 *  User object being updated.
 *
 */
function _webform_user_profile_save_profile($updates, $uid) {

   for ($i = 0; $i < count($updates); $i++) {
     $mapped_field = $updates[$i];
     if (_profile_field_serialize($mapped_field['type'])) {
       $mapped_field['data'] = serialize($mapped_field['data']);
     }

     db_query("DELETE FROM {profile_values} WHERE fid = :fid AND uid = :uid", array(
       ':fid' => $mapped_field['fid'],
       ':uid' => $uid)
     );
     db_query("INSERT INTO {profile_values} (fid, uid, value) VALUES (:fid, :uid, :data)", array(
       ':fid' => $mapped_field['fid'],
       ':uid' => $uid,
       ':data' => $mapped_field['data'])
     );
     
     
   }
}

/**
 * Returns a reference to an element of a FAPI array based on a known path.
 */
function &webform_user_find_field(&$form, $path) {
  foreach (array_keys($path) as $v) {
    if (is_array($path[$v]) && count($path[$v])) { // if there are more keys
      return webform_user_find_field($form[$v], $path[$v]);
    }
    else {
      return $form[$v];
    }
  }
}

/**
 * Creates a nested array of where components exist in the FAPI array for all components in a webform.
 * This is needed because the fundraiser module allows the user to move components around. Therefore
 * we must be able to find them if they are not in their usual spot.
 */
function webform_user_parse_components($nid, $components) {

  $component_hierarchy = array();
  foreach ($components as $cid => $component) {
    $component_path = 'submitted[' . implode('][', webform_user_walk_component_hierarchy($nid, $cid)) . ']';
    parse_str($component_path, $output); // convert string to a nested array
    $component_hierarchy[$component['form_key']] = $output;
  }
  return $component_hierarchy;
}

/**
 * Creates a nested array of where a component exists in the FAPI array.
 */
function webform_user_parse_component($nid, $form_key) {


  $results = db_query("SELECT cid FROM {webform_component} WHERE nid = :nid and form_key = :form_key", array(
    ':nid' => $nid,
    ':form_key' => $form_key)
  );
  $cid = $results->fetchColumn();

  $component_path = 'submitted[' . implode('][', webform_user_walk_component_hierarchy($nid, $cid)) . ']';
  parse_str($component_path, $output); // convert string to a nested array
  return $output;
}

/**
 * Builds a path from the webform component to it's topmost parent.
 */
function webform_user_walk_component_hierarchy($nid, $cid, $path = array()) {

  $result = db_query('SELECT cid, pid, form_key FROM {webform_component} WHERE nid = :nid and cid = :cid', array(
    ':nid' => $nid,
    ':cid' => $cid)
  );
  while ($data = $result->fetchObject()) {
    array_unshift($path, $data->form_key);
    if ($data->pid > 0) {
      webform_user_walk_component_hierarchy($nid, $data->pid, $path);
    }
  }
  return $path;
}

function _webform_user_add_webform_defaults(&$node, &$user) {
  // Reload user object to ensure profile field values are present.
  $account = user_load($user->uid);
  
  $fields = _webform_user_get_profile_fields();
  foreach ($node->webform['components'] as $ckey => $component) {
    foreach ($fields as $fkey => $field) {
      // Handle e-mail.
      if ($component['form_key'] == 'mail') {
        $node->webform['components'][$ckey]['value'] = check_plain($account->mail);
      }
      // Handle custom profile fields.
      elseif ($component['form_key'] == $field['name'] && isset($account->$component['form_key'])) {
        if ($field['type'] == 'checkbox') {
          $node->webform['components'][$ckey]['value'] = $component['form_key'];
        }
        else {
          $node->webform['components'][$ckey]['value'] = check_plain($account->$component['form_key']);
        }

        unset($fields[$fkey]);
      }
    }
  }
}

/**
 * Validates the user webform submission.
 */
function webform_user_webform_validate($form, &$form_state) {
  $node = node_load($form_state['values']['details']['nid']);
  $fields = _webform_user_flatten_tree($form_state['values']['submitted'], $node->nid);
  if (webform_user_is_webform_user($node) && !_webform_user_validate_email($fields['mail'])) {
    form_set_error('mail', t('Please enter a valid email address.'));
  }
}

/**
 * Process webform submissions.
 */
function webform_user_webform_submit($form, &$form_state) {
  global $user;
  $account = new stdClass;
  $node = node_load($form_state['values']['details']['nid']);

  // Only process if the form is completed and it's a webform_user form.
  $submit_op = empty($node->webform['submit_text']) ? t('Submit') : $node->webform['submit_text'];

  if ($form_state['values']['op'] == $submit_op && webform_user_is_webform_user($node)) {
    $fields = _webform_user_flatten_tree($form_state['values']['submitted_tree'], $node->nid);
    $map = _webform_user_get_map($form_state['values']['details']['nid'], $fields);
    $results = db_query("SELECT uid FROM {users} WHERE mail= ':mail'", array(':mail' => $fields['mail']));
    $account_uid = $results->fetchColumn();
    if ($account_uid) {
      $account = user_load($account_uid);
    }
    // Authenticated user, update if this isn't an edit.
    if ($user->uid && $form_state['redirect']) {
      // Update the existing user account.
      _webform_user_save_profile_map($user->uid, $map);
    }
    // Anonymous user with matching email address.
    elseif (isset($account->uid) && $form_state['redirect']) {

      // Update the existing user account.
      _webform_user_save_profile_map($account->uid, $map);
      $sid = $form_state['values']['details']['sid'];
      db_query("UPDATE {webform_submissions} SET uid = :uid WHERE sid = :sid", array(
        ':uid' => $account->uid,
        ':sid' => $sid)
      );
    }
    // Anonymous user, new to Drupal.
    elseif ($form_state['redirect']) {
      // Register the user.
      $user_fields = array(
        'name' => $fields['mail'],
        'mail' => $fields['mail'],
        'init' => $fields['mail'],
        'pass' => user_password(8),
        'status' => 1,
      );
      $account = user_save('', $user_fields);
      
      // Update the new user account.
      _webform_user_save_profile_map($account->uid, $map);
      // Update the submission record with the id of the new user
      $sid = $form_state['values']['details']['sid'];
      db_query("UPDATE {webform_submissions} SET uid = :uid WHERE sid = :sid", array(
        ':uid' => $account->uid,
        ':sid' => $sid)
      );
      
      // Send the e-mail through the user module.
      if ($node->send_new_user_email) {
        // Manually set the password so it appears in the e-mail.
        $account->password = $user_fields['pass'];
        drupal_mail('user', 'register_no_approval_required', $user_fields['mail'], NULL, array('account' => $account), NULL);
      }
    }
  }
}


/**
 * Implements hook_webform_submission_presave().
 *
 * We're using this to prevent webform from changing the owner of a submission when a webform_user submission is edited.
 */
function webform_user_webform_submission_presave($node, &$submission) {
  
  if (webform_user_is_webform_user($node) && isset($submission->sid)) {
    $results = db_query('SELECT uid FROM {webform_submissions} where sid = :sid', array(':sid' => $submission->sid));
    $uid = $results->fetchColumn();
    if ($uid) {
      $submission->uid = $uid;
    }
  }
}

/**
 * Validates an e-mail address.
 *
 * @param $mail
 *   The e-mail address to validate.
 * @return
 *   Returns TRUE if the e-mail address is valid; FALSE otherwise.
 */
function _webform_user_validate_email($mail) {
  return preg_match("/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/", $mail);
}

/**
 * Flatten a tree into a flat list. Note: date values are not flattened.
 */
function _webform_user_flatten_tree($tree, $nid = NULL) {
  $items = array();

  foreach ($tree as $key => $val) {
    // look up the type of component
    $results = db_query("SELECT type FROM {webform_component} WHERE nid = :nid AND form_key = :form_key", array(
      ':nid' => $nid,
      ':form_key' => $key)
    );
    $type = $results->fetchColumn();
    
    if (is_array($val)) {
      // If it's a date, don't flatten the value.
      if ($type == 'date') {
        if ($val[0] && $val[1] && $val[2]) {
          $val['month'] = $val[0];
          $val['day'] = $val[1];
          $val['year'] = $val[2];
          unset($val[0], $val[1], $val[2]);
          $items[$key] = $val;
        }
        else {
          continue;
        }
      }
      elseif ($type == 'select') {
        $values = array();
        foreach ($val as $k => $v) {
          $values[] = $v;
        }
        if (count($values) == 1) { // single item select (aka checkbox)
          $items[$key] = array_shift($values);
        }
        elseif (count($values) == 0) { // no value, reset
          $items[$key] = NULL;
        }
        else {
          $items[$key] = $values;
        }
      }
      else {
        $items = array_merge($items, _webform_user_flatten_tree($val, $nid));
      }
    }
    elseif (!empty($val)) {
      $items[$key] = $val;
    }
  }

  return $items;
}

/*
 * Saves mapped profile data
 */
function _webform_user_save_profile_map($uid, &$map) {

  if ($map) {
    global $user;
    $map_keys = array_keys($map);
    $edit = array();
    
    if ($user->uid == 0) {
      $account = user_load($uid);
    }
    else {
      $account = $user;
    }
    
    $profile_fields = _webform_user_get_profile_fields();

    foreach ($profile_fields as $field) {

      switch ($field['type']) {
        case 'text':
        case 'hidden':
        case 'list_text':
        case 'list_integer':
          if (in_array($field['name'], $map_keys)) {
            $edit[$field['name']] = array(
              'und' => array(
                0 => array(
                  'value' => $map[$field['name']],
                ),
              ),
            );
          }
          break;
        // TODO: track down format for nonstandard fields like "link" and "email"
      }
  
    }
    if (count($edit) && $account->uid) {
      user_save($account, $edit);
    }
  }
}


/**
 * Checks to see if a checkbox value is valid.
 *
 * @param $value
 *   The submitted value of a checkbox.
 * @return bool
 *   TRUE if valid; FALSE otherwise.
 */
function _webform_user_validate_checkbox($value) {
  if ($value !== 0 || $value !== 1) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

function _webform_user_load_webform_user($nid) {
  $result = db_query("SELECT * FROM {webform_user} WHERE nid = :nid", array(':nid' => $nid));
  return (array) $result->fetchObject();
}

/**
 * Checks to see if the is_webform_user checkbox is enabled for the selected node.
 *
 * @param $nid
 *   The ID of the selected node, the node object or the node type
 * @return bool
 *   Returns TRUE if is_webform_user is enabled, FALSE otherwise.
 */
function _webform_user_is_webform_user($nid) {
  $result = db_query('SELECT is_webform_user FROM {webform_user} WHERE nid = :nid', array(':nid' => $nid));
  $is_webform_user = $result->fetchColumn();
  return $result['is_webform_user'] == 1 ? TRUE : FALSE;
}

function _webform_user_is_webform_user_node_type($type) {
  $webform_user_node_types = array_filter(variable_get('webform_user_node_types', array('webform')));
  
  return in_array($type, $webform_user_node_types) ? TRUE : FALSE;
}


/**
 * Saves the values of the is_webform_user checkbox when the selected node is created.
 *
 * @param $node
 *   An object representation of the selected node.
 *
 * @return unknown_type
 */
function _webform_user_set_values(&$node) {
  $is_webform_user = $node->is_webform_user ? TRUE : FALSE;

  $send_new_user_email = $node->send_new_user_email ? 1 : 0;

  $result = db_query("SELECT count(*) FROM {webform_user} WHERE nid = :nid", array(':nid' => $node->nid));
  $exists = $result->fetchColumn();

  if (!$exists && $is_webform_user) {
    db_query(
      "INSERT INTO {webform_user} (nid, is_webform_user, send_new_user_email)
       VALUES (:nid, :is_webform_user, :send_new_user_email)",
      array(
        ':nid' => $node->nid,
        ':is_webform_user' => $is_webform_user,
        ':send_new_user_email' => $send_new_user_email
      )
    );

  }
  else {
    db_update('webform_user')
      ->fields(array(
        'is_webform_user' => $is_webform_user,
        'send_new_user_email' => $send_new_user_email,
      ))
      ->condition('nid', $node->nid)
      ->execute();
  }
}


/**
 * Clears data from the webform_user and webform_user_component_map tables when a node is deleted.
 *
 * @param $node
 *   An object representation of the selected node.
 */
function _webform_user_delete_node_values($node) {
  db_query('DELETE FROM {webform_user} WHERE nid = :nid', array(':nid' => $node->nid));
  // added garbage collection on the webform user component map table.
  db_query('DELETE FROM {webform_user_component_map} WHERE nid = :nid', array('nid' => $node->nid));
}

/**
 * Creates a machine-readable version of a given name.
 *
 * @param $name
 *   The name for which you'd like to create a normalized name.
 * @return string
 *   The normalized name.
 */
function _webform_user_normalize_name($name) {
  // make lowercase, drop special chars, replace spaces with underscores
  return preg_replace(array('/[^a-z0-9_\s]/', '/\s+/'), array('', '_'), strtolower($name));
}


/**
 * Fetch an array of user profile fields.
 */
function _webform_user_get_profile_fields() {
 
  $fields = array();
  $entity_types = array('user');
  
  if (module_exists('profile2')) {
    $entity_types[] = 'profile2';
  }

  $results = db_query(
    'SELECT i.id, i.field_name, i.data, c.data as extra, c.type
     FROM {field_config_instance} i
     INNER JOIN {field_config} c
       ON i.field_name = c.field_name
     WHERE entity_type IN (:types)',
    array(':types' => $entity_types)
  );
    
  foreach ($results as $result) {
    $result->data = unserialize($result->data);
    $result->extra = unserialize($result->extra);
    $field['fid'] = $result->id;
    $field['title'] = $result->data['label'];
    $field['name'] = $result->field_name;
    $field['type'] = $result->type;
    $field['explanantion'] = $result->data['description'];
    $field['category'] = NULL;
    $field['value'] = isset($result->data['default_value']['value']) ? $result->data['default_value'][0]['value'] : NULL;
    $field['weight'] = $result->data['widget']['weight'];
    $field['mandatory'] = $result->data['required'] ? $result->data['required'] : 0;
    $field['visibility'] = NULL;
    $field['options'] = isset($result->extra['settings']['allowed_values']) ? $result->extra['settings']['allowed_values'] : NULL;
    $fields[] = $field;
  }

  // Grab settings from D7 profile (straight install).
  $categories = _user_categories();
  foreach ($categories as $category) {
    $profile_fields = _profile_get_fields($category['name'], FALSE);
    foreach ($profile_fields as $profile_field) {
      $field = (array) $profile_field;
      $field['mandatory'] = $profile_field->required ? $profile_field->required : 0;
      $field['value'] = NULL;
      $fields[] = $field;
    }
  }
  return $fields;
}


/**
 * Creates Webform components for the selected Webform node. One component for each user profile field + a
 * component for email address.
 *
 * @param $node
 *   An object representation of the selected node.
 */
function _webform_user_create_webform_components(&$node) {

  // include webform component functions
  module_load_include('inc', 'webform', 'includes/webform.components');

  $items = array();
  $fieldset_lookup = array();

  // Add the e-mail field.
  $mail_field = array(
    'nid' => $node->nid,
    'pid' => 0,
    'form_key' => 'mail',
    'name' => 'E-mail address',
    'type' => 'textfield',
    'mandatory' => 1,
    'weight' => 0,
    'email' => 1,
    'extra' => array(
      'description' => '',
    ),
  );

  $cid = webform_component_insert($mail_field);
    
  // Add the component mapping record
  $map = array(
    'nid' => $node->nid,
    'cid' => $cid,
    'map_id' => 'mail',
  );
  drupal_write_record('webform_user_component_map', $map);


  // Process non-fieldset results.
  $fields = _webform_user_get_profile_fields();
  drupal_alter('webform_user_get_profile_fields', $fields);

  $all = FALSE;
  $default_fields = variable_get('webform_user_default_fields_' . $node->type, array('webform_user_all_profile_fields'));
  if (empty($default_fields) || in_array('webform_user_all_profile_fields', $default_fields)) {
    $all = TRUE;
  }
  foreach ($fields as $field) {
    // Filter our fields only to those marked in the profile configuration for this
    // node type. Users can always add more as needed, this is just for default configurations.
    if ($all || in_array($field['name'], $default_fields)) {
      // Create a Webform component array for the field.
      $item = array(
        'nid' => $node->nid,
        'form_key' => str_replace('profile_', '', $field['name']),
        'pid' => 0,
        'name' => $field['title'],
        'type' => $field['type'],
        'mandatory' => $field['mandatory'],
        'weight' => $field['weight'],
        'email' => 1,
        'extra' => array(
          'description' => isset($field['explanation']) ? $field['explanation'] : '',
        ),
      );

      // Transform the component array for certain field types.
      switch ($item['type']) {
        case 'checkbox':
          $item['type'] = 'select';
          $item['extra']['items'] = $field['name'] . '|' . $field['title'];
          $item['extra']['aslist'] = 0;
          $item['extra']['multiple'] = 'Y';
          break;

        case 'list':
          $item['type'] = 'textarea';
          break;

        case 'text':
          $item['type'] = 'textfield';
          break;
        case 'list_text':
        case 'list_integer':
        case 'list_float':
          $field['options'] = _webform_user_implode_options($field['options']);
          $item['type'] = 'select';
          $item['extra']['items'] = $field['options'];
          $item['extra']['aslist'] = 'Y';
          $item['extra']['multiple'] = 0;
          break;

        case 'url':
          $item['type'] = 'textfield';
          break;
      }

      // Add the component to the Webform.
      $cid = webform_component_insert($item);

      // Add the component mapping record
      $map = array(
        'nid' => $node->nid,
        'cid' => $cid,
        'map_id' => $field['name'],
      );
      drupal_write_record('webform_user_component_map', $map);
    }
  }
}


/**
 * Convert an associative array into a formatted string suitable for consumption by a
 * webform select component.
 *
 * @param $options
 * associative array containing the value and label of each select box option.
 * Format: $options = array('value' => 'label')
 *
 */
function _webform_user_implode_options($options) {
  $formatted_options = '';
  if (is_array($options)) {
    foreach ($options as $key => $value) {
      $formatted_options .= "$key|$value\n";
    }
  }
  return $formatted_options;
}

// TODO: examine this closely and remove or refactor salesforce-specific code. This should be in a SF-specific module.
/**
 * Implementation of queue_batch_item_alter().
 */
function webform_user_queue_batch_item_alter(&$object, $type, $action, $oid) {
  if ($type == 'webform_user' && $action == 'create') {
    $relationship = _webform_user_get_relationship($oid);
    if (!empty($relationship)) {
      $user = _webform_user_load_user_salesforce_ids($oid);
      if ($relationship->related_object == 'account') {
        $id = $user->salesforce_account_id;
      }
      elseif ($relationship->related_object == 'contact') {
        $id = $user->salesforce_contact_id;
      }
      
      // continue if we've got an id
      if ($id) {
        // add the extra relationship field
        $object[$relationship->foreign_key_field] = $id;
      }
    }
  }
}



